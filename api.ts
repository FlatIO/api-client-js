/* tslint:disable */
/* eslint-disable */
/**
 * Flat API
 * The Flat API allows you to easily extend the abilities of the [Flat Platform](https://flat.io), with a wide range of use cases including the following:  * Creating and importing new music scores using MusicXML, MIDI, Guitar Pro (GP3, GP4, GP5, GPX, GP), PowerTab, TuxGuitar and MuseScore files * Browsing, updating, copying, exporting the user\'s scores (for example in MP3, WAV or MIDI) * Managing educational resources with Flat for Education: creating & updating the organization accounts, the classes, rosters and assignments.  The Flat API is built on HTTP. Our API is RESTful It has predictable resource URLs. It returns HTTP response codes to indicate errors. It also accepts and returns JSON in the HTTP body. The [schema](/swagger.yaml) of this API follows the [OpenAPI Initiative (OAI) specification](https://www.openapis.org/), you can use and work with [compatible Swagger tools](http://swagger.io/open-source-integrations/). This API features Cross-Origin Resource Sharing (CORS) implemented in compliance with [W3C spec](https://www.w3.org/TR/cors/).  You can use your favorite HTTP/REST library for your programming language to use Flat\'s API. This specification and reference is [available on Github](https://github.com/FlatIO/api-reference).  Getting Started and learn more:  * [API Overview and introduction](https://flat.io/developers/docs/api/) * [Authentication (Personal Access Tokens or OAuth2)](https://flat.io/developers/docs/api/authentication.html) * [SDKs](https://flat.io/developers/docs/api/sdks.html) * [Rate Limits](https://flat.io/developers/docs/api/rate-limits.html) * [Changelog](https://flat.io/developers/docs/api/changelog.html) 
 *
 * The version of the OpenAPI document: 2.20.0
 * Contact: developers@flat.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * An API access token
 * @export
 * @interface ApiAccessToken
 */
export interface ApiAccessToken {
    /**
     * Unique identifier of this private token
     * @type {string}
     * @memberof ApiAccessToken
     */
    'id'?: string;
    /**
     * Name of the personal access token
     * @type {string}
     * @memberof ApiAccessToken
     */
    'name'?: string;
    /**
     * The token. This token will only be returned once, then only the first 4 characters will be returned. 
     * @type {string}
     * @memberof ApiAccessToken
     */
    'token'?: string;
    /**
     * The date then this token was issued 
     * @type {string}
     * @memberof ApiAccessToken
     */
    'issuedDate'?: string;
    /**
     * The date then this token will expire 
     * @type {string}
     * @memberof ApiAccessToken
     */
    'expirationDate'?: string;
    /**
     * The list of scopes associated to the token 
     * @type {Array<AppScopes>}
     * @memberof ApiAccessToken
     */
    'scopes'?: Array<AppScopes>;
}
/**
 * Available scopes
 * @export
 * @enum {string}
 */

export const AppScopes = {
    AccountPublicProfile: 'account.public_profile',
    AccountEmail: 'account.email',
    AccountEducationProfile: 'account.education_profile',
    ScoresReadonly: 'scores.readonly',
    ScoresSocial: 'scores.social',
    Scores: 'scores',
    CollectionsReadonly: 'collections.readonly',
    CollectionsAddScores: 'collections.add_scores',
    Collections: 'collections',
    EduResources: 'edu.resources',
    EduResourcesReadonly: 'edu.resources.readonly',
    EduClasses: 'edu.classes',
    EduClassesReadonly: 'edu.classes.readonly',
    EduAssignments: 'edu.assignments',
    EduAssignmentsReadonly: 'edu.assignments.readonly',
    EduAdmin: 'edu.admin',
    EduAdminLti: 'edu.admin.lti',
    EduAdminLtiReadonly: 'edu.admin.lti.readonly',
    EduAdminUsers: 'edu.admin.users',
    EduAdminUsersReadonly: 'edu.admin.users.readonly',
    TasksReadonly: 'tasks.readonly'
} as const;

export type AppScopes = typeof AppScopes[keyof typeof AppScopes];


/**
 * Assignment details
 * @export
 * @interface Assignment
 */
export interface Assignment {
    /**
     * Unique identifier of the assignment
     * @type {string}
     * @memberof Assignment
     */
    'id': string;
    /**
     * 
     * @type {AssignmentType}
     * @memberof Assignment
     */
    'type': AssignmentType;
    /**
     * 
     * @type {AssignmentCopyResponseCapabilities}
     * @memberof Assignment
     */
    'capabilities': AssignmentCopyResponseCapabilities;
    /**
     * Title of the assignment
     * @type {string}
     * @memberof Assignment
     */
    'title': string;
    /**
     * Description and content of the assignment
     * @type {string}
     * @memberof Assignment
     */
    'description'?: string;
    /**
     * The URL of the cover to display
     * @type {string}
     * @memberof Assignment
     */
    'cover'?: string;
    /**
     * The id of the cover to display
     * @type {string}
     * @memberof Assignment
     */
    'coverFile'?: string;
    /**
     * 
     * @type {Array<MediaAttachment>}
     * @memberof Assignment
     */
    'attachments': Array<MediaAttachment>;
    /**
     * For all assignments created after 02/2023, all the underlying resources must be dedicated and stored in the assignment. This boolean indicates that this assignment only supports dedicated attachments. 
     * @type {boolean}
     * @memberof Assignment
     */
    'useDedicatedAttachments'?: boolean;
    /**
     * If set, the grading will be enabled for the assignement 
     * @type {number}
     * @memberof Assignment
     */
    'maxPoints'?: number;
    /**
     * For worksheets, how grading will work for the assignment: - If set to `auto`, the grades will be automatically released when the student submits the submissions - If set to `manual`, the grades will only be set as `draftGrade` and will be released when the teacher returns the submissions 
     * @type {string}
     * @memberof Assignment
     */
    'releaseGrades'?: AssignmentReleaseGradesEnum;
    /**
     * Mixing worksheets exercises for each student
     * @type {boolean}
     * @memberof Assignment
     */
    'shuffleExercises'?: boolean;
    /**
     * The id of the associated toolset
     * @type {string}
     * @memberof Assignment
     */
    'toolset'?: string;
    /**
     * The number of playback authorized on the scores of the assignment.
     * @type {number}
     * @memberof Assignment
     */
    'nbPlaybackAuthorized'?: number;
}

export const AssignmentReleaseGradesEnum = {
    Auto: 'auto',
    Manual: 'manual'
} as const;

export type AssignmentReleaseGradesEnum = typeof AssignmentReleaseGradesEnum[keyof typeof AssignmentReleaseGradesEnum];

/**
 * 
 * @export
 * @interface AssignmentCopy
 */
export interface AssignmentCopy {
    /**
     * The destination classroom where the assignment will be copied
     * @type {string}
     * @memberof AssignmentCopy
     */
    'classroom': string;
    /**
     * An optional destination assignment where the original assignement will be copied. Must be a draft.
     * @type {string}
     * @memberof AssignmentCopy
     */
    'assignment'?: string;
    /**
     * The publication (scheduled) date of the assignment. If this one is specified, the assignment will only be listed to the teachers of the class. Alternatively the existing `scheduledDate` from the copied assignment will be used. 
     * @type {string}
     * @memberof AssignmentCopy
     */
    'scheduledDate'?: string;
    /**
     * Identifier of the parent resource where the new one will created, e.g. a folder id or `root`
     * @type {string}
     * @memberof AssignmentCopy
     */
    'libraryParent': string;
    /**
     * Option to check if the assignment is already in Resource Library
     * @type {boolean}
     * @memberof AssignmentCopy
     */
    'verifyIfNotAlreadyInResourceLibrary'?: boolean;
}
/**
 * 
 * @export
 * @interface AssignmentCopyResponse
 */
export interface AssignmentCopyResponse {
    /**
     * Unique identifier of the assignment
     * @type {string}
     * @memberof AssignmentCopyResponse
     */
    'id': string;
    /**
     * 
     * @type {AssignmentType}
     * @memberof AssignmentCopyResponse
     */
    'type': AssignmentType;
    /**
     * 
     * @type {AssignmentCopyResponseCapabilities}
     * @memberof AssignmentCopyResponse
     */
    'capabilities': AssignmentCopyResponseCapabilities;
    /**
     * Title of the assignment
     * @type {string}
     * @memberof AssignmentCopyResponse
     */
    'title': string;
    /**
     * Description and content of the assignment
     * @type {string}
     * @memberof AssignmentCopyResponse
     */
    'description'?: string;
    /**
     * The URL of the cover to display
     * @type {string}
     * @memberof AssignmentCopyResponse
     */
    'cover'?: string;
    /**
     * The id of the cover to display
     * @type {string}
     * @memberof AssignmentCopyResponse
     */
    'coverFile'?: string;
    /**
     * 
     * @type {Array<MediaAttachment>}
     * @memberof AssignmentCopyResponse
     */
    'attachments': Array<MediaAttachment>;
    /**
     * For all assignments created after 02/2023, all the underlying resources must be dedicated and stored in the assignment. This boolean indicates that this assignment only supports dedicated attachments. 
     * @type {boolean}
     * @memberof AssignmentCopyResponse
     */
    'useDedicatedAttachments'?: boolean;
    /**
     * If set, the grading will be enabled for the assignement 
     * @type {number}
     * @memberof AssignmentCopyResponse
     */
    'maxPoints'?: number;
    /**
     * For worksheets, how grading will work for the assignment: - If set to `auto`, the grades will be automatically released when the student submits the submissions - If set to `manual`, the grades will only be set as `draftGrade` and will be released when the teacher returns the submissions 
     * @type {string}
     * @memberof AssignmentCopyResponse
     */
    'releaseGrades'?: AssignmentCopyResponseReleaseGradesEnum;
    /**
     * Mixing worksheets exercises for each student
     * @type {boolean}
     * @memberof AssignmentCopyResponse
     */
    'shuffleExercises'?: boolean;
    /**
     * The id of the associated toolset
     * @type {string}
     * @memberof AssignmentCopyResponse
     */
    'toolset'?: string;
    /**
     * The number of playback authorized on the scores of the assignment.
     * @type {number}
     * @memberof AssignmentCopyResponse
     */
    'nbPlaybackAuthorized'?: number;
    /**
     * If this assignment is stored as a resource in the Flat for Education Resource Library, the unique identifier of the resource.
     * @type {string}
     * @memberof AssignmentCopyResponse
     */
    'resource'?: string;
}

export const AssignmentCopyResponseReleaseGradesEnum = {
    Auto: 'auto',
    Manual: 'manual'
} as const;

export type AssignmentCopyResponseReleaseGradesEnum = typeof AssignmentCopyResponseReleaseGradesEnum[keyof typeof AssignmentCopyResponseReleaseGradesEnum];

/**
 * Capabilities the current user has on this assignment. Each capability corresponds to a fine-grained action that a user may take.
 * @export
 * @interface AssignmentCopyResponseCapabilities
 */
export interface AssignmentCopyResponseCapabilities {
    /**
     * Whether the current user can edit the assignment 
     * @type {boolean}
     * @memberof AssignmentCopyResponseCapabilities
     */
    'canEdit': boolean;
    /**
     * Whether this assignment can be published in a class 
     * @type {boolean}
     * @memberof AssignmentCopyResponseCapabilities
     */
    'canPublishInClass': boolean;
    /**
     * 
     * @type {AssignmentCopyResponseCapabilitiesCanPublishInClassError}
     * @memberof AssignmentCopyResponseCapabilities
     */
    'canPublishInClassError'?: AssignmentCopyResponseCapabilitiesCanPublishInClassError;
    /**
     * Whether the current user can archive the assignment 
     * @type {boolean}
     * @memberof AssignmentCopyResponseCapabilities
     */
    'canArchive': boolean;
    /**
     * Whether the current user can unarchive the assignment 
     * @type {boolean}
     * @memberof AssignmentCopyResponseCapabilities
     */
    'canUnarchive': boolean;
}
/**
 * If `canPublishInClass` and `canEdit` are false, the issue why this assignment cannot be published in a class 
 * @export
 * @interface AssignmentCopyResponseCapabilitiesCanPublishInClassError
 */
export interface AssignmentCopyResponseCapabilitiesCanPublishInClassError {
    /**
     * A corresponding code for this error
     * @type {string}
     * @memberof AssignmentCopyResponseCapabilitiesCanPublishInClassError
     */
    'code': string;
    /**
     * A printable and localized message for this error
     * @type {string}
     * @memberof AssignmentCopyResponseCapabilitiesCanPublishInClassError
     */
    'message': string;
}
/**
 * Assignment Submission
 * @export
 * @interface AssignmentSubmission
 */
export interface AssignmentSubmission {
    /**
     * Unique identifier of the submission
     * @type {string}
     * @memberof AssignmentSubmission
     */
    'id': string;
    /**
     * 
     * @type {AssignmentSubmissionState}
     * @memberof AssignmentSubmission
     */
    'state': AssignmentSubmissionState;
    /**
     * Unique identifier of the classroom where the assignment was posted 
     * @type {string}
     * @memberof AssignmentSubmission
     */
    'classroom': string;
    /**
     * Unique identifier of the assignment
     * @type {string}
     * @memberof AssignmentSubmission
     */
    'assignment': string;
    /**
     * The User identifier of the student who created the submission
     * @type {string}
     * @memberof AssignmentSubmission
     */
    'creator': string;
    /**
     * The date when the submission was created
     * @type {string}
     * @memberof AssignmentSubmission
     */
    'creationDate': string;
    /**
     * 
     * @type {Array<MediaAttachment>}
     * @memberof AssignmentSubmission
     */
    'attachments': Array<MediaAttachment>;
    /**
     * The date when the student submitted their work
     * @type {string}
     * @memberof AssignmentSubmission
     */
    'submissionDate'?: string;
    /**
     * The date when the teacher returned the work
     * @type {string}
     * @memberof AssignmentSubmission
     */
    'returnDate'?: string;
    /**
     * The User unique identifier of the teacher who returned the submission 
     * @type {string}
     * @memberof AssignmentSubmission
     */
    'returnCreator'?: string;
    /**
     * Optional grade. If unset, no grade was set.
     * @type {number}
     * @memberof AssignmentSubmission
     */
    'grade'?: number | null;
    /**
     * Optional grade. If unset, no grade was set. This value is only visible by the teacher, and we will be set to `grade` once the teacher returns the submission
     * @type {number}
     * @memberof AssignmentSubmission
     */
    'draftGrade'?: number | null;
    /**
     * Optional max points for the grade. If set, a corresponding `draftGrade` or `grade` will be set.
     * @type {number}
     * @memberof AssignmentSubmission
     */
    'maxPoints'?: number;
    /**
     * The ids of exercises when they need to be in a specific order
     * @type {Array<string>}
     * @memberof AssignmentSubmission
     */
    'exercisesIds'?: Array<string>;
    /**
     * 
     * @type {Array<AssignmentSubmissionPlaybackInner>}
     * @memberof AssignmentSubmission
     */
    'playback': Array<AssignmentSubmissionPlaybackInner>;
    /**
     * 
     * @type {AssignmentSubmissionComments}
     * @memberof AssignmentSubmission
     */
    'comments': AssignmentSubmissionComments;
    /**
     * 
     * @type {GoogleClassroomSubmission}
     * @memberof AssignmentSubmission
     */
    'googleClassroom'?: GoogleClassroomSubmission;
    /**
     * 
     * @type {MicrosoftGraphSubmission}
     * @memberof AssignmentSubmission
     */
    'microsoftGraph'?: MicrosoftGraphSubmission;
    /**
     * 
     * @type {AssignmentSubmissionLti}
     * @memberof AssignmentSubmission
     */
    'lti'?: AssignmentSubmissionLti;
}


/**
 * Feedback comment added to an assignment submission
 * @export
 * @interface AssignmentSubmissionComment
 */
export interface AssignmentSubmissionComment {
    /**
     * The comment unique identifier
     * @type {string}
     * @memberof AssignmentSubmissionComment
     */
    'id'?: string;
    /**
     * The author unique identifier
     * @type {string}
     * @memberof AssignmentSubmissionComment
     */
    'user'?: string;
    /**
     * The submission unique identifier
     * @type {string}
     * @memberof AssignmentSubmissionComment
     */
    'submission'?: string;
    /**
     * The date when the comment was posted
     * @type {string}
     * @memberof AssignmentSubmissionComment
     */
    'date'?: string;
    /**
     * The date of the last comment modification
     * @type {string}
     * @memberof AssignmentSubmissionComment
     */
    'modificationDate'?: string;
    /**
     * The comment text
     * @type {string}
     * @memberof AssignmentSubmissionComment
     */
    'comment'?: string;
    /**
     * True if the comment is unread by the current user
     * @type {boolean}
     * @memberof AssignmentSubmissionComment
     */
    'unread'?: boolean;
}
/**
 * Creation of a assignment submission comment
 * @export
 * @interface AssignmentSubmissionCommentCreation
 */
export interface AssignmentSubmissionCommentCreation {
    /**
     * The comment text
     * @type {string}
     * @memberof AssignmentSubmissionCommentCreation
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface AssignmentSubmissionComments
 */
export interface AssignmentSubmissionComments {
    /**
     * The total number of comments added to the submission
     * @type {number}
     * @memberof AssignmentSubmissionComments
     */
    'total'?: number;
    /**
     * The number of unread comments for the current user
     * @type {number}
     * @memberof AssignmentSubmissionComments
     */
    'unread'?: number;
}
/**
 * History item of the submission
 * @export
 * @interface AssignmentSubmissionHistory
 */
export interface AssignmentSubmissionHistory {
    /**
     * The date when the submission was changed
     * @type {string}
     * @memberof AssignmentSubmissionHistory
     */
    'date': string;
    /**
     * The classroom unique identifier where the submission was changed
     * @type {string}
     * @memberof AssignmentSubmissionHistory
     */
    'classroom'?: string;
    /**
     * The assignment unique identifier where the submission was changed
     * @type {string}
     * @memberof AssignmentSubmissionHistory
     */
    'assignment'?: string;
    /**
     * The submission unique identifier
     * @type {string}
     * @memberof AssignmentSubmissionHistory
     */
    'submission'?: string;
    /**
     * The user(s) unique identifier(s) who made the change
     * @type {Array<string>}
     * @memberof AssignmentSubmissionHistory
     */
    'users': Array<string>;
    /**
     * The source of the change if the change was made by a third-party software
     * @type {string}
     * @memberof AssignmentSubmissionHistory
     */
    'source'?: AssignmentSubmissionHistorySourceEnum;
    /**
     * 
     * @type {AssignmentSubmissionHistoryState}
     * @memberof AssignmentSubmissionHistory
     */
    'state'?: AssignmentSubmissionHistoryState;
    /**
     * The numerator of the grade at this time in the submission grade history
     * @type {number}
     * @memberof AssignmentSubmissionHistory
     */
    'draftGrade'?: number;
    /**
     * The numerator of the grade at this time in the submission grade history
     * @type {number}
     * @memberof AssignmentSubmissionHistory
     */
    'grade'?: number;
    /**
     * The denominator of the grade at this time in the submission grade history
     * @type {number}
     * @memberof AssignmentSubmissionHistory
     */
    'maxPoints'?: number;
    /**
     * The comment that is made to this submission
     * @type {string}
     * @memberof AssignmentSubmissionHistory
     */
    'comment'?: string;
    /**
     * The due date of this assignment
     * @type {string}
     * @memberof AssignmentSubmissionHistory
     */
    'dueDate'?: string;
    /**
     * 
     * @type {AssignmentSubmissionHistoryAttachment}
     * @memberof AssignmentSubmissionHistory
     */
    'attachment'?: AssignmentSubmissionHistoryAttachment;
}

export const AssignmentSubmissionHistorySourceEnum = {
    Lti: 'lti',
    GoogleClassroom: 'googleClassroom',
    MicrosoftGraph: 'microsoftGraph'
} as const;

export type AssignmentSubmissionHistorySourceEnum = typeof AssignmentSubmissionHistorySourceEnum[keyof typeof AssignmentSubmissionHistorySourceEnum];

/**
 * 
 * @export
 * @interface AssignmentSubmissionHistoryAttachment
 */
export interface AssignmentSubmissionHistoryAttachment {
    /**
     * The score identifier that changed
     * @type {string}
     * @memberof AssignmentSubmissionHistoryAttachment
     */
    'score'?: string;
    /**
     * The revision identifier that changed
     * @type {string}
     * @memberof AssignmentSubmissionHistoryAttachment
     */
    'revision'?: string;
    /**
     * The title of the score that changed
     * @type {string}
     * @memberof AssignmentSubmissionHistoryAttachment
     */
    'title'?: string;
}
/**
 * State of the submission history
 * @export
 * @enum {string}
 */

export const AssignmentSubmissionHistoryState = {
    Created: 'created',
    TurnedIn: 'turnedIn',
    Returned: 'returned',
    Graded: 'graded',
    Reset: 'reset'
} as const;

export type AssignmentSubmissionHistoryState = typeof AssignmentSubmissionHistoryState[keyof typeof AssignmentSubmissionHistoryState];


/**
 * 
 * @export
 * @interface AssignmentSubmissionLti
 */
export interface AssignmentSubmissionLti {
    /**
     * The sourcedid of the LTI submission when using LTI Outcomes
     * @type {string}
     * @memberof AssignmentSubmissionLti
     */
    'sourcedid': string;
}
/**
 * Playback used by student in this submission (used to limit the playback for the assignment)
 * @export
 * @interface AssignmentSubmissionPlaybackInner
 */
export interface AssignmentSubmissionPlaybackInner {
    /**
     * The score unique identifier
     * @type {string}
     * @memberof AssignmentSubmissionPlaybackInner
     */
    'score': string;
    /**
     * The number of playback used by the student
     * @type {number}
     * @memberof AssignmentSubmissionPlaybackInner
     */
    'nbPlayAttempt': number;
}
/**
 * State of the submission
 * @export
 * @enum {string}
 */

export const AssignmentSubmissionState = {
    Created: 'created',
    TurnedIn: 'turnedIn',
    Returned: 'returned',
    Graded: 'graded'
} as const;

export type AssignmentSubmissionState = typeof AssignmentSubmissionState[keyof typeof AssignmentSubmissionState];


/**
 * Assignment Submission creation
 * @export
 * @interface AssignmentSubmissionUpdate
 */
export interface AssignmentSubmissionUpdate {
    /**
     * 
     * @type {Array<ClassAttachmentCreation>}
     * @memberof AssignmentSubmissionUpdate
     */
    'attachments'?: Array<ClassAttachmentCreation>;
    /**
     * If `true`, the submission will be marked as done
     * @type {boolean}
     * @memberof AssignmentSubmissionUpdate
     */
    'submit'?: boolean;
    /**
     * Optional grade. If unset, no grade was set. This value is only visible by the teacher, and we will be set to `grade` once the teacher returns the submission
     * @type {number}
     * @memberof AssignmentSubmissionUpdate
     */
    'draftGrade'?: number | null;
    /**
     * Optional grade. If unset, no grade was set.
     * @type {number}
     * @memberof AssignmentSubmissionUpdate
     */
    'grade'?: number | null;
    /**
     * The ids of exercises when they need to be in a specific order
     * @type {Array<string>}
     * @memberof AssignmentSubmissionUpdate
     */
    'exercisesIds'?: Array<string> | null;
    /**
     * If `true`, the submission will be marked as done
     * @type {boolean}
     * @memberof AssignmentSubmissionUpdate
     */
    'return'?: boolean;
}
/**
 * Type of the assignment
 * @export
 * @enum {string}
 */

export const AssignmentType = {
    None: 'none',
    NewScore: 'newScore',
    ScoreTemplate: 'scoreTemplate',
    SharedWriting: 'sharedWriting',
    Worksheet: 'worksheet',
    Performance: 'performance'
} as const;

export type AssignmentType = typeof AssignmentType[keyof typeof AssignmentType];


/**
 * Assignment Resource Editing
 * @export
 * @interface AssignmentUpdate
 */
export interface AssignmentUpdate {
    /**
     * 
     * @type {AssignmentType}
     * @memberof AssignmentUpdate
     */
    'type'?: AssignmentType;
    /**
     * Title of the assignment
     * @type {string}
     * @memberof AssignmentUpdate
     */
    'title'?: string;
    /**
     * Description and content of the assignment
     * @type {string}
     * @memberof AssignmentUpdate
     */
    'description'?: string;
    /**
     * 
     * @type {Array<ClassAttachmentCreation>}
     * @memberof AssignmentUpdate
     */
    'attachments'?: Array<ClassAttachmentCreation>;
    /**
     * The number of playback authorized on the scores of the assignment.
     * @type {number}
     * @memberof AssignmentUpdate
     */
    'nbPlaybackAuthorized'?: number | null;
    /**
     * The id of the toolset to apply to this assignment. The toolset will be copied to the assignment as a dedicated object to prevent unexpected changes when making modifications to the template toolset. This property can be set to null to delete the linked toolset and switch back to all the tools available for this assignment. 
     * @type {string}
     * @memberof AssignmentUpdate
     */
    'toolset'?: string | null;
    /**
     * The id of the cover to display
     * @type {string}
     * @memberof AssignmentUpdate
     */
    'coverFile'?: string | null;
    /**
     * The URL of the cover to display
     * @type {string}
     * @memberof AssignmentUpdate
     */
    'cover'?: string | null;
    /**
     * If set, the grading will be enabled for the assignement with this value as the maximum of points 
     * @type {number}
     * @memberof AssignmentUpdate
     */
    'maxPoints'?: number | null;
    /**
     * For worksheets, how grading will work for the assignment: - If set to `auto`, the grades will be automatically released when the student submits the submissions - If set to `manual`, the grades will only be set as `draftGrade` and will be released when the teacher returns the submissions 
     * @type {string}
     * @memberof AssignmentUpdate
     */
    'releaseGrades'?: AssignmentUpdateReleaseGradesEnum;
    /**
     * Mixing worksheets exercises for each student
     * @type {boolean}
     * @memberof AssignmentUpdate
     */
    'shuffleExercises'?: boolean;
}

export const AssignmentUpdateReleaseGradesEnum = {
    Auto: 'auto',
    Manual: 'manual'
} as const;

export type AssignmentUpdateReleaseGradesEnum = typeof AssignmentUpdateReleaseGradesEnum[keyof typeof AssignmentUpdateReleaseGradesEnum];

/**
 * 
 * @export
 * @interface ClassAssignment
 */
export interface ClassAssignment {
    /**
     * Unique identifier of the assignment
     * @type {string}
     * @memberof ClassAssignment
     */
    'id': string;
    /**
     * 
     * @type {AssignmentType}
     * @memberof ClassAssignment
     */
    'type': AssignmentType;
    /**
     * 
     * @type {AssignmentCopyResponseCapabilities}
     * @memberof ClassAssignment
     */
    'capabilities': AssignmentCopyResponseCapabilities;
    /**
     * Title of the assignment
     * @type {string}
     * @memberof ClassAssignment
     */
    'title': string;
    /**
     * Description and content of the assignment
     * @type {string}
     * @memberof ClassAssignment
     */
    'description'?: string;
    /**
     * The URL of the cover to display
     * @type {string}
     * @memberof ClassAssignment
     */
    'cover'?: string;
    /**
     * The id of the cover to display
     * @type {string}
     * @memberof ClassAssignment
     */
    'coverFile'?: string;
    /**
     * 
     * @type {Array<MediaAttachment>}
     * @memberof ClassAssignment
     */
    'attachments': Array<MediaAttachment>;
    /**
     * For all assignments created after 02/2023, all the underlying resources must be dedicated and stored in the assignment. This boolean indicates that this assignment only supports dedicated attachments. 
     * @type {boolean}
     * @memberof ClassAssignment
     */
    'useDedicatedAttachments'?: boolean;
    /**
     * If set, the grading will be enabled for the assignement 
     * @type {number}
     * @memberof ClassAssignment
     */
    'maxPoints'?: number;
    /**
     * For worksheets, how grading will work for the assignment: - If set to `auto`, the grades will be automatically released when the student submits the submissions - If set to `manual`, the grades will only be set as `draftGrade` and will be released when the teacher returns the submissions 
     * @type {string}
     * @memberof ClassAssignment
     */
    'releaseGrades'?: ClassAssignmentReleaseGradesEnum;
    /**
     * Mixing worksheets exercises for each student
     * @type {boolean}
     * @memberof ClassAssignment
     */
    'shuffleExercises'?: boolean;
    /**
     * The id of the associated toolset
     * @type {string}
     * @memberof ClassAssignment
     */
    'toolset'?: string;
    /**
     * The number of playback authorized on the scores of the assignment.
     * @type {number}
     * @memberof ClassAssignment
     */
    'nbPlaybackAuthorized'?: number;
    /**
     * The User unique identifier of the creator of this assignment 
     * @type {string}
     * @memberof ClassAssignment
     */
    'creator'?: string;
    /**
     * State of the assignment
     * @type {string}
     * @memberof ClassAssignment
     */
    'state'?: ClassAssignmentStateEnum;
    /**
     * The unique identifier of the class where this assignment was posted
     * @type {string}
     * @memberof ClassAssignment
     */
    'classroom'?: string;
    /**
     * The creation date of this assignment
     * @type {string}
     * @memberof ClassAssignment
     */
    'creationDate'?: string;
    /**
     * The publication (scheduled) date of the assignment. If this one is specified, the assignment will only be listed to the teachers of the class. 
     * @type {string}
     * @memberof ClassAssignment
     */
    'scheduledDate'?: string;
    /**
     * The due date of this assignment, late submissions will be marked as paste due. 
     * @type {string}
     * @memberof ClassAssignment
     */
    'dueDate'?: string;
    /**
     * Possible modes of assigning assignments
     * @type {string}
     * @memberof ClassAssignment
     */
    'assigneeMode'?: ClassAssignmentAssigneeModeEnum;
    /**
     * Identifiers for the students that have access to the assignment
     * @type {Array<string>}
     * @memberof ClassAssignment
     */
    'assignedStudents'?: Array<string>;
    /**
     * 
     * @type {Array<AssignmentSubmission>}
     * @memberof ClassAssignment
     */
    'submissions'?: Array<AssignmentSubmission>;
    /**
     * 
     * @type {GoogleClassroomCoursework}
     * @memberof ClassAssignment
     */
    'googleClassroom'?: GoogleClassroomCoursework;
    /**
     * 
     * @type {MicrosoftGraphAssignment}
     * @memberof ClassAssignment
     */
    'microsoftGraph'?: MicrosoftGraphAssignment;
    /**
     * 
     * @type {ClassAssignmentMfc}
     * @memberof ClassAssignment
     */
    'mfc'?: ClassAssignmentMfc;
    /**
     * 
     * @type {ClassAssignmentCanvas}
     * @memberof ClassAssignment
     */
    'canvas'?: ClassAssignmentCanvas;
    /**
     * 
     * @type {ClassAssignmentLti}
     * @memberof ClassAssignment
     */
    'lti'?: ClassAssignmentLti;
    /**
     * Detected issue for this assignment
     * @type {string}
     * @memberof ClassAssignment
     */
    'issue'?: string;
}

export const ClassAssignmentReleaseGradesEnum = {
    Auto: 'auto',
    Manual: 'manual'
} as const;

export type ClassAssignmentReleaseGradesEnum = typeof ClassAssignmentReleaseGradesEnum[keyof typeof ClassAssignmentReleaseGradesEnum];
export const ClassAssignmentStateEnum = {
    Draft: 'draft',
    Active: 'active',
    Archived: 'archived'
} as const;

export type ClassAssignmentStateEnum = typeof ClassAssignmentStateEnum[keyof typeof ClassAssignmentStateEnum];
export const ClassAssignmentAssigneeModeEnum = {
    Everyone: 'everyone',
    Selected: 'selected'
} as const;

export type ClassAssignmentAssigneeModeEnum = typeof ClassAssignmentAssigneeModeEnum[keyof typeof ClassAssignmentAssigneeModeEnum];

/**
 * A Canvas LMS assignment
 * @export
 * @interface ClassAssignmentCanvas
 */
export interface ClassAssignmentCanvas {
    /**
     * Unique identifier of the course on Canvas assignment
     * @type {string}
     * @memberof ClassAssignmentCanvas
     */
    'id'?: string;
    /**
     * Link to Canvas assignment
     * @type {string}
     * @memberof ClassAssignmentCanvas
     */
    'alternateLink'?: string;
}
/**
 * An LTI assignment
 * @export
 * @interface ClassAssignmentLti
 */
export interface ClassAssignmentLti {
    /**
     * Resource ID in the LMS
     * @type {string}
     * @memberof ClassAssignmentLti
     */
    'id'?: string;
}
/**
 * A MusicFirst Classroom assignment
 * @export
 * @interface ClassAssignmentMfc
 */
export interface ClassAssignmentMfc {
    /**
     * Unique identifier of the course on MusicFirst Task
     * @type {string}
     * @memberof ClassAssignmentMfc
     */
    'id'?: string;
    /**
     * Link to MusicFirst Classroom task
     * @type {string}
     * @memberof ClassAssignmentMfc
     */
    'alternateLink'?: string;
}
/**
 * 
 * @export
 * @interface ClassAssignmentUpdate
 */
export interface ClassAssignmentUpdate {
    /**
     * 
     * @type {AssignmentType}
     * @memberof ClassAssignmentUpdate
     */
    'type'?: AssignmentType;
    /**
     * Title of the assignment
     * @type {string}
     * @memberof ClassAssignmentUpdate
     */
    'title'?: string;
    /**
     * Description and content of the assignment
     * @type {string}
     * @memberof ClassAssignmentUpdate
     */
    'description'?: string;
    /**
     * 
     * @type {Array<ClassAttachmentCreation>}
     * @memberof ClassAssignmentUpdate
     */
    'attachments'?: Array<ClassAttachmentCreation>;
    /**
     * The number of playback authorized on the scores of the assignment.
     * @type {number}
     * @memberof ClassAssignmentUpdate
     */
    'nbPlaybackAuthorized'?: number | null;
    /**
     * The id of the toolset to apply to this assignment. The toolset will be copied to the assignment as a dedicated object to prevent unexpected changes when making modifications to the template toolset. This property can be set to null to delete the linked toolset and switch back to all the tools available for this assignment. 
     * @type {string}
     * @memberof ClassAssignmentUpdate
     */
    'toolset'?: string | null;
    /**
     * The id of the cover to display
     * @type {string}
     * @memberof ClassAssignmentUpdate
     */
    'coverFile'?: string | null;
    /**
     * The URL of the cover to display
     * @type {string}
     * @memberof ClassAssignmentUpdate
     */
    'cover'?: string | null;
    /**
     * If set, the grading will be enabled for the assignement with this value as the maximum of points 
     * @type {number}
     * @memberof ClassAssignmentUpdate
     */
    'maxPoints'?: number | null;
    /**
     * For worksheets, how grading will work for the assignment: - If set to `auto`, the grades will be automatically released when the student submits the submissions - If set to `manual`, the grades will only be set as `draftGrade` and will be released when the teacher returns the submissions 
     * @type {string}
     * @memberof ClassAssignmentUpdate
     */
    'releaseGrades'?: ClassAssignmentUpdateReleaseGradesEnum;
    /**
     * Mixing worksheets exercises for each student
     * @type {boolean}
     * @memberof ClassAssignmentUpdate
     */
    'shuffleExercises'?: boolean;
    /**
     * State of the assignment
     * @type {string}
     * @memberof ClassAssignmentUpdate
     */
    'state'?: ClassAssignmentUpdateStateEnum;
    /**
     * The due date of this assignment, late submissions will be marked as paste due. If not set, the assignment won\'t have a due date. 
     * @type {string}
     * @memberof ClassAssignmentUpdate
     */
    'dueDate'?: string | null;
    /**
     * The publication (scheduled) date of the assignment. If this one is specified, the assignment will only be listed to the teachers of the class. 
     * @type {string}
     * @memberof ClassAssignmentUpdate
     */
    'scheduledDate'?: string | null;
    /**
     * 
     * @type {ClassAssignmentUpdateGoogleClassroom}
     * @memberof ClassAssignmentUpdate
     */
    'googleClassroom'?: ClassAssignmentUpdateGoogleClassroom;
    /**
     * 
     * @type {ClassAssignmentUpdateMicrosoftGraph}
     * @memberof ClassAssignmentUpdate
     */
    'microsoftGraph'?: ClassAssignmentUpdateMicrosoftGraph;
    /**
     * Possible modes of assigning assignments
     * @type {string}
     * @memberof ClassAssignmentUpdate
     */
    'assigneeMode'?: ClassAssignmentUpdateAssigneeModeEnum;
    /**
     * Identifiers for the students that have access to the assignment
     * @type {Array<string>}
     * @memberof ClassAssignmentUpdate
     */
    'assignedStudents'?: Array<string>;
}

export const ClassAssignmentUpdateReleaseGradesEnum = {
    Auto: 'auto',
    Manual: 'manual'
} as const;

export type ClassAssignmentUpdateReleaseGradesEnum = typeof ClassAssignmentUpdateReleaseGradesEnum[keyof typeof ClassAssignmentUpdateReleaseGradesEnum];
export const ClassAssignmentUpdateStateEnum = {
    Draft: 'draft',
    Active: 'active'
} as const;

export type ClassAssignmentUpdateStateEnum = typeof ClassAssignmentUpdateStateEnum[keyof typeof ClassAssignmentUpdateStateEnum];
export const ClassAssignmentUpdateAssigneeModeEnum = {
    Everyone: 'everyone',
    Selected: 'selected'
} as const;

export type ClassAssignmentUpdateAssigneeModeEnum = typeof ClassAssignmentUpdateAssigneeModeEnum[keyof typeof ClassAssignmentUpdateAssigneeModeEnum];

/**
 * Google Classroom options for this assignment
 * @export
 * @interface ClassAssignmentUpdateGoogleClassroom
 */
export interface ClassAssignmentUpdateGoogleClassroom {
    /**
     * Identifier of the topic where the assignment is created
     * @type {string}
     * @memberof ClassAssignmentUpdateGoogleClassroom
     */
    'topicId'?: string | null;
}
/**
 * Microsoft Graph options for this assignment
 * @export
 * @interface ClassAssignmentUpdateMicrosoftGraph
 */
export interface ClassAssignmentUpdateMicrosoftGraph {
    /**
     * List of categories this assignment belongs to
     * @type {Array<string>}
     * @memberof ClassAssignmentUpdateMicrosoftGraph
     */
    'categories'?: Array<string> | null;
}
/**
 * Attachment creation for an assignment or stream post. This attachment must contain a `score` or an `url`, all the details of this one will be resolved and returned as `ClassAttachment` once the assignment or stream post is created. 
 * @export
 * @interface ClassAttachmentCreation
 */
export interface ClassAttachmentCreation {
    /**
     * The type of the attachment posted: * `rich`, `photo`, `video` are attachment types that are automatically resolved from a `link` attachment. * A `flat` attachment is a score document where the unique identifier will be specified in the `score` property. Its sharing mode will be provided in the `sharingMode` property. 
     * @type {string}
     * @memberof ClassAttachmentCreation
     */
    'type'?: ClassAttachmentCreationTypeEnum;
    /**
     * A unique Flat score identifier. The user creating the assignment must at least have read access to the document. If the user has admin rights, new group permissions will be automatically added for the teachers and students of the class. 
     * @type {string}
     * @memberof ClassAttachmentCreation
     */
    'score'?: string;
    /**
     * An unique worksheet identifier
     * @type {string}
     * @memberof ClassAttachmentCreation
     */
    'worksheet'?: string;
    /**
     * 
     * @type {MediaScoreSharingMode}
     * @memberof ClassAttachmentCreation
     */
    'sharingMode'?: MediaScoreSharingMode;
    /**
     * To be used with a score attached in `sharingMode` `copy` (score used as template). If true, students won\'t be able to change the original notes of the template.
     * @type {boolean}
     * @memberof ClassAttachmentCreation
     */
    'lockScoreTemplate'?: boolean;
    /**
     * The URL of the attachment.
     * @type {string}
     * @memberof ClassAttachmentCreation
     */
    'url'?: string;
    /**
     * The ID of the Google Drive File
     * @type {string}
     * @memberof ClassAttachmentCreation
     */
    'googleDriveFileId'?: string;
}

export const ClassAttachmentCreationTypeEnum = {
    Rich: 'rich',
    Photo: 'photo',
    Video: 'video',
    Link: 'link',
    Flat: 'flat',
    GoogleDrive: 'googleDrive',
    Worksheet: 'worksheet',
    Performance: 'performance'
} as const;

export type ClassAttachmentCreationTypeEnum = typeof ClassAttachmentCreationTypeEnum[keyof typeof ClassAttachmentCreationTypeEnum];

/**
 * Creation of a classroom
 * @export
 * @interface ClassCreation
 */
export interface ClassCreation {
    /**
     * The name of the new class
     * @type {string}
     * @memberof ClassCreation
     */
    'name': string;
    /**
     * The section of the new class
     * @type {string}
     * @memberof ClassCreation
     */
    'section'?: string;
    /**
     * 
     * @type {ClassGradeLevel}
     * @memberof ClassCreation
     */
    'level'?: ClassGradeLevel;
    /**
     * Specific skills that will be focused in classroom
     * @type {Array<string>}
     * @memberof ClassCreation
     */
    'skillsFocused'?: Array<ClassCreationSkillsFocusedEnum>;
    /**
     * Number of students in the classroom
     * @type {number}
     * @memberof ClassCreation
     */
    'size'?: number | null;
}

export const ClassCreationSkillsFocusedEnum = {
    Notation: 'notation',
    SightReading: 'sight-reading',
    PerformanceInstrumental: 'performance-instrumental',
    EarTraining: 'ear-training',
    MusicTheory: 'music-theory',
    Composition: 'composition',
    JazzEnsemble: 'jazz-ensemble',
    MusicTechnology: 'music-technology',
    Other: 'other'
} as const;

export type ClassCreationSkillsFocusedEnum = typeof ClassCreationSkillsFocusedEnum[keyof typeof ClassCreationSkillsFocusedEnum];

/**
 * A classroom
 * @export
 * @interface ClassDetails
 */
export interface ClassDetails {
    /**
     * The unique identifier of the class
     * @type {string}
     * @memberof ClassDetails
     */
    'id': string;
    /**
     * 
     * @type {ClassState}
     * @memberof ClassDetails
     */
    'state'?: ClassState;
    /**
     * The name of the class
     * @type {string}
     * @memberof ClassDetails
     */
    'name'?: string;
    /**
     * The section of the class
     * @type {string}
     * @memberof ClassDetails
     */
    'section'?: string;
    /**
     * An optionnal description for this class
     * @type {string}
     * @memberof ClassDetails
     */
    'description'?: string;
    /**
     * The unique identifier of the Organization owning this class
     * @type {string}
     * @memberof ClassDetails
     */
    'organization'?: string;
    /**
     * The unique identifier of the User owning this class
     * @type {string}
     * @memberof ClassDetails
     */
    'owner'?: string;
    /**
     * The date when the class was create
     * @type {string}
     * @memberof ClassDetails
     */
    'creationDate'?: string;
    /**
     * [Teachers only] The enrollment code that can be used by the students to join the class 
     * @type {string}
     * @memberof ClassDetails
     */
    'enrollmentCode'?: string;
    /**
     * The theme identifier using in Flat User Interface
     * @type {string}
     * @memberof ClassDetails
     */
    'theme'?: string;
    /**
     * The number of assignments created in the class
     * @type {number}
     * @memberof ClassDetails
     */
    'assignmentsCount'?: number;
    /**
     * 
     * @type {GroupDetails}
     * @memberof ClassDetails
     */
    'studentsGroup'?: GroupDetails;
    /**
     * 
     * @type {GroupDetails}
     * @memberof ClassDetails
     */
    'teachersGroup'?: GroupDetails;
    /**
     * 
     * @type {ClassDetailsIssues}
     * @memberof ClassDetails
     */
    'issues'?: ClassDetailsIssues;
    /**
     * 
     * @type {ClassDetailsGoogleClassroom}
     * @memberof ClassDetails
     */
    'googleClassroom'?: ClassDetailsGoogleClassroom;
    /**
     * 
     * @type {ClassDetailsGoogleDrive}
     * @memberof ClassDetails
     */
    'googleDrive'?: ClassDetailsGoogleDrive;
    /**
     * 
     * @type {ClassDetailsMicrosoftGraph}
     * @memberof ClassDetails
     */
    'microsoftGraph'?: ClassDetailsMicrosoftGraph;
    /**
     * 
     * @type {ClassDetailsLti}
     * @memberof ClassDetails
     */
    'lti'?: ClassDetailsLti;
    /**
     * 
     * @type {ClassDetailsCanvas}
     * @memberof ClassDetails
     */
    'canvas'?: ClassDetailsCanvas;
    /**
     * 
     * @type {ClassDetailsMfc}
     * @memberof ClassDetails
     */
    'mfc'?: ClassDetailsMfc;
    /**
     * 
     * @type {ClassDetailsClever}
     * @memberof ClassDetails
     */
    'clever'?: ClassDetailsClever;
    /**
     * 
     * @type {ClassGradeLevel}
     * @memberof ClassDetails
     */
    'level'?: ClassGradeLevel;
    /**
     * Specific skills that will be focused in classroom
     * @type {Array<string>}
     * @memberof ClassDetails
     */
    'skillsFocused'?: Array<ClassDetailsSkillsFocusedEnum>;
    /**
     * Number of students in the classroom
     * @type {number}
     * @memberof ClassDetails
     */
    'size'?: number | null;
}

export const ClassDetailsSkillsFocusedEnum = {
    Notation: 'notation',
    SightReading: 'sight-reading',
    PerformanceInstrumental: 'performance-instrumental',
    EarTraining: 'ear-training',
    MusicTheory: 'music-theory',
    Composition: 'composition',
    JazzEnsemble: 'jazz-ensemble',
    MusicTechnology: 'music-technology',
    Other: 'other'
} as const;

export type ClassDetailsSkillsFocusedEnum = typeof ClassDetailsSkillsFocusedEnum[keyof typeof ClassDetailsSkillsFocusedEnum];

/**
 * Meta information provided by Canvs LMS
 * @export
 * @interface ClassDetailsCanvas
 */
export interface ClassDetailsCanvas {
    /**
     * Unique identifier of the course on Canvas
     * @type {string}
     * @memberof ClassDetailsCanvas
     */
    'id'?: string;
    /**
     * Canvas instance domain (e.g. \"canvas.instructure.com\")
     * @type {string}
     * @memberof ClassDetailsCanvas
     */
    'domain'?: string;
}
/**
 * Clever.com section-related information
 * @export
 * @interface ClassDetailsClever
 */
export interface ClassDetailsClever {
    /**
     * Clever section unique identifier
     * @type {string}
     * @memberof ClassDetailsClever
     */
    'id'?: string;
    /**
     * The creation date of the section on clever
     * @type {string}
     * @memberof ClassDetailsClever
     */
    'creationDate'?: string;
    /**
     * The last modification date of the section on clever
     * @type {string}
     * @memberof ClassDetailsClever
     */
    'modificationDate'?: string;
    /**
     * Normalized subject of the course
     * @type {string}
     * @memberof ClassDetailsClever
     */
    'subject'?: ClassDetailsCleverSubjectEnum;
    /**
     * Name of the term when this course happens
     * @type {string}
     * @memberof ClassDetailsClever
     */
    'termName'?: string;
    /**
     * Beginning date of the term
     * @type {string}
     * @memberof ClassDetailsClever
     */
    'termStartDate'?: string;
    /**
     * End date of the term
     * @type {string}
     * @memberof ClassDetailsClever
     */
    'termEndDate'?: string;
}

export const ClassDetailsCleverSubjectEnum = {
    EnglishLanguageArts: 'english/language arts',
    Math: 'math',
    Science: 'science',
    SocialStudies: 'social studies',
    Language: 'language',
    HomeroomAdvisory: 'homeroom/advisory',
    InterventionsOnlineLearning: 'interventions/online learning',
    TechnologyAndEngineering: 'technology and engineering',
    PeAndHealth: 'PE and health',
    ArtsAndMusic: 'arts and music',
    Other: 'other'
} as const;

export type ClassDetailsCleverSubjectEnum = typeof ClassDetailsCleverSubjectEnum[keyof typeof ClassDetailsCleverSubjectEnum];

/**
 * Google Classroom course-related information
 * @export
 * @interface ClassDetailsGoogleClassroom
 */
export interface ClassDetailsGoogleClassroom {
    /**
     * The course identifier on Google Classroom
     * @type {string}
     * @memberof ClassDetailsGoogleClassroom
     */
    'id'?: string;
    /**
     * Absolute link to this course in the Classroom web UI
     * @type {string}
     * @memberof ClassDetailsGoogleClassroom
     */
    'alternateLink'?: string;
}
/**
 * Google Drive course-related information provided by Google Classroom
 * @export
 * @interface ClassDetailsGoogleDrive
 */
export interface ClassDetailsGoogleDrive {
    /**
     * [Teachers only] The Drive directory identifier of the teachers\' folder 
     * @type {string}
     * @memberof ClassDetailsGoogleDrive
     */
    'teacherFolderId'?: string;
    /**
     * [Teachers only] The Drive URL of the teachers\' folder 
     * @type {string}
     * @memberof ClassDetailsGoogleDrive
     */
    'teacherFolderAlternateLink'?: string;
}
/**
 * Detected issues for this class
 * @export
 * @interface ClassDetailsIssues
 */
export interface ClassDetailsIssues {
    /**
     * Synchronization issues for the class
     * @type {Array<ClassDetailsIssuesSyncInner>}
     * @memberof ClassDetailsIssues
     */
    'sync'?: Array<ClassDetailsIssuesSyncInner>;
}
/**
 * A sync issue
 * @export
 * @interface ClassDetailsIssuesSyncInner
 */
export interface ClassDetailsIssuesSyncInner {
    /**
     * The account user identifier
     * @type {string}
     * @memberof ClassDetailsIssuesSyncInner
     */
    'id'?: string;
    /**
     * The email address of the user concerned by this sync issue
     * @type {string}
     * @memberof ClassDetailsIssuesSyncInner
     */
    'email'?: string;
    /**
     * The reason why the account cannot be synced
     * @type {string}
     * @memberof ClassDetailsIssuesSyncInner
     */
    'reason'?: ClassDetailsIssuesSyncInnerReasonEnum;
}

export const ClassDetailsIssuesSyncInnerReasonEnum = {
    OtherOrgnanization: 'otherOrgnanization',
    PersonalSubscription: 'personalSubscription'
} as const;

export type ClassDetailsIssuesSyncInnerReasonEnum = typeof ClassDetailsIssuesSyncInnerReasonEnum[keyof typeof ClassDetailsIssuesSyncInnerReasonEnum];

/**
 * Meta information provided by the LTI consumer
 * @export
 * @interface ClassDetailsLti
 */
export interface ClassDetailsLti {
    /**
     * Unique context identifier provided
     * @type {string}
     * @memberof ClassDetailsLti
     */
    'contextId'?: string;
    /**
     * Context title
     * @type {string}
     * @memberof ClassDetailsLti
     */
    'contextTitle'?: string;
    /**
     * Context label
     * @type {string}
     * @memberof ClassDetailsLti
     */
    'contextLabel'?: string;
}
/**
 * Meta information provided by Canvs LMS
 * @export
 * @interface ClassDetailsMfc
 */
export interface ClassDetailsMfc {
    /**
     * Unique identifier of the course on MusicFirst Classroom
     * @type {string}
     * @memberof ClassDetailsMfc
     */
    'id'?: string;
    /**
     * Link to MusicFirst Classroom class
     * @type {string}
     * @memberof ClassDetailsMfc
     */
    'alternateLink'?: string;
}
/**
 * 
 * @export
 * @interface ClassDetailsMicrosoftGraph
 */
export interface ClassDetailsMicrosoftGraph {
    /**
     * The course identifier on Microsoft Graph
     * @type {string}
     * @memberof ClassDetailsMicrosoftGraph
     */
    'id'?: string;
}
/**
 * Class grade level
 * @export
 * @enum {string}
 */

export const ClassGradeLevel = {
    Elementary: 'elementary',
    Middle: 'middle',
    High: 'high',
    University: 'university',
    Other: 'other'
} as const;

export type ClassGradeLevel = typeof ClassGradeLevel[keyof typeof ClassGradeLevel];


/**
 * User\'s Class Role (for Edu users only)
 * @export
 * @enum {string}
 */

export const ClassRoles = {
    Teacher: 'teacher',
    Student: 'student'
} as const;

export type ClassRoles = typeof ClassRoles[keyof typeof ClassRoles];


/**
 * The state of a classroom
 * @export
 * @enum {string}
 */

export const ClassState = {
    Active: 'active',
    Inactive: 'inactive',
    Archived: 'archived'
} as const;

export type ClassState = typeof ClassState[keyof typeof ClassState];


/**
 * Update of a classroom
 * @export
 * @interface ClassUpdate
 */
export interface ClassUpdate {
    /**
     * The name of the class
     * @type {string}
     * @memberof ClassUpdate
     */
    'name'?: string;
    /**
     * The section of the class
     * @type {string}
     * @memberof ClassUpdate
     */
    'section'?: string;
    /**
     * 
     * @type {ClassGradeLevel}
     * @memberof ClassUpdate
     */
    'level'?: ClassGradeLevel;
    /**
     * Specific skills that will be focused in classroom
     * @type {Array<string>}
     * @memberof ClassUpdate
     */
    'skillsFocused'?: Array<ClassUpdateSkillsFocusedEnum>;
    /**
     * Number of students in the classroom
     * @type {number}
     * @memberof ClassUpdate
     */
    'size'?: number | null;
}

export const ClassUpdateSkillsFocusedEnum = {
    Notation: 'notation',
    SightReading: 'sight-reading',
    PerformanceInstrumental: 'performance-instrumental',
    EarTraining: 'ear-training',
    MusicTheory: 'music-theory',
    Composition: 'composition',
    JazzEnsemble: 'jazz-ensemble',
    MusicTechnology: 'music-technology',
    Other: 'other'
} as const;

export type ClassUpdateSkillsFocusedEnum = typeof ClassUpdateSkillsFocusedEnum[keyof typeof ClassUpdateSkillsFocusedEnum];

/**
 * Collection of scores
 * @export
 * @interface Collection
 */
export interface Collection {
    /**
     * Unique identifier of the collection
     * @type {string}
     * @memberof Collection
     */
    'id'?: string;
    /**
     * The title of the collection
     * @type {string}
     * @memberof Collection
     */
    'title'?: string;
    /**
     * The url where the collection can be viewed in a web browser
     * @type {string}
     * @memberof Collection
     */
    'htmlUrl'?: string;
    /**
     * 
     * @type {CollectionType}
     * @memberof Collection
     */
    'type'?: CollectionType;
    /**
     * 
     * @type {CollectionPrivacy}
     * @memberof Collection
     */
    'privacy'?: CollectionPrivacy;
    /**
     * The private sharing key of the collection (available when the `privacy` mode is set to `privateLink`)
     * @type {string}
     * @memberof Collection
     */
    'sharingKey'?: string;
    /**
     * 
     * @type {CollectionApp}
     * @memberof Collection
     */
    'app'?: CollectionApp;
    /**
     * The date when the collection was created
     * @type {string}
     * @memberof Collection
     */
    'creationDate'?: string;
    /**
     * 
     * @type {UserPublicSummary}
     * @memberof Collection
     */
    'user'?: UserPublicSummary;
    /**
     * If the score has been created in an organization, the identifier of this organization.  
     * @type {string}
     * @memberof Collection
     */
    'organization'?: string;
    /**
     * 
     * @type {ResourceRights}
     * @memberof Collection
     */
    'rights'?: ResourceRights;
    /**
     * The list of the collaborators of the collection
     * @type {Array<ResourceCollaborator>}
     * @memberof Collection
     */
    'collaborators'?: Array<ResourceCollaborator>;
    /**
     * 
     * @type {CollectionCapabilities}
     * @memberof Collection
     */
    'capabilities': CollectionCapabilities;
    /**
     * The List of parent collections, which includes all the collections this score is included. Please note that you might not have access to all of them.
     * @type {Array<string>}
     * @memberof Collection
     */
    'collections'?: Array<string>;
}


/**
 * For App collections, the details of the app that created the collection
 * @export
 * @interface CollectionApp
 */
export interface CollectionApp {
    /**
     * The app unique identifier
     * @type {string}
     * @memberof CollectionApp
     */
    'id'?: string;
    /**
     * The name of the app
     * @type {string}
     * @memberof CollectionApp
     */
    'name'?: string;
    /**
     * The app logo url
     * @type {string}
     * @memberof CollectionApp
     */
    'logo'?: string;
}
/**
 * Capabilities the current user has on this collection. Each capability corresponds to a fine-grained action that a user may take.
 * @export
 * @interface CollectionCapabilities
 */
export interface CollectionCapabilities {
    /**
     * Whether the current user can modify the metadata for the collection 
     * @type {boolean}
     * @memberof CollectionCapabilities
     */
    'canEdit': boolean;
    /**
     * Whether the current user can modify the sharing settings for the collection 
     * @type {boolean}
     * @memberof CollectionCapabilities
     */
    'canShare': boolean;
    /**
     * Whether the current user can delete the collection 
     * @type {boolean}
     * @memberof CollectionCapabilities
     */
    'canDelete': boolean;
    /**
     * Whether the current user can add scores to the collection  If this collection has the `type` `trash`, this property will be set to `false`. Use `DELETE /v2/scores/{score}` to trash a score. 
     * @type {boolean}
     * @memberof CollectionCapabilities
     */
    'canAddScores': boolean;
    /**
     * Whether the current user can delete scores from the collection  If this collection has the `type` `trash`, this property will be set to `false`. Use `POST /v2/scores/{score}/untrash` to restore a score. 
     * @type {boolean}
     * @memberof CollectionCapabilities
     */
    'canDeleteScores': boolean;
}
/**
 * 
 * @export
 * @interface CollectionCreation
 */
export interface CollectionCreation {
    /**
     * The title of the collection
     * @type {string}
     * @memberof CollectionCreation
     */
    'title': string;
    /**
     * 
     * @type {CollectionPrivacy}
     * @memberof CollectionCreation
     */
    'privacy': CollectionPrivacy;
}


/**
 * Edit the collection metadata
 * @export
 * @interface CollectionModification
 */
export interface CollectionModification {
    /**
     * The title of the collection
     * @type {string}
     * @memberof CollectionModification
     */
    'title'?: string;
    /**
     * 
     * @type {CollectionPrivacy}
     * @memberof CollectionModification
     */
    'privacy'?: CollectionPrivacy;
}


/**
 * The collection main privacy mode. - `private`: The collection is private and can be only accessed, modified and administred by specified collaborators users. 
 * @export
 * @enum {string}
 */

export const CollectionPrivacy = {
    Private: 'private'
} as const;

export type CollectionPrivacy = typeof CollectionPrivacy[keyof typeof CollectionPrivacy];


/**
 * Type of the collection. The type will influence the capabilitied available on the collections and how this collection is/can be populated. 
 * @export
 * @enum {string}
 */

export const CollectionType = {
    Root: 'root',
    Regular: 'regular',
    SharedWithMe: 'sharedWithMe',
    SharedWithGroup: 'sharedWithGroup',
    App: 'app',
    Trash: 'trash'
} as const;

export type CollectionType = typeof CollectionType[keyof typeof CollectionType];


/**
 * A Flat for Education Library
 * @export
 * @interface EduLibrary
 */
export interface EduLibrary {
    /**
     * Unique identifier of the library.  This one can be used to list the underlying resources using `GET /v2/eduResources?parent={library-id}` 
     * @type {string}
     * @memberof EduLibrary
     */
    'id'?: string;
    /**
     * Name of the lirbary
     * @type {string}
     * @memberof EduLibrary
     */
    'name'?: string;
    /**
     * Type of the library
     * @type {string}
     * @memberof EduLibrary
     */
    'type'?: EduLibraryTypeEnum;
    /**
     * Visibility of the library
     * @type {string}
     * @memberof EduLibrary
     */
    'visibility'?: EduLibraryVisibilityEnum;
}

export const EduLibraryTypeEnum = {
    MyResources: 'myResources',
    OrganizationResources: 'organizationResources',
    FlatEduSamples: 'flatEduSamples'
} as const;

export type EduLibraryTypeEnum = typeof EduLibraryTypeEnum[keyof typeof EduLibraryTypeEnum];
export const EduLibraryVisibilityEnum = {
    Private: 'private',
    Organization: 'organization',
    Public: 'public'
} as const;

export type EduLibraryVisibilityEnum = typeof EduLibraryVisibilityEnum[keyof typeof EduLibraryVisibilityEnum];

/**
 * A Flat for Education resource contained in a resources library
 * @export
 * @interface EduResource
 */
export interface EduResource {
    /**
     * Resource unique identifier
     * @type {string}
     * @memberof EduResource
     */
    'id': string;
    /**
     * The User identifier of the resource creator
     * @type {string}
     * @memberof EduResource
     */
    'creator'?: string;
    /**
     * 
     * @type {EduResourceType}
     * @memberof EduResource
     */
    'type': EduResourceType;
    /**
     * 
     * @type {EduResourcePrivacy}
     * @memberof EduResource
     */
    'privacy'?: EduResourcePrivacy;
    /**
     * Specific attributes for the resource (e.g. sample resources with custom design)
     * @type {Array<string>}
     * @memberof EduResource
     */
    'tags'?: Array<string>;
    /**
     * Identifier of the parent resource, e.g. a folder or root
     * @type {string}
     * @memberof EduResource
     */
    'parent'?: string;
    /**
     * Title of the resource
     * @type {string}
     * @memberof EduResource
     */
    'title': string;
    /**
     * The date when the resource was created
     * @type {string}
     * @memberof EduResource
     */
    'creationDate'?: string;
    /**
     * The date when the resource was updated
     * @type {string}
     * @memberof EduResource
     */
    'updateDate'?: string;
    /**
     * 
     * @type {EduResourceResource}
     * @memberof EduResource
     */
    'resource'?: EduResourceResource;
    /**
     * 
     * @type {EduResourceCapabilities}
     * @memberof EduResource
     */
    'capabilities': EduResourceCapabilities;
}


/**
 * Capabilities available for this resource
 * @export
 * @interface EduResourceCapabilities
 */
export interface EduResourceCapabilities {
    /**
     * Whether the current user can modify this resource 
     * @type {boolean}
     * @memberof EduResourceCapabilities
     */
    'canEdit'?: boolean;
    /**
     * Whether the current user can add resources within this resource (e.g. `assignment` inside a `folder`) 
     * @type {boolean}
     * @memberof EduResourceCapabilities
     */
    'canAddResources'?: boolean;
    /**
     * Whether the current user can add folders within this resource (e.g. `folder` inside `root`) 
     * @type {boolean}
     * @memberof EduResourceCapabilities
     */
    'canAddFolders'?: boolean;
}
/**
 * Copy an education resource
 * @export
 * @interface EduResourceCopy
 */
export interface EduResourceCopy {
    /**
     * Unique identifier of the destination of the folder where to copy this resource. This can also be `root` to copy the resource at the root of the user resource library. 
     * @type {string}
     * @memberof EduResourceCopy
     */
    'destination': string;
}
/**
 * Creation of an education resource
 * @export
 * @interface EduResourceCreation
 */
export interface EduResourceCreation {
    /**
     * 
     * @type {EduResourceType}
     * @memberof EduResourceCreation
     */
    'type': EduResourceType;
    /**
     * Title of the resource
     * @type {string}
     * @memberof EduResourceCreation
     */
    'title': string;
    /**
     * Identifier of the parent resource where the new one will created, e.g. a folder id or `root`
     * @type {string}
     * @memberof EduResourceCreation
     */
    'parent'?: string;
}


/**
 * LTI Link details for the class
 * @export
 * @interface EduResourceLtiLink
 */
export interface EduResourceLtiLink {
    /**
     * An URL that can be used to launch LTI with this resource in a classroom.
     * @type {string}
     * @memberof EduResourceLtiLink
     */
    'ltiUrl': string;
}
/**
 * Move an education resource
 * @export
 * @interface EduResourceMove
 */
export interface EduResourceMove {
    /**
     * Unique identifier of the destination of the folder where to move this resource. This can also be `root` to move the resource at the root of the user resource library. 
     * @type {string}
     * @memberof EduResourceMove
     */
    'destination': string;
}
/**
 * The Education resource privacy mode. 
 * @export
 * @enum {string}
 */

export const EduResourcePrivacy = {
    Private: 'private',
    OrganizationPublic: 'organizationPublic',
    Public: 'public'
} as const;

export type EduResourcePrivacy = typeof EduResourcePrivacy[keyof typeof EduResourcePrivacy];


/**
 * 
 * @export
 * @interface EduResourceResource
 */
export interface EduResourceResource {
    /**
     * Unique identifier of the assignment
     * @type {string}
     * @memberof EduResourceResource
     */
    'id': string;
    /**
     * 
     * @type {AssignmentType}
     * @memberof EduResourceResource
     */
    'type': AssignmentType;
    /**
     * 
     * @type {AssignmentCopyResponseCapabilities}
     * @memberof EduResourceResource
     */
    'capabilities': AssignmentCopyResponseCapabilities;
    /**
     * Title of the folder
     * @type {string}
     * @memberof EduResourceResource
     */
    'title': string;
    /**
     * Description and content of the assignment
     * @type {string}
     * @memberof EduResourceResource
     */
    'description'?: string;
    /**
     * The URL of the cover to display
     * @type {string}
     * @memberof EduResourceResource
     */
    'cover'?: string;
    /**
     * The id of the cover to display
     * @type {string}
     * @memberof EduResourceResource
     */
    'coverFile'?: string;
    /**
     * 
     * @type {Array<MediaAttachment>}
     * @memberof EduResourceResource
     */
    'attachments': Array<MediaAttachment>;
    /**
     * For all assignments created after 02/2023, all the underlying resources must be dedicated and stored in the assignment. This boolean indicates that this assignment only supports dedicated attachments. 
     * @type {boolean}
     * @memberof EduResourceResource
     */
    'useDedicatedAttachments'?: boolean;
    /**
     * If set, the grading will be enabled for the assignement 
     * @type {number}
     * @memberof EduResourceResource
     */
    'maxPoints'?: number;
    /**
     * For worksheets, how grading will work for the assignment: - If set to `auto`, the grades will be automatically released when the student submits the submissions - If set to `manual`, the grades will only be set as `draftGrade` and will be released when the teacher returns the submissions 
     * @type {string}
     * @memberof EduResourceResource
     */
    'releaseGrades'?: EduResourceResourceReleaseGradesEnum;
    /**
     * Mixing worksheets exercises for each student
     * @type {boolean}
     * @memberof EduResourceResource
     */
    'shuffleExercises'?: boolean;
    /**
     * The id of the associated toolset
     * @type {string}
     * @memberof EduResourceResource
     */
    'toolset'?: string;
    /**
     * The number of playback authorized on the scores of the assignment.
     * @type {number}
     * @memberof EduResourceResource
     */
    'nbPlaybackAuthorized'?: number;
}

export const EduResourceResourceReleaseGradesEnum = {
    Auto: 'auto',
    Manual: 'manual'
} as const;

export type EduResourceResourceReleaseGradesEnum = typeof EduResourceResourceReleaseGradesEnum[keyof typeof EduResourceResourceReleaseGradesEnum];

/**
 * Type of an education resource
 * @export
 * @enum {string}
 */

export const EduResourceType = {
    Assignment: 'assignment',
    Folder: 'folder'
} as const;

export type EduResourceType = typeof EduResourceType[keyof typeof EduResourceType];


/**
 * Update of an education resource
 * @export
 * @interface EduResourceUpdate
 */
export interface EduResourceUpdate {
    /**
     * Title of the resource
     * @type {string}
     * @memberof EduResourceUpdate
     */
    'title'?: string;
    /**
     * 
     * @type {EduResourcePrivacy}
     * @memberof EduResourceUpdate
     */
    'privacy'?: EduResourcePrivacy;
}


/**
 * Use an education resource in class
 * @export
 * @interface EduResourceUseInClass
 */
export interface EduResourceUseInClass {
    /**
     * The destination classroom where the resource will be copied.
     * @type {string}
     * @memberof EduResourceUseInClass
     */
    'classroom': string;
    /**
     * An optional destination assignment where the original assignement will be copied. Must be a draft.
     * @type {string}
     * @memberof EduResourceUseInClass
     */
    'assignment'?: string;
}
/**
 * An API Error response
 * @export
 * @interface FlatErrorResponse
 */
export interface FlatErrorResponse {
    /**
     * A corresponding code for this error
     * @type {string}
     * @memberof FlatErrorResponse
     */
    'code': string;
    /**
     * A printable message for this error
     * @type {string}
     * @memberof FlatErrorResponse
     */
    'message': string;
    /**
     * An unique error identifier generated for the request
     * @type {string}
     * @memberof FlatErrorResponse
     */
    'id'?: string;
    /**
     * The related parameter that caused the error
     * @type {string}
     * @memberof FlatErrorResponse
     */
    'param'?: string;
}
/**
 * The user language
 * @export
 * @enum {string}
 */

export const FlatLocales = {
    En: 'en',
    EnGb: 'en-GB',
    Es: 'es',
    Fr: 'fr',
    De: 'de',
    It: 'it',
    Ja: 'ja',
    JaHira: 'ja-HIRA',
    Ko: 'ko',
    Nl: 'nl',
    Pl: 'pl',
    Pt: 'pt',
    PtBr: 'pt-BR',
    Ro: 'ro',
    Ru: 'ru',
    Sv: 'sv',
    Tr: 'tr',
    ZhHans: 'zh-Hans'
} as const;

export type FlatLocales = typeof FlatLocales[keyof typeof FlatLocales];


/**
 * A coursework on Google Classroom
 * @export
 * @interface GoogleClassroomCoursework
 */
export interface GoogleClassroomCoursework {
    /**
     * Identifier of the coursework assigned by Classroom
     * @type {string}
     * @memberof GoogleClassroomCoursework
     */
    'id'?: string;
    /**
     * State of the coursework
     * @type {string}
     * @memberof GoogleClassroomCoursework
     */
    'state'?: string;
    /**
     * Absolute link to this coursework in the Classroom web UI
     * @type {string}
     * @memberof GoogleClassroomCoursework
     */
    'alternateLink'?: string;
    /**
     * Identifier of the topic where the assignment is created
     * @type {string}
     * @memberof GoogleClassroomCoursework
     */
    'topicId'?: string | null;
}
/**
 * A coursework submission on Google Classroom
 * @export
 * @interface GoogleClassroomSubmission
 */
export interface GoogleClassroomSubmission {
    /**
     * Identifier of the coursework submission assigned by Classroom
     * @type {string}
     * @memberof GoogleClassroomSubmission
     */
    'id': string;
    /**
     * State of the submission on Google Classroom
     * @type {string}
     * @memberof GoogleClassroomSubmission
     */
    'state': string;
    /**
     * Absolute link to this coursework in the Classroom web UI
     * @type {string}
     * @memberof GoogleClassroomSubmission
     */
    'alternateLink': string;
}
/**
 * A group of users
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * The unique identifier of the group
     * @type {string}
     * @memberof Group
     */
    'id'?: string;
    /**
     * The display name of the group
     * @type {string}
     * @memberof Group
     */
    'name'?: string;
    /**
     * The type of the group: * `generic`: A group created by a Flat user * `classTeachers`: A group created automaticaly by Flat that contains   the teachers of a class * `classStudents`: A group created automaticaly by Flat that contains   the studnets of a class 
     * @type {string}
     * @memberof Group
     */
    'type'?: GroupTypeEnum;
    /**
     * The number of users in this group
     * @type {number}
     * @memberof Group
     */
    'usersCount'?: number;
    /**
     * `True` if the group is set in read-only 
     * @type {boolean}
     * @memberof Group
     */
    'readOnly'?: boolean;
    /**
     * If the group is related to an organization, this field will contain the unique identifier of the organization 
     * @type {string}
     * @memberof Group
     */
    'organization'?: string;
    /**
     * The creation date of the group
     * @type {string}
     * @memberof Group
     */
    'creationDate'?: string;
}

export const GroupTypeEnum = {
    Generic: 'generic',
    ClassTeachers: 'classTeachers',
    ClassStudents: 'classStudents'
} as const;

export type GroupTypeEnum = typeof GroupTypeEnum[keyof typeof GroupTypeEnum];

/**
 * The details of a group
 * @export
 * @interface GroupDetails
 */
export interface GroupDetails {
    /**
     * The unique identifier of the group
     * @type {string}
     * @memberof GroupDetails
     */
    'id'?: string;
    /**
     * The displayable name of the group
     * @type {string}
     * @memberof GroupDetails
     */
    'name'?: string;
    /**
     * 
     * @type {GroupType}
     * @memberof GroupDetails
     */
    'type'?: GroupType;
    /**
     * The unique identifier of the Organization owning the group
     * @type {string}
     * @memberof GroupDetails
     */
    'organization'?: string;
    /**
     * The date when the group was create
     * @type {string}
     * @memberof GroupDetails
     */
    'creationDate'?: string;
    /**
     * The number of students in this group
     * @type {number}
     * @memberof GroupDetails
     */
    'usersCount'?: number;
    /**
     * `true` if the properties and members of this group are in in read-only 
     * @type {boolean}
     * @memberof GroupDetails
     */
    'readOnly'?: boolean;
}


/**
 * The type of the group
 * @export
 * @enum {string}
 */

export const GroupType = {
    Generic: 'generic',
    ClassTeachers: 'classTeachers',
    ClassStudents: 'classStudents'
} as const;

export type GroupType = typeof GroupType[keyof typeof GroupType];


/**
 * Mode of the license
 * @export
 * @enum {string}
 */

export const LicenseMode = {
    Credit: 'credit',
    Site: 'site'
} as const;

export type LicenseMode = typeof LicenseMode[keyof typeof LicenseMode];


/**
 * Source of the license
 * @export
 * @enum {string}
 */

export const LicenseSources = {
    Order: 'order',
    Trial: 'trial',
    Voucher: 'voucher',
    Distributor: 'distributor',
    Subscription: 'subscription',
    AppStore: 'appStore',
    PlayStore: 'playStore',
    Musicfirst: 'musicfirst'
} as const;

export type LicenseSources = typeof LicenseSources[keyof typeof LicenseSources];


/**
 * LMS name
 * @export
 * @enum {string}
 */

export const LmsName = {
    Canvas: 'canvas',
    Moodle: 'moodle',
    Schoology: 'schoology',
    Blackboard: 'blackboard',
    Desire2learn: 'desire2learn',
    Sakai: 'sakai',
    Schoolbox: 'schoolbox',
    Other: 'other'
} as const;

export type LmsName = typeof LmsName[keyof typeof LmsName];


/**
 * A couple of LTI 1.x OAuth credentials
 * @export
 * @interface LtiCredentials
 */
export interface LtiCredentials {
    /**
     * The unique identifier of this couple of credentials
     * @type {string}
     * @memberof LtiCredentials
     */
    'id'?: string;
    /**
     * Name of the couple of credentials
     * @type {string}
     * @memberof LtiCredentials
     */
    'name'?: string;
    /**
     * 
     * @type {LmsName}
     * @memberof LtiCredentials
     */
    'lms'?: LmsName;
    /**
     * The unique identifier of the Organization associated to these credentials
     * @type {string}
     * @memberof LtiCredentials
     */
    'organization'?: string;
    /**
     * Unique identifier of the user who created these credentials
     * @type {string}
     * @memberof LtiCredentials
     */
    'creator'?: string;
    /**
     * The creation date of thse credentials
     * @type {string}
     * @memberof LtiCredentials
     */
    'creationDate'?: string;
    /**
     * The last time these credentials were used
     * @type {string}
     * @memberof LtiCredentials
     */
    'lastUsage'?: string;
    /**
     * OAuth 1 Consumer Key
     * @type {string}
     * @memberof LtiCredentials
     */
    'consumerKey'?: string;
    /**
     * OAuth 1 Consumer Secret
     * @type {string}
     * @memberof LtiCredentials
     */
    'consumerSecret'?: string;
}


/**
 * Creation of a couple of LTI 1.x OAuth credentials
 * @export
 * @interface LtiCredentialsCreation
 */
export interface LtiCredentialsCreation {
    /**
     * Name of the couple of credentials
     * @type {string}
     * @memberof LtiCredentialsCreation
     */
    'name': string;
    /**
     * 
     * @type {LmsName}
     * @memberof LtiCredentialsCreation
     */
    'lms': LmsName;
}


/**
 * Media attachment. The API will automatically resolve the details, oEmbed, and media available if possible and return them in this object 
 * @export
 * @interface MediaAttachment
 */
export interface MediaAttachment {
    /**
     * The type of the assignment resolved: * `rich`, `photo`, `video` are automatically resolved as `link` * A `flat` attachment is a score document where the unique identifier will be specified in the `score` property. Its sharing mode will be provided in the `sharingMode` property. 
     * @type {string}
     * @memberof MediaAttachment
     */
    'type': MediaAttachmentTypeEnum;
    /**
     * An unique Flat score identifier
     * @type {string}
     * @memberof MediaAttachment
     */
    'score'?: string;
    /**
     * An unique revision identifier of a score
     * @type {string}
     * @memberof MediaAttachment
     */
    'revision'?: string;
    /**
     * An unique worksheet identifier
     * @type {string}
     * @memberof MediaAttachment
     */
    'worksheet'?: string;
    /**
     * True if the resource is dedicated for the assignment (for scores and worksheets), meaning on the user-side this one is stored in the assignment
     * @type {boolean}
     * @memberof MediaAttachment
     */
    'dedicated'?: boolean;
    /**
     * A unique track identifier
     * @type {string}
     * @memberof MediaAttachment
     */
    'track'?: string;
    /**
     * 
     * @type {MediaScoreSharingMode}
     * @memberof MediaAttachment
     */
    'sharingMode'?: MediaScoreSharingMode;
    /**
     * To be used with a score attached in `sharingMode` `copy` (score used as template). If true, students won\'t be able to change the original notes of the template.
     * @type {boolean}
     * @memberof MediaAttachment
     */
    'lockScoreTemplate'?: boolean;
    /**
     * The resolved title of the attachment
     * @type {string}
     * @memberof MediaAttachment
     */
    'title'?: string;
    /**
     * The resolved description of the attachment
     * @type {string}
     * @memberof MediaAttachment
     */
    'description'?: string;
    /**
     * If the attachment type is `rich` or `video`, the HTML code of the media to display 
     * @type {string}
     * @memberof MediaAttachment
     */
    'html'?: string;
    /**
     * If the `html` is available, the width of the widget
     * @type {string}
     * @memberof MediaAttachment
     */
    'htmlWidth'?: string;
    /**
     * If the `html` is available, the height of the widget
     * @type {string}
     * @memberof MediaAttachment
     */
    'htmlHeight'?: string;
    /**
     * The url of the attachment
     * @type {string}
     * @memberof MediaAttachment
     */
    'url'?: string;
    /**
     * If the attachment type is `rich`, `video`, `photo` or `link`, a displayable thumbnail for this attachment 
     * @type {string}
     * @memberof MediaAttachment
     */
    'thumbnailUrl'?: string;
    /**
     * If the `thumbnailUrl` is available, the width of the thumbnail 
     * @type {number}
     * @memberof MediaAttachment
     */
    'thumbnailWidth'?: number;
    /**
     * If the `thumbnailUrl` is available, the width of the thumbnail 
     * @type {number}
     * @memberof MediaAttachment
     */
    'thumbnailHeight'?: number;
    /**
     * The resolved author name of the attachment
     * @type {string}
     * @memberof MediaAttachment
     */
    'authorName'?: string;
    /**
     * The resolved author url of the attachment
     * @type {string}
     * @memberof MediaAttachment
     */
    'authorUrl'?: string;
    /**
     * The URL of the icon
     * @type {string}
     * @memberof MediaAttachment
     */
    'iconUrl'?: string;
    /**
     * The mine type of the file
     * @type {string}
     * @memberof MediaAttachment
     */
    'mimeType'?: string;
    /**
     * The ID of the Google Drive File
     * @type {string}
     * @memberof MediaAttachment
     */
    'googleDriveFileId'?: string;
}

export const MediaAttachmentTypeEnum = {
    Rich: 'rich',
    Photo: 'photo',
    Video: 'video',
    Link: 'link',
    Flat: 'flat',
    GoogleDrive: 'googleDrive',
    Worksheet: 'worksheet',
    Performance: 'performance'
} as const;

export type MediaAttachmentTypeEnum = typeof MediaAttachmentTypeEnum[keyof typeof MediaAttachmentTypeEnum];

/**
 * The sharing mode of the score for classes post and assignments
 * @export
 * @enum {string}
 */

export const MediaScoreSharingMode = {
    Read: 'read',
    Write: 'write',
    Copy: 'copy',
    Performance: 'performance'
} as const;

export type MediaScoreSharingMode = typeof MediaScoreSharingMode[keyof typeof MediaScoreSharingMode];


/**
 * A Microsoft Teams asignment
 * @export
 * @interface MicrosoftGraphAssignment
 */
export interface MicrosoftGraphAssignment {
    /**
     * Identifier of the assignement assigned by Microsoft Teams
     * @type {string}
     * @memberof MicrosoftGraphAssignment
     */
    'id'?: string;
    /**
     * State of the assignment
     * @type {string}
     * @memberof MicrosoftGraphAssignment
     */
    'state'?: string;
    /**
     * Absolute link to this assignement in the Microsoft Teams web UI
     * @type {string}
     * @memberof MicrosoftGraphAssignment
     */
    'alternateLink'?: string;
    /**
     * List of categories where this assignment is published under
     * @type {Array<string>}
     * @memberof MicrosoftGraphAssignment
     */
    'categories'?: Array<string>;
}
/**
 * A Microsoft Teams submission
 * @export
 * @interface MicrosoftGraphSubmission
 */
export interface MicrosoftGraphSubmission {
    /**
     * Identifier of the submission assigned by Microsoft Teams
     * @type {string}
     * @memberof MicrosoftGraphSubmission
     */
    'id': string;
    /**
     * State of the submission
     * @type {string}
     * @memberof MicrosoftGraphSubmission
     */
    'state': string;
}
/**
 * Details of an invitation to join an organization
 * @export
 * @interface OrganizationInvitation
 */
export interface OrganizationInvitation {
    /**
     * The invitation unique identifier
     * @type {string}
     * @memberof OrganizationInvitation
     */
    'id'?: string;
    /**
     * The creation date of the invitation
     * @type {string}
     * @memberof OrganizationInvitation
     */
    'creationDate'?: string;
    /**
     * The unique identifier of the Organization owning this class
     * @type {string}
     * @memberof OrganizationInvitation
     */
    'organization': string;
    /**
     * 
     * @type {OrganizationRoles}
     * @memberof OrganizationInvitation
     */
    'organizationRole': OrganizationRoles;
    /**
     * Enrollment code to use when joining this organization
     * @type {string}
     * @memberof OrganizationInvitation
     */
    'customCode': string | null;
    /**
     * The email address this invitation was sent to
     * @type {string}
     * @memberof OrganizationInvitation
     */
    'email'?: string;
    /**
     * The unique identifier of the User who created this invitation
     * @type {string}
     * @memberof OrganizationInvitation
     */
    'invitedBy'?: string;
    /**
     * If true, the invitation can be used multiple times. If false, the invitation can only be used once. 
     * @type {boolean}
     * @memberof OrganizationInvitation
     */
    'allowMultipleUse': boolean;
    /**
     * List of users who used this invitation
     * @type {Array<string>}
     * @memberof OrganizationInvitation
     */
    'usedBy'?: Array<string>;
}


/**
 * The parameters to create an organization invitation
 * @export
 * @interface OrganizationInvitationCreation
 */
export interface OrganizationInvitationCreation {
    /**
     * The email address you want to send the invitation to
     * @type {string}
     * @memberof OrganizationInvitationCreation
     */
    'email'?: string;
    /**
     * User\'s Organization Role
     * @type {string}
     * @memberof OrganizationInvitationCreation
     */
    'organizationRole'?: OrganizationInvitationCreationOrganizationRoleEnum;
}

export const OrganizationInvitationCreationOrganizationRoleEnum = {
    Admin: 'admin',
    Teacher: 'teacher'
} as const;

export type OrganizationInvitationCreationOrganizationRoleEnum = typeof OrganizationInvitationCreationOrganizationRoleEnum[keyof typeof OrganizationInvitationCreationOrganizationRoleEnum];

/**
 * User\'s Organization Role (for Edu users only)
 * @export
 * @enum {string}
 */

export const OrganizationRoles = {
    Admin: 'admin',
    Billing: 'billing',
    Teacher: 'teacher',
    User: 'user'
} as const;

export type OrganizationRoles = typeof OrganizationRoles[keyof typeof OrganizationRoles];


/**
 * Creation of a delegated API access token for an organization user
 * @export
 * @interface OrganizationUserAccessTokenCreation
 */
export interface OrganizationUserAccessTokenCreation {
    /**
     * List of requested scopes for this credential
     * @type {Array<AppScopes>}
     * @memberof OrganizationUserAccessTokenCreation
     */
    'scopes': Array<AppScopes>;
}
/**
 * 
 * @export
 * @interface ResourceCollaborator
 */
export interface ResourceCollaborator {
    /**
     * `True` if the current user can read the current document 
     * @type {boolean}
     * @memberof ResourceCollaborator
     */
    'aclRead': boolean;
    /**
     * `True` if the current user can modify the current document.  If this is a right of a Collection, the capabilities of the associated user can be lower than this permission, check out the `capabilities` property as the end-user to have the complete possibilities with the collection. 
     * @type {boolean}
     * @memberof ResourceCollaborator
     */
    'aclWrite': boolean;
    /**
     * `True` if the current user can manage the current document (i.e. share, delete)  If this is a right of a Collection, the capabilities of the associated user can be lower than this permission, check out the `capabilities` property as the end-user to have the complete possibilities with the collection. 
     * @type {boolean}
     * @memberof ResourceCollaborator
     */
    'aclAdmin': boolean;
    /**
     * `True` if the current user is a collaborator of the current document (direct or via group). 
     * @type {boolean}
     * @memberof ResourceCollaborator
     */
    'isCollaborator': boolean;
    /**
     * The type of the collaborator for the resource 
     * @type {string}
     * @memberof ResourceCollaborator
     */
    'collaboratorType'?: ResourceCollaboratorCollaboratorTypeEnum;
    /**
     * The unique identifier of the permission
     * @type {string}
     * @memberof ResourceCollaborator
     */
    'id'?: string;
    /**
     * The date when the permission was added
     * @type {string}
     * @memberof ResourceCollaborator
     */
    'date'?: string;
    /**
     * If this object is a permission of a score, this property will contain the unique identifier of the score
     * @type {string}
     * @memberof ResourceCollaborator
     */
    'score'?: string;
    /**
     * If this object is a permission of a collection, this property will contain the unique identifier of the collection
     * @type {string}
     * @memberof ResourceCollaborator
     */
    'collection'?: string;
    /**
     * 
     * @type {UserPublic}
     * @memberof ResourceCollaborator
     */
    'user'?: UserPublic;
    /**
     * 
     * @type {Group}
     * @memberof ResourceCollaborator
     */
    'group'?: Group;
    /**
     * If the collaborator is not a user of Flat yet, this field will contain their email. 
     * @type {string}
     * @memberof ResourceCollaborator
     */
    'userEmail'?: string;
    /**
     * If this property is `true`, this is still a pending invitation 
     * @type {boolean}
     * @memberof ResourceCollaborator
     */
    'invited'?: boolean;
}

export const ResourceCollaboratorCollaboratorTypeEnum = {
    Owner: 'owner',
    User: 'user',
    Group: 'group'
} as const;

export type ResourceCollaboratorCollaboratorTypeEnum = typeof ResourceCollaboratorCollaboratorTypeEnum[keyof typeof ResourceCollaboratorCollaboratorTypeEnum];

/**
 * Add a collaborator to a resource.
 * @export
 * @interface ResourceCollaboratorCreation
 */
export interface ResourceCollaboratorCreation {
    /**
     * The unique identifier of a Flat user
     * @type {string}
     * @memberof ResourceCollaboratorCreation
     */
    'user'?: string;
    /**
     * The unique identifier of a Flat group
     * @type {string}
     * @memberof ResourceCollaboratorCreation
     */
    'group'?: string;
    /**
     * Fill this field to invite an individual user by email. 
     * @type {string}
     * @memberof ResourceCollaboratorCreation
     */
    'userEmail'?: string;
    /**
     * Token received in an invitation to join the score. 
     * @type {string}
     * @memberof ResourceCollaboratorCreation
     */
    'userToken'?: string;
    /**
     * `True` if the related user can read the score. (probably true if the user has a permission on the document). 
     * @type {boolean}
     * @memberof ResourceCollaboratorCreation
     */
    'aclRead'?: boolean;
    /**
     * `True` if the related user can modify the score. 
     * @type {boolean}
     * @memberof ResourceCollaboratorCreation
     */
    'aclWrite'?: boolean;
    /**
     * `True` if the related user can can manage the current document, i.e. changing the document permissions and deleting the document 
     * @type {boolean}
     * @memberof ResourceCollaboratorCreation
     */
    'aclAdmin'?: boolean;
}
/**
 * The rights of the current user on a score or collection
 * @export
 * @interface ResourceRights
 */
export interface ResourceRights {
    /**
     * `True` if the current user can read the current document 
     * @type {boolean}
     * @memberof ResourceRights
     */
    'aclRead': boolean;
    /**
     * `True` if the current user can modify the current document.  If this is a right of a Collection, the capabilities of the associated user can be lower than this permission, check out the `capabilities` property as the end-user to have the complete possibilities with the collection. 
     * @type {boolean}
     * @memberof ResourceRights
     */
    'aclWrite': boolean;
    /**
     * `True` if the current user can manage the current document (i.e. share, delete)  If this is a right of a Collection, the capabilities of the associated user can be lower than this permission, check out the `capabilities` property as the end-user to have the complete possibilities with the collection. 
     * @type {boolean}
     * @memberof ResourceRights
     */
    'aclAdmin': boolean;
    /**
     * `True` if the current user is a collaborator of the current document (direct or via group). 
     * @type {boolean}
     * @memberof ResourceRights
     */
    'isCollaborator': boolean;
    /**
     * The type of the collaborator for the resource 
     * @type {string}
     * @memberof ResourceRights
     */
    'collaboratorType'?: ResourceRightsCollaboratorTypeEnum;
}

export const ResourceRightsCollaboratorTypeEnum = {
    Owner: 'owner',
    User: 'user',
    Group: 'group'
} as const;

export type ResourceRightsCollaboratorTypeEnum = typeof ResourceRightsCollaboratorTypeEnum[keyof typeof ResourceRightsCollaboratorTypeEnum];

/**
 * Comment added on a sheet music
 * @export
 * @interface ScoreComment
 */
export interface ScoreComment {
    /**
     * The comment unique identifier
     * @type {string}
     * @memberof ScoreComment
     */
    'id'?: string;
    /**
     * The type of the comment
     * @type {string}
     * @memberof ScoreComment
     */
    'type'?: ScoreCommentTypeEnum;
    /**
     * The author unique identifier
     * @type {string}
     * @memberof ScoreComment
     */
    'user'?: string;
    /**
     * The unique identifier of the score where the comment was posted
     * @type {string}
     * @memberof ScoreComment
     */
    'score'?: string;
    /**
     * The unique identifier of revision the comment was posted
     * @type {string}
     * @memberof ScoreComment
     */
    'revision'?: string;
    /**
     * When the comment is a reply to another comment, the unique identifier of the parent comment 
     * @type {string}
     * @memberof ScoreComment
     */
    'replyTo'?: string;
    /**
     * The date when the comment was posted
     * @type {string}
     * @memberof ScoreComment
     */
    'date'?: string;
    /**
     * The date of the last comment modification
     * @type {string}
     * @memberof ScoreComment
     */
    'modificationDate'?: string;
    /**
     * The comment text that can includes mentions using the following format: `@[id:username]`. 
     * @type {string}
     * @memberof ScoreComment
     */
    'comment'?: string;
    /**
     * A raw version of the comment, that can be displayed without parsing the mentions. 
     * @type {string}
     * @memberof ScoreComment
     */
    'rawComment'?: string;
    /**
     * 
     * @type {ScoreCommentContext}
     * @memberof ScoreComment
     */
    'context'?: ScoreCommentContext;
    /**
     * The list of user identifier mentioned on the score
     * @type {Array<string>}
     * @memberof ScoreComment
     */
    'mentions'?: Array<string>;
    /**
     * For inline comments, the comment can be marked as resolved and will be hidden in the future responses 
     * @type {boolean}
     * @memberof ScoreComment
     */
    'resolved'?: boolean;
    /**
     * If the user is marked as resolved, this will contain the unique identifier of the User who marked this comment as resolved 
     * @type {string}
     * @memberof ScoreComment
     */
    'resolvedBy'?: string;
    /**
     * 
     * @type {ScoreCommentModeration}
     * @memberof ScoreComment
     */
    'moderation'?: ScoreCommentModeration;
    /**
     * `true  if the message has been detected as spam and hidden from other users 
     * @type {boolean}
     * @memberof ScoreComment
     */
    'spam'?: boolean;
}

export const ScoreCommentTypeEnum = {
    Document: 'document',
    Inline: 'inline'
} as const;

export type ScoreCommentTypeEnum = typeof ScoreCommentTypeEnum[keyof typeof ScoreCommentTypeEnum];

/**
 * The context of the comment (for inline/contextualized comments). A context will include all the information related to the location of the comment (i.e. score parts, range of measure, time position). 
 * @export
 * @interface ScoreCommentContext
 */
export interface ScoreCommentContext {
    /**
     * The unique identifier (UUID) of the score part
     * @type {string}
     * @memberof ScoreCommentContext
     */
    'partUuid': string;
    /**
     * (Deprecated, use `staffUuid`) The identififer of the staff
     * @type {number}
     * @memberof ScoreCommentContext
     */
    'staffIdx'?: number;
    /**
     * The unique identififer (UUID) of the staff
     * @type {string}
     * @memberof ScoreCommentContext
     */
    'staffUuid'?: string;
    /**
     * The list of measure UUIds
     * @type {Array<string>}
     * @memberof ScoreCommentContext
     */
    'measureUuids': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ScoreCommentContext
     */
    'startTimePos': number;
    /**
     * 
     * @type {number}
     * @memberof ScoreCommentContext
     */
    'stopTimePos': number;
    /**
     * 
     * @type {number}
     * @memberof ScoreCommentContext
     */
    'startDpq': number;
    /**
     * 
     * @type {number}
     * @memberof ScoreCommentContext
     */
    'stopDpq': number;
}
/**
 * Creation of a comment
 * @export
 * @interface ScoreCommentCreation
 */
export interface ScoreCommentCreation {
    /**
     * The unique indentifier of the revision of the score where the comment was added. If this property is unspecified or contains \"last\", the API will automatically take the last revision created. 
     * @type {string}
     * @memberof ScoreCommentCreation
     */
    'revision'?: string;
    /**
     * The comment text that can includes mentions using the following format: `@[id:username]`. 
     * @type {string}
     * @memberof ScoreCommentCreation
     */
    'comment': string;
    /**
     * A raw version of the comment, that can be displayed without the mentions. If you use mentions, this property must be set. 
     * @type {string}
     * @memberof ScoreCommentCreation
     */
    'rawComment'?: string;
    /**
     * The list of user identifiers mentioned in this comment
     * @type {Array<string>}
     * @memberof ScoreCommentCreation
     */
    'mentions'?: Array<string>;
    /**
     * When the comment is a reply to another comment, the unique identifier of the parent comment 
     * @type {string}
     * @memberof ScoreCommentCreation
     */
    'replyTo'?: string;
    /**
     * 
     * @type {ScoreCommentContext}
     * @memberof ScoreCommentCreation
     */
    'context'?: ScoreCommentContext;
}
/**
 * Information about the comment being moderated
 * @export
 * @interface ScoreCommentModeration
 */
export interface ScoreCommentModeration {
    /**
     * If true, this comment will be hidden from other users
     * @type {boolean}
     * @memberof ScoreCommentModeration
     */
    'hidden'?: boolean;
    /**
     * If the comment is hidden, the reason why this one has been moderated
     * @type {string}
     * @memberof ScoreCommentModeration
     */
    'reason'?: ScoreCommentModerationReasonEnum;
}

export const ScoreCommentModerationReasonEnum = {
    Spam: 'spam',
    Inappropriate: 'inappropriate'
} as const;

export type ScoreCommentModerationReasonEnum = typeof ScoreCommentModerationReasonEnum[keyof typeof ScoreCommentModerationReasonEnum];

/**
 * Update of a comment
 * @export
 * @interface ScoreCommentUpdate
 */
export interface ScoreCommentUpdate {
    /**
     * The unique indentifier of the revision of the score where the comment was added. If this property is unspecified or contains \"last\", the API will automatically take the last revision created. 
     * @type {string}
     * @memberof ScoreCommentUpdate
     */
    'revision'?: string;
    /**
     * The comment text that can includes mentions using the following format: `@[id:username]`. 
     * @type {string}
     * @memberof ScoreCommentUpdate
     */
    'comment'?: string;
    /**
     * A raw version of the comment, that can be displayed without the mentions. If you use mentions, this property must be set. 
     * @type {string}
     * @memberof ScoreCommentUpdate
     */
    'rawComment'?: string;
    /**
     * 
     * @type {ScoreCommentContext}
     * @memberof ScoreCommentUpdate
     */
    'context'?: ScoreCommentContext;
}
/**
 * A computed version of the total, unique, weekly and monthly number of comments added on the documents (this doesn\'t include inline comments). 
 * @export
 * @interface ScoreCommentsCounts
 */
export interface ScoreCommentsCounts {
    /**
     * The total number of comments added to the score
     * @type {number}
     * @memberof ScoreCommentsCounts
     */
    'total'?: number;
    /**
     * The unique (1/user) number of comments added to the score
     * @type {number}
     * @memberof ScoreCommentsCounts
     */
    'unique'?: number;
    /**
     * The weekly unique number of comments added to the score
     * @type {number}
     * @memberof ScoreCommentsCounts
     */
    'weekly'?: number;
    /**
     * The monthly unique number of comments added to the score
     * @type {number}
     * @memberof ScoreCommentsCounts
     */
    'monthly'?: number;
}
/**
 * 
 * @export
 * @interface ScoreCreation
 */
export interface ScoreCreation {
    /**
     * The title of the new score. If the title is too long, the API may trim this one.  If this title is not specified, the API will try to (in this order):   - Use the title contained in the file (e.g. [`movement-title`](https://usermanuals.musicxml.com/MusicXML/Content/EL-MusicXML-movement-title.htm) or [`credit-words`](https://usermanuals.musicxml.com/MusicXML/Content/EL-MusicXML-credit-words.htm) for [MusicXML](http://www.musicxml.com/) files).   - Use the name of the file for files from a specified `source` (e.g. Google Drive) or the one in the `filename` property   - Set a default title (e.g. \"New Music Score\") 
     * @type {string}
     * @memberof ScoreCreation
     */
    'title'?: string;
    /**
     * 
     * @type {ScorePrivacy}
     * @memberof ScoreCreation
     */
    'privacy'?: ScorePrivacy;
    /**
     * Unique identifier of a collection where the score will be created. If no collection identifier is provided, the score will be stored in the `root` directory. 
     * @type {string}
     * @memberof ScoreCreation
     */
    'collection'?: string;
    /**
     * If the user uses Google Drive and this properties is specified, the file will be created in this directory. The currently user creating the file must be granted to write in this directory. 
     * @type {string}
     * @memberof ScoreCreation
     */
    'googleDriveFolder'?: string;
    /**
     * 
     * @type {ScoreCreationBuilderData}
     * @memberof ScoreCreation
     */
    'builderData'?: ScoreCreationBuilderData;
    /**
     * If this is an imported file, its filename
     * @type {string}
     * @memberof ScoreCreation
     */
    'filename'?: string;
    /**
     * The data of the score file. It must be a MusicXML 3 file (`vnd.recordare.musicxml` or `vnd.recordare.musicxml+xml`), a MIDI file (`audio/midi`) or a Flat.json (aka Adagio.json) file. Binary payloads (`vnd.recordare.musicxml` and `audio/midi`) can be encoded in Base64, in this case the `dataEncoding` property must match the encoding used for the API request. 
     * @type {string}
     * @memberof ScoreCreation
     */
    'data'?: string;
    /**
     * The optional encoding of the score data. This property must match the encoding used for the `data` property.
     * @type {string}
     * @memberof ScoreCreation
     */
    'dataEncoding'?: ScoreCreationDataEncodingEnum;
    /**
     * 
     * @type {ScoreSource}
     * @memberof ScoreCreation
     */
    'source'?: ScoreSource;
}

export const ScoreCreationDataEncodingEnum = {
    Base64: 'base64'
} as const;

export type ScoreCreationDataEncodingEnum = typeof ScoreCreationDataEncodingEnum[keyof typeof ScoreCreationDataEncodingEnum];

/**
 * 
 * @export
 * @interface ScoreCreationBuilderData
 */
export interface ScoreCreationBuilderData {
    /**
     * 
     * @type {ScoreCreationBuilderDataScoreData}
     * @memberof ScoreCreationBuilderData
     */
    'scoreData': ScoreCreationBuilderDataScoreData;
    /**
     * 
     * @type {ScoreCreationBuilderDataLayoutData}
     * @memberof ScoreCreationBuilderData
     */
    'layoutData'?: ScoreCreationBuilderDataLayoutData;
}
/**
 * Control the appearance of the score. If missing, default values are used.
 * @export
 * @interface ScoreCreationBuilderDataLayoutData
 */
export interface ScoreCreationBuilderDataLayoutData {
    /**
     * A float value >= 1 that controls the spacing between notes.
     * @type {number}
     * @memberof ScoreCreationBuilderDataLayoutData
     */
    'notesSpacingCoeff'?: number;
    /**
     * The unit to use for layout customizations
     * @type {string}
     * @memberof ScoreCreationBuilderDataLayoutData
     */
    'lengthUnit'?: ScoreCreationBuilderDataLayoutDataLengthUnitEnum;
    /**
     * The height of the page in chosen unit (`lengthUnit`).
     * @type {number}
     * @memberof ScoreCreationBuilderDataLayoutData
     */
    'pageHeight'?: number;
    /**
     * The width of the page in chosen unit (`lengthUnit`).
     * @type {number}
     * @memberof ScoreCreationBuilderDataLayoutData
     */
    'pageWidth'?: number;
    /**
     * The top margin of the page in chosen unit (`lengthUnit`).
     * @type {number}
     * @memberof ScoreCreationBuilderDataLayoutData
     */
    'pageMarginTop'?: number;
    /**
     * The bottom margin of the page in chosen unit (`lengthUnit`).
     * @type {number}
     * @memberof ScoreCreationBuilderDataLayoutData
     */
    'pageMarginBottom'?: number;
    /**
     * The left margin of the page in chosen unit (`lengthUnit`).
     * @type {number}
     * @memberof ScoreCreationBuilderDataLayoutData
     */
    'pageMarginLeft'?: number;
    /**
     * The right margin of the page in chosen unit (`lengthUnit`).
     * @type {number}
     * @memberof ScoreCreationBuilderDataLayoutData
     */
    'pageMarginRight'?: number;
}

export const ScoreCreationBuilderDataLayoutDataLengthUnitEnum = {
    Cm: 'cm',
    Inch: 'inch'
} as const;

export type ScoreCreationBuilderDataLayoutDataLengthUnitEnum = typeof ScoreCreationBuilderDataLayoutDataLengthUnitEnum[keyof typeof ScoreCreationBuilderDataLayoutDataLengthUnitEnum];

/**
 * 
 * @export
 * @interface ScoreCreationBuilderDataScoreData
 */
export interface ScoreCreationBuilderDataScoreData {
    /**
     * true if the TAB staff is displayed with fretted instruments
     * @type {boolean}
     * @memberof ScoreCreationBuilderDataScoreData
     */
    'useTabStaff'?: boolean;
    /**
     * true if the chord grid must be displayed with fretted instruments
     * @type {boolean}
     * @memberof ScoreCreationBuilderDataScoreData
     */
    'useChordGrid'?: boolean;
    /**
     * The key signature of the score (expressed between -7 and 7). Major C is used when the value is not provided.
     * @type {number}
     * @memberof ScoreCreationBuilderDataScoreData
     */
    'fifths'?: number;
    /**
     * The number of beats in the measure
     * @type {number}
     * @memberof ScoreCreationBuilderDataScoreData
     */
    'nbBeats'?: number;
    /**
     * The duration of a beat in the measure
     * @type {number}
     * @memberof ScoreCreationBuilderDataScoreData
     */
    'beatType'?: number;
    /**
     * The list of instruments to add to the score. See https://prod.flat-cdn.com/fixtures/instruments_en.json for the possible values for `group` and `instrument`. 
     * @type {Array<ScoreCreationBuilderDataScoreDataInstrumentsInner>}
     * @memberof ScoreCreationBuilderDataScoreData
     */
    'instruments': Array<ScoreCreationBuilderDataScoreDataInstrumentsInner>;
}
/**
 * 
 * @export
 * @interface ScoreCreationBuilderDataScoreDataInstrumentsInner
 */
export interface ScoreCreationBuilderDataScoreDataInstrumentsInner {
    /**
     * The  of the instrument group (e.g. `keyboards`, `brass`)
     * @type {string}
     * @memberof ScoreCreationBuilderDataScoreDataInstrumentsInner
     */
    'group': string;
    /**
     * The identifier of the instrument (e.g. `piano`, `trumpet`)
     * @type {string}
     * @memberof ScoreCreationBuilderDataScoreDataInstrumentsInner
     */
    'instrument': string;
    /**
     * The full name of the instrument
     * @type {string}
     * @memberof ScoreCreationBuilderDataScoreDataInstrumentsInner
     */
    'longName'?: string;
    /**
     * The abbreviation of the name of the instrument
     * @type {string}
     * @memberof ScoreCreationBuilderDataScoreDataInstrumentsInner
     */
    'shortName'?: string;
    /**
     * True if the part can use quarter tone (prevent the part to have a TAB/chord grid)
     * @type {boolean}
     * @memberof ScoreCreationBuilderDataScoreDataInstrumentsInner
     */
    'hasQuarterTone'?: boolean;
}
/**
 * The type of creation (an orginal, an arrangement)
 * @export
 * @enum {string}
 */

export const ScoreCreationType = {
    Original: 'original',
    Arrangement: 'arrangement',
    Other: 'other',
    Null: 'null'
} as const;

export type ScoreCreationType = typeof ScoreCreationType[keyof typeof ScoreCreationType];


/**
 * 
 * @export
 * @interface ScoreDetails
 */
export interface ScoreDetails {
    /**
     * The unique identifier of the score
     * @type {string}
     * @memberof ScoreDetails
     */
    'id': string;
    /**
     * The private sharing key of the score (available when the `privacy` mode is set to `privateLink`)
     * @type {string}
     * @memberof ScoreDetails
     */
    'sharingKey'?: string;
    /**
     * The title of the score
     * @type {string}
     * @memberof ScoreDetails
     */
    'title': string;
    /**
     * 
     * @type {ScorePrivacy}
     * @memberof ScoreDetails
     */
    'privacy': ScorePrivacy;
    /**
     * 
     * @type {UserPublic}
     * @memberof ScoreDetails
     */
    'user': UserPublic;
    /**
     * The url where the score can be viewed in a web browser
     * @type {string}
     * @memberof ScoreDetails
     */
    'htmlUrl': string;
    /**
     * Subtitle of the score
     * @type {string}
     * @memberof ScoreDetails
     */
    'subtitle'?: string;
    /**
     * Lyricist of the score
     * @type {string}
     * @memberof ScoreDetails
     */
    'lyricist'?: string;
    /**
     * Arranger of the score
     * @type {string}
     * @memberof ScoreDetails
     */
    'arranger'?: string;
    /**
     * Composer of the score
     * @type {string}
     * @memberof ScoreDetails
     */
    'composer'?: string;
    /**
     * Description of the creation
     * @type {string}
     * @memberof ScoreDetails
     */
    'description'?: string;
    /**
     * Tags describing the score
     * @type {Array<string>}
     * @memberof ScoreDetails
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {ScoreCreationType}
     * @memberof ScoreDetails
     */
    'creationType'?: ScoreCreationType | null;
    /**
     * 
     * @type {ScoreLicense}
     * @memberof ScoreDetails
     */
    'license'?: ScoreLicense | null;
    /**
     * Additional license text written on the exported/printed score
     * @type {string}
     * @memberof ScoreDetails
     */
    'licenseText'?: string;
    /**
     * In seconds, an approximative duration of the score
     * @type {number}
     * @memberof ScoreDetails
     */
    'durationTime'?: number;
    /**
     * The number of measures in the score
     * @type {number}
     * @memberof ScoreDetails
     */
    'numberMeasures'?: number;
    /**
     * The main tempo of the score (in QPM)
     * @type {number}
     * @memberof ScoreDetails
     */
    'mainTempoQpm'?: number;
    /**
     * The main key signature of the score (expressed between -7 and 7).
     * @type {number}
     * @memberof ScoreDetails
     */
    'mainKeySignature'?: number;
    /**
     * 
     * @type {ResourceRights}
     * @memberof ScoreDetails
     */
    'rights'?: ResourceRights;
    /**
     * The list of the collaborators of the score
     * @type {Array<ResourceCollaborator>}
     * @memberof ScoreDetails
     */
    'collaborators'?: Array<ResourceCollaborator>;
    /**
     * The date when the score was created
     * @type {string}
     * @memberof ScoreDetails
     */
    'creationDate'?: string;
    /**
     * The date of the last revision of the score
     * @type {string}
     * @memberof ScoreDetails
     */
    'modificationDate'?: string;
    /**
     * The date when the score was published on Flat
     * @type {string}
     * @memberof ScoreDetails
     */
    'publicationDate'?: string;
    /**
     * The date when the score was highlighted (featured) on our community
     * @type {string}
     * @memberof ScoreDetails
     */
    'highlightedDate'?: string;
    /**
     * If the score has been created in an organization, the identifier of this organization. This property is especially used with the score privacy `organizationPublic`. 
     * @type {string}
     * @memberof ScoreDetails
     */
    'organization'?: string;
    /**
     * If the score has been forked, the unique identifier of the parent score. 
     * @type {string}
     * @memberof ScoreDetails
     */
    'parentScore'?: string;
    /**
     * An array of the instrument identifiers used in the last version of the score. This is mainly used to display a list of the instruments in the Flat\'s UI or instruments icons. The format of the strings is `{instrument-group}.{instrument-id}`. 
     * @type {Array<string>}
     * @memberof ScoreDetails
     */
    'instruments'?: Array<string>;
    /**
     * An array of the audio samples identifiers used the different score parts. The format of the strings is `{instrument-group}.{sample-id}`. 
     * @type {Array<string>}
     * @memberof ScoreDetails
     */
    'samples'?: Array<string>;
    /**
     * If the user uses Google Drive and the score exists on Google Drive, this field will contain the unique identifier of the Flat score on Google Drive. You can access the document using the url: `https://drive.google.com/open?id={googleDriveFileId}` 
     * @type {string}
     * @memberof ScoreDetails
     */
    'googleDriveFileId'?: string;
    /**
     * 
     * @type {ScoreLikesCounts}
     * @memberof ScoreDetails
     */
    'likes'?: ScoreLikesCounts;
    /**
     * 
     * @type {ScoreCommentsCounts}
     * @memberof ScoreDetails
     */
    'comments'?: ScoreCommentsCounts;
    /**
     * 
     * @type {ScoreViewsCounts}
     * @memberof ScoreDetails
     */
    'views'?: ScoreViewsCounts;
    /**
     * 
     * @type {ScorePlaysCounts}
     * @memberof ScoreDetails
     */
    'plays'?: ScorePlaysCounts;
    /**
     * The List of parent collections, which includes all the collections this score is included. Please note that you might not have access to all of them.
     * @type {Array<string>}
     * @memberof ScoreDetails
     */
    'collections'?: Array<string>;
}


/**
 * Options to fork the score
 * @export
 * @interface ScoreFork
 */
export interface ScoreFork {
    /**
     * Unique identifier of a collection where the score will be copied. If no collection identifier is provided, the score will be stored in the `root` directory. If null is provided, the score won\'t be added to any collections 
     * @type {string}
     * @memberof ScoreFork
     */
    'collection'?: string | null;
    /**
     * If set to `true`, the API won\'t create the score on Google Drive 
     * @type {boolean}
     * @memberof ScoreFork
     */
    'googleDriveDisabled'?: boolean;
    /**
     * Option to keep the original title of the score (i.e. don\'t prepend it with \"Copy of \", or add the student name in assignment usage). 
     * @type {boolean}
     * @memberof ScoreFork
     */
    'keepOriginalTitle'?: boolean;
}
/**
 * License of the creation. Read more about the Creative Commons licenses on https://creativecommons.org/licenses/ 
 * @export
 * @enum {string}
 */

export const ScoreLicense = {
    Copyright: 'copyright',
    Cc0: 'cc0',
    CcBy: 'cc-by',
    CcBySa: 'cc-by-sa',
    CcByNd: 'cc-by-nd',
    CcByNc: 'cc-by-nc',
    CcByNcSa: 'cc-by-nc-sa',
    CcByNcNd: 'cc-by-nc-nd',
    Null: 'null'
} as const;

export type ScoreLicense = typeof ScoreLicense[keyof typeof ScoreLicense];


/**
 * A computed version of the weekly, monthly and total of number of likes for a score 
 * @export
 * @interface ScoreLikesCounts
 */
export interface ScoreLikesCounts {
    /**
     * The total number of likes of the score
     * @type {number}
     * @memberof ScoreLikesCounts
     */
    'total': number;
    /**
     * The number of new likes during the last week
     * @type {number}
     * @memberof ScoreLikesCounts
     */
    'weekly': number;
    /**
     * The number of new likes during the last month
     * @type {number}
     * @memberof ScoreLikesCounts
     */
    'monthly': number;
}
/**
 * Edit the score metadata
 * @export
 * @interface ScoreModification
 */
export interface ScoreModification {
    /**
     * The title of the score
     * @type {string}
     * @memberof ScoreModification
     */
    'title'?: string;
    /**
     * The subtitle of the score
     * @type {string}
     * @memberof ScoreModification
     */
    'subtitle'?: string | null;
    /**
     * The composer of the score
     * @type {string}
     * @memberof ScoreModification
     */
    'composer'?: string | null;
    /**
     * The lyricist of the score
     * @type {string}
     * @memberof ScoreModification
     */
    'lyricist'?: string | null;
    /**
     * The arranger of the score
     * @type {string}
     * @memberof ScoreModification
     */
    'arranger'?: string | null;
    /**
     * 
     * @type {ScorePrivacy}
     * @memberof ScoreModification
     */
    'privacy'?: ScorePrivacy;
    /**
     * When using the `privacy` mode `privateLink`, this property can be used to set a custom sharing key, otherwise a new key will be generated.
     * @type {string}
     * @memberof ScoreModification
     */
    'sharingKey'?: string;
    /**
     * Description of the creation
     * @type {string}
     * @memberof ScoreModification
     */
    'description'?: string | null;
    /**
     * Tags describing the score
     * @type {Array<string>}
     * @memberof ScoreModification
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {ScoreCreationType}
     * @memberof ScoreModification
     */
    'creationType'?: ScoreCreationType | null;
    /**
     * 
     * @type {ScoreLicense}
     * @memberof ScoreModification
     */
    'license'?: ScoreLicense | null;
    /**
     * The rights info written on the score
     * @type {string}
     * @memberof ScoreModification
     */
    'licenseText'?: string | null;
}


/**
 * A computed version of the total, weekly, and monthly number of plays of the score 
 * @export
 * @interface ScorePlaysCounts
 */
export interface ScorePlaysCounts {
    /**
     * The total number of plays of the score
     * @type {number}
     * @memberof ScorePlaysCounts
     */
    'total'?: number;
    /**
     * The weekly number of plays of the score
     * @type {number}
     * @memberof ScorePlaysCounts
     */
    'weekly'?: number;
    /**
     * The monthly number of plays of the score
     * @type {number}
     * @memberof ScorePlaysCounts
     */
    'monthly'?: number;
}
/**
 * The score main privacy mode.  - `public`: The score is public on the Internet. This one can be accessible at the url `https://flat.io/score/{score}` and can be modified and administred by specified collaborators users. - `private`: The score is private and can be only accessed, modified and administred by specified collaborators users. - `privateLink`: The score is private but can be accessed using a private link `htmlUrl` or the private key in the property `sharingKey`. - `organizationPublic`: _Available only with [Flat for Education](https://flat.io/edu)._ The score is public in the organization: users of the same organization can access to this one. The score can be modified and administred by specified collaborators users.  The score can also be individually shared to a set of users or groups using the different collaborators API methods.  When a file is synchronized from an external source (e.g. Google Drive) and the sharing options are changed on the source, Flat will chose the best privacy mode for the file.  When using a [Flat for Education](https://flat.io/edu) account, some of the modes may not be available if disabled by an administrator of the organization (e.g. by default the `public` mode is not available). 
 * @export
 * @enum {string}
 */

export const ScorePrivacy = {
    Public: 'public',
    Private: 'private',
    OrganizationPublic: 'organizationPublic',
    PrivateLink: 'privateLink'
} as const;

export type ScorePrivacy = typeof ScorePrivacy[keyof typeof ScorePrivacy];


/**
 * A score revision metadata
 * @export
 * @interface ScoreRevision
 */
export interface ScoreRevision {
    /**
     * The unique identifier of the revision.
     * @type {string}
     * @memberof ScoreRevision
     */
    'id'?: string;
    /**
     * The user identifier who created the revision
     * @type {string}
     * @memberof ScoreRevision
     */
    'user'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScoreRevision
     */
    'collaborators'?: Array<string>;
    /**
     * The date when this revision was created
     * @type {string}
     * @memberof ScoreRevision
     */
    'creationDate'?: string;
    /**
     * The last event (action id) of the revision
     * @type {string}
     * @memberof ScoreRevision
     */
    'event'?: string;
    /**
     * A description associated to the revision
     * @type {string}
     * @memberof ScoreRevision
     */
    'description'?: string;
    /**
     * True if this revision was automatically generated by Flat and not on purpose by the user. 
     * @type {boolean}
     * @memberof ScoreRevision
     */
    'autosave'?: boolean;
    /**
     * 
     * @type {ScoreRevisionStatistics}
     * @memberof ScoreRevision
     */
    'statistics'?: ScoreRevisionStatistics;
}
/**
 * A new created revision
 * @export
 * @interface ScoreRevisionCreation
 */
export interface ScoreRevisionCreation {
    /**
     * The data of the score file. It must be a MusicXML 3 file (`vnd.recordare.musicxml` or `vnd.recordare.musicxml+xml`), a MIDI file (`audio/midi`) or a Flat.json (aka Adagio.json) file. Binary payloads (`vnd.recordare.musicxml` and `audio/midi`) can be encoded in Base64, in this case the `dataEncoding` property must match the encoding used for the API request. 
     * @type {string}
     * @memberof ScoreRevisionCreation
     */
    'data': string;
    /**
     * The optional encoding of the score data. This property must match the encoding used for the `data` property.
     * @type {string}
     * @memberof ScoreRevisionCreation
     */
    'dataEncoding'?: ScoreRevisionCreationDataEncodingEnum;
    /**
     * Must be set to `true` if the revision was created automatically. 
     * @type {boolean}
     * @memberof ScoreRevisionCreation
     */
    'autosave'?: boolean;
    /**
     * A description associated to the revision
     * @type {string}
     * @memberof ScoreRevisionCreation
     */
    'description'?: string;
}

export const ScoreRevisionCreationDataEncodingEnum = {
    Base64: 'base64'
} as const;

export type ScoreRevisionCreationDataEncodingEnum = typeof ScoreRevisionCreationDataEncodingEnum[keyof typeof ScoreRevisionCreationDataEncodingEnum];

/**
 * The statistics related to the score revision (additions and deletions) 
 * @export
 * @interface ScoreRevisionStatistics
 */
export interface ScoreRevisionStatistics {
    /**
     * The number of additions operations in the last revision
     * @type {number}
     * @memberof ScoreRevisionStatistics
     */
    'additions'?: number;
    /**
     * The number of deletions operations in the last revision
     * @type {number}
     * @memberof ScoreRevisionStatistics
     */
    'deletions'?: number;
    /**
     * The date of the first action included in this revision
     * @type {string}
     * @memberof ScoreRevisionStatistics
     */
    'startDate'?: string;
    /**
     * The date of the latest action included in this revision
     * @type {string}
     * @memberof ScoreRevisionStatistics
     */
    'endDate'?: string;
}
/**
 * 
 * @export
 * @interface ScoreSource
 */
export interface ScoreSource {
    /**
     * If the score is a file on Google Drive, this field property must contain its identifier. To use this method, the Drive file must be public or the Flat Drive App must have access to the file. 
     * @type {string}
     * @memberof ScoreSource
     */
    'googleDrive'?: string;
}
/**
 * An audio track for a score
 * @export
 * @interface ScoreTrack
 */
export interface ScoreTrack {
    /**
     * The unique identifier of the score track
     * @type {string}
     * @memberof ScoreTrack
     */
    'id': string;
    /**
     * Title of the track
     * @type {string}
     * @memberof ScoreTrack
     */
    'title'?: string;
    /**
     * The unique identifier of the score
     * @type {string}
     * @memberof ScoreTrack
     */
    'score': string;
    /**
     * The unique identifier of the track creator
     * @type {string}
     * @memberof ScoreTrack
     */
    'creator': string;
    /**
     * The creation date of the track
     * @type {string}
     * @memberof ScoreTrack
     */
    'creationDate': string;
    /**
     * The modification date of the track
     * @type {string}
     * @memberof ScoreTrack
     */
    'modificationDate': string;
    /**
     * True if the track should be used as default audio source
     * @type {boolean}
     * @memberof ScoreTrack
     */
    'default': boolean;
    /**
     * 
     * @type {ScoreTrackState}
     * @memberof ScoreTrack
     */
    'state': ScoreTrackState;
    /**
     * 
     * @type {ScoreTrackType}
     * @memberof ScoreTrack
     */
    'type': ScoreTrackType;
    /**
     * 
     * @type {ScoreTrackPurpose}
     * @memberof ScoreTrack
     */
    'purpose': ScoreTrackPurpose;
    /**
     * The URL of the track
     * @type {string}
     * @memberof ScoreTrack
     */
    'url'?: string;
    /**
     * The unique identifier of the track when hosted on an external service. For example, if the url is `https://www.youtube.com/watch?v=dQw4w9WgXcQ`, `mediaId` will be `dQw4w9WgXcQ` 
     * @type {string}
     * @memberof ScoreTrack
     */
    'mediaId'?: string;
    /**
     * 
     * @type {Array<ScoreTrackPoint>}
     * @memberof ScoreTrack
     */
    'synchronizationPoints'?: Array<ScoreTrackPoint>;
}


/**
 * Creation of a new track. This one must contain the URL of the track or the corresponding file 
 * @export
 * @interface ScoreTrackCreation
 */
export interface ScoreTrackCreation {
    /**
     * Title of the track
     * @type {string}
     * @memberof ScoreTrackCreation
     */
    'title'?: string;
    /**
     * True if the track should be used as default audio source
     * @type {boolean}
     * @memberof ScoreTrackCreation
     */
    'default'?: boolean;
    /**
     * 
     * @type {ScoreTrackState}
     * @memberof ScoreTrackCreation
     */
    'state'?: ScoreTrackState;
    /**
     * 
     * @type {ScoreTrackPurpose}
     * @memberof ScoreTrackCreation
     */
    'purpose'?: ScoreTrackPurpose;
    /**
     * The URL of the track
     * @type {string}
     * @memberof ScoreTrackCreation
     */
    'url'?: string;
    /**
     * 
     * @type {Array<ScoreTrackPoint>}
     * @memberof ScoreTrackCreation
     */
    'synchronizationPoints'?: Array<ScoreTrackPoint>;
}


/**
 * A track synchronization point
 * @export
 * @interface ScoreTrackPoint
 */
export interface ScoreTrackPoint {
    /**
     * The type of the synchronization point. If the type is `measure`, the measure uuid must be present in `measureUuid`
     * @type {string}
     * @memberof ScoreTrackPoint
     */
    'type': ScoreTrackPointTypeEnum;
    /**
     * The measure unique identifier
     * @type {string}
     * @memberof ScoreTrackPoint
     */
    'measureUuid'?: string;
    /**
     * The corresponding time in seconds
     * @type {number}
     * @memberof ScoreTrackPoint
     */
    'time': number;
}

export const ScoreTrackPointTypeEnum = {
    Measure: 'measure',
    End: 'end'
} as const;

export type ScoreTrackPointTypeEnum = typeof ScoreTrackPointTypeEnum[keyof typeof ScoreTrackPointTypeEnum];

/**
 * The purpose of the audio track
 * @export
 * @enum {string}
 */

export const ScoreTrackPurpose = {
    Common: 'common',
    PerformanceSubmission: 'performanceSubmission'
} as const;

export type ScoreTrackPurpose = typeof ScoreTrackPurpose[keyof typeof ScoreTrackPurpose];


/**
 * State of the track
 * @export
 * @enum {string}
 */

export const ScoreTrackState = {
    Draft: 'draft',
    Completed: 'completed',
    Deleted: 'deleted'
} as const;

export type ScoreTrackState = typeof ScoreTrackState[keyof typeof ScoreTrackState];


/**
 * The type of an audio track
 * @export
 * @enum {string}
 */

export const ScoreTrackType = {
    Audio: 'audio',
    Soundcloud: 'soundcloud',
    Youtube: 'youtube',
    Vimeo: 'vimeo'
} as const;

export type ScoreTrackType = typeof ScoreTrackType[keyof typeof ScoreTrackType];


/**
 * Update an existing track. 
 * @export
 * @interface ScoreTrackUpdate
 */
export interface ScoreTrackUpdate {
    /**
     * Title of the track
     * @type {string}
     * @memberof ScoreTrackUpdate
     */
    'title'?: string;
    /**
     * True if the track should be used as default audio source
     * @type {boolean}
     * @memberof ScoreTrackUpdate
     */
    'default'?: boolean;
    /**
     * 
     * @type {ScoreTrackState}
     * @memberof ScoreTrackUpdate
     */
    'state'?: ScoreTrackState;
    /**
     * 
     * @type {Array<ScoreTrackPoint>}
     * @memberof ScoreTrackUpdate
     */
    'synchronizationPoints'?: Array<ScoreTrackPoint>;
}


/**
 * A computed version of the total, weekly, and monthly number of views of the score 
 * @export
 * @interface ScoreViewsCounts
 */
export interface ScoreViewsCounts {
    /**
     * The total number of views of the score
     * @type {number}
     * @memberof ScoreViewsCounts
     */
    'total'?: number;
    /**
     * The weekly number of views of the score
     * @type {number}
     * @memberof ScoreViewsCounts
     */
    'weekly'?: number;
    /**
     * The monthly number of views of the score
     * @type {number}
     * @memberof ScoreViewsCounts
     */
    'monthly'?: number;
}
/**
 * An asynchronous task
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * Unique identifier of the task
     * @type {string}
     * @memberof Task
     */
    'id': string;
    /**
     * Type of the task (e.g. audio-export)
     * @type {string}
     * @memberof Task
     */
    'type'?: string;
    /**
     * State of the Task
     * @type {string}
     * @memberof Task
     */
    'state': TaskStateEnum;
    /**
     * For files processing, the file format (e.g. `mp3`, `wav`)
     * @type {string}
     * @memberof Task
     */
    'format'?: string;
    /**
     * The score unique identifier for tasks related to scores
     * @type {string}
     * @memberof Task
     */
    'score'?: string;
    /**
     * 
     * @type {TaskProgress}
     * @memberof Task
     */
    'progress'?: TaskProgress;
    /**
     * The creation date of the task
     * @type {string}
     * @memberof Task
     */
    'creationDate'?: string;
    /**
     * The last modification date of the task
     * @type {string}
     * @memberof Task
     */
    'modificationDate'?: string;
    /**
     * The date when the task has been completed
     * @type {string}
     * @memberof Task
     */
    'doneDate'?: string;
    /**
     * 
     * @type {TaskResult}
     * @memberof Task
     */
    'result'?: TaskResult;
    /**
     * If any errors happened when processing this task, the list of errors identifiers
     * @type {Array<string>}
     * @memberof Task
     */
    'errorHistory'?: Array<string>;
}

export const TaskStateEnum = {
    Created: 'created',
    Doing: 'doing',
    Done: 'done',
    Canceled: 'canceled',
    Error: 'error'
} as const;

export type TaskStateEnum = typeof TaskStateEnum[keyof typeof TaskStateEnum];

/**
 * Options for the requested export 
 * @export
 * @interface TaskExportOptions
 */
export interface TaskExportOptions {
    /**
     * A list of parts to specifically export
     * @type {Array<string>}
     * @memberof TaskExportOptions
     */
    'parts'?: Array<string>;
}
/**
 * Details about the task progression
 * @export
 * @interface TaskProgress
 */
export interface TaskProgress {
    /**
     * Percent of the task progression
     * @type {number}
     * @memberof TaskProgress
     */
    'percent'?: number;
    /**
     * Text details of the task progress
     * @type {string}
     * @memberof TaskProgress
     */
    'text'?: string;
}
/**
 * Optional result information about this task
 * @export
 * @interface TaskResult
 */
export interface TaskResult {
    /**
     * URL returned by the task worker
     * @type {string}
     * @memberof TaskResult
     */
    'url'?: string;
    /**
     * Error returned by task worker
     * @type {string}
     * @memberof TaskResult
     */
    'error'?: string;
}
/**
 * The Tutteo product used by the user account
 * @export
 * @enum {string}
 */

export const TutteoProduct = {
    Flat: 'flat',
    FlatEdu: 'flatEdu',
    Msnippet: 'msnippet',
    Embed: 'embed'
} as const;

export type TutteoProduct = typeof TutteoProduct[keyof typeof TutteoProduct];


/**
 * User update as an organization admin
 * @export
 * @interface UserAdminUpdate
 */
export interface UserAdminUpdate {
    /**
     * Password of the account
     * @type {string}
     * @memberof UserAdminUpdate
     */
    'password'?: string;
    /**
     * 
     * @type {OrganizationRoles}
     * @memberof UserAdminUpdate
     */
    'organizationRole'?: OrganizationRoles;
    /**
     * Username of the account
     * @type {string}
     * @memberof UserAdminUpdate
     */
    'username'?: string;
    /**
     * First name of the user
     * @type {string}
     * @memberof UserAdminUpdate
     */
    'firstname'?: string;
    /**
     * Last name of the user
     * @type {string}
     * @memberof UserAdminUpdate
     */
    'lastname'?: string;
    /**
     * Email of the account
     * @type {string}
     * @memberof UserAdminUpdate
     */
    'email'?: string;
}


/**
 * 
 * @export
 * @interface UserAzureDetails
 */
export interface UserAzureDetails {
    /**
     * User object identifier on Azure AD
     * @type {string}
     * @memberof UserAzureDetails
     */
    'oid'?: string;
    /**
     * User tenant (domain name)
     * @type {string}
     * @memberof UserAzureDetails
     */
    'hd'?: string;
    /**
     * User Preferred Username (UPN), i.e. the main email of the user
     * @type {string}
     * @memberof UserAzureDetails
     */
    'preferredUsername'?: string;
}
/**
 * Social networks links
 * @export
 * @interface UserCommunityProfileLinks
 */
export interface UserCommunityProfileLinks {
    /**
     * Spotify Profile URL
     * @type {string}
     * @memberof UserCommunityProfileLinks
     */
    'spotifyUrl'?: string | null;
    /**
     * YouTube channel URL
     * @type {string}
     * @memberof UserCommunityProfileLinks
     */
    'youtubeUrl'?: string | null;
    /**
     * SoundCloud Profile URL
     * @type {string}
     * @memberof UserCommunityProfileLinks
     */
    'soundcloudUrl'?: string | null;
    /**
     * TikTok profile URL. For updates, also accepts TikTok usernames
     * @type {string}
     * @memberof UserCommunityProfileLinks
     */
    'tiktokUrl'?: string | null;
    /**
     * Instagram profile URL. For updates, also accepts Instagram usernames
     * @type {string}
     * @memberof UserCommunityProfileLinks
     */
    'instagramUrl'?: string | null;
    /**
     * Personnal website URL
     * @type {string}
     * @memberof UserCommunityProfileLinks
     */
    'websiteUrl'?: string | null;
}
/**
 * User creation
 * @export
 * @interface UserCreation
 */
export interface UserCreation {
    /**
     * Username of the new account
     * @type {string}
     * @memberof UserCreation
     */
    'username': string;
    /**
     * First name of the user
     * @type {string}
     * @memberof UserCreation
     */
    'firstname'?: string;
    /**
     * Last name of the user
     * @type {string}
     * @memberof UserCreation
     */
    'lastname'?: string;
    /**
     * Email of the new account
     * @type {string}
     * @memberof UserCreation
     */
    'email'?: string;
    /**
     * Password of the new account
     * @type {string}
     * @memberof UserCreation
     */
    'password': string;
    /**
     * 
     * @type {FlatLocales}
     * @memberof UserCreation
     */
    'locale'?: FlatLocales;
    /**
     * Role of the new account
     * @type {string}
     * @memberof UserCreation
     */
    'role'?: UserCreationRoleEnum;
}

export const UserCreationRoleEnum = {
    User: 'user',
    Teacher: 'teacher',
    Admin: 'admin'
} as const;

export type UserCreationRoleEnum = typeof UserCreationRoleEnum[keyof typeof UserCreationRoleEnum];

/**
 * 
 * @export
 * @interface UserDetails
 */
export interface UserDetails {
    /**
     * The user unique identifier
     * @type {string}
     * @memberof UserDetails
     */
    'id': string;
    /**
     * The type of user account
     * @type {string}
     * @memberof UserDetails
     */
    'type': UserDetailsTypeEnum;
    /**
     * 
     * @type {TutteoProduct}
     * @memberof UserDetails
     */
    'product': TutteoProduct;
    /**
     * The user name (unique for the organization)
     * @type {string}
     * @memberof UserDetails
     */
    'username': string;
    /**
     * The name that can be directly printed (name, firstname & lastname, or username)
     * @type {string}
     * @memberof UserDetails
     */
    'printableName'?: string;
    /**
     * Firstname of the user (for education users)
     * @type {string}
     * @memberof UserDetails
     */
    'firstname'?: string;
    /**
     * Lastname of the user (for education users)
     * @type {string}
     * @memberof UserDetails
     */
    'lastname'?: string;
    /**
     * A displayable name for the user (for consumer users)
     * @type {string}
     * @memberof UserDetails
     */
    'name'?: string;
    /**
     * The URL of the picture to display
     * @type {string}
     * @memberof UserDetails
     */
    'picture': string | null;
    /**
     * List of badges for the user profile:  - `power` - `staff` - `composerOfTheMonth` - `ambassador` - `challenge` 
     * @type {Array<string>}
     * @memberof UserDetails
     */
    'badges'?: Array<string>;
    /**
     * Organization ID (for Edu users only)
     * @type {string}
     * @memberof UserDetails
     */
    'organization'?: string;
    /**
     * 
     * @type {OrganizationRoles}
     * @memberof UserDetails
     */
    'organizationRole'?: OrganizationRoles;
    /**
     * 
     * @type {ClassRoles}
     * @memberof UserDetails
     */
    'classRole'?: ClassRoles;
    /**
     * Link to user profile (for Indiv. users only)
     * @type {string}
     * @memberof UserDetails
     */
    'htmlUrl'?: string;
    /**
     * User\'s biography
     * @type {string}
     * @memberof UserDetails
     */
    'bio'?: string;
    /**
     * Date the user signed up
     * @type {string}
     * @memberof UserDetails
     */
    'registrationDate'?: string;
    /**
     * Number of the scores liked by the user
     * @type {number}
     * @memberof UserDetails
     */
    'likedScoresCount'?: number;
    /**
     * Number of followers the user have
     * @type {number}
     * @memberof UserDetails
     */
    'followersCount'?: number;
    /**
     * Number of people the user follow
     * @type {number}
     * @memberof UserDetails
     */
    'followingCount'?: number;
    /**
     * Number of public scores the user have
     * @type {number}
     * @memberof UserDetails
     */
    'ownedPublicScoresCount'?: number;
    /**
     * Cover picture (backgroud) for the profile
     * @type {string}
     * @memberof UserDetails
     */
    'coverPicture'?: string | null;
    /**
     * Theme (background) for the profile
     * @type {string}
     * @memberof UserDetails
     */
    'profileTheme'?: string;
    /**
     * An array of the instrument identifiers. The format of the strings is `{instrument-group}.{instrument-id}`. 
     * @type {Array<string>}
     * @memberof UserDetails
     */
    'instruments'?: Array<string>;
    /**
     * 
     * @type {UserCommunityProfileLinks}
     * @memberof UserDetails
     */
    'links'?: UserCommunityProfileLinks;
    /**
     * 
     * @type {UserAzureDetails}
     * @memberof UserDetails
     */
    'azureDetails'?: UserAzureDetails;
    /**
     * Tell either this user profile is private or not (individual accounts only)
     * @type {boolean}
     * @memberof UserDetails
     */
    'privateProfile'?: boolean;
    /**
     * 
     * @type {FlatLocales}
     * @memberof UserDetails
     */
    'locale'?: FlatLocales;
    /**
     * For Flat for Education accounts, list of Group identifiers the user is part of.
     * @type {Array<string>}
     * @memberof UserDetails
     */
    'groups'?: Array<string>;
    /**
     * The ID of the user profile picture
     * @type {string}
     * @memberof UserDetails
     */
    'pictureFile'?: string | null;
    /**
     * The ID of the user profile cover picture
     * @type {string}
     * @memberof UserDetails
     */
    'coverPictureFile'?: string | null;
}

export const UserDetailsTypeEnum = {
    User: 'user',
    Guest: 'guest'
} as const;

export type UserDetailsTypeEnum = typeof UserDetailsTypeEnum[keyof typeof UserDetailsTypeEnum];

/**
 * 
 * @export
 * @interface UserDetailsAdmin
 */
export interface UserDetailsAdmin {
    /**
     * The user unique identifier
     * @type {string}
     * @memberof UserDetailsAdmin
     */
    'id': string;
    /**
     * The type of user account
     * @type {string}
     * @memberof UserDetailsAdmin
     */
    'type': UserDetailsAdminTypeEnum;
    /**
     * 
     * @type {TutteoProduct}
     * @memberof UserDetailsAdmin
     */
    'product': TutteoProduct;
    /**
     * The user name (unique for the organization)
     * @type {string}
     * @memberof UserDetailsAdmin
     */
    'username': string;
    /**
     * The name that can be directly printed (name, firstname & lastname, or username)
     * @type {string}
     * @memberof UserDetailsAdmin
     */
    'printableName'?: string;
    /**
     * Firstname of the user (for education users)
     * @type {string}
     * @memberof UserDetailsAdmin
     */
    'firstname'?: string;
    /**
     * Lastname of the user (for education users)
     * @type {string}
     * @memberof UserDetailsAdmin
     */
    'lastname'?: string;
    /**
     * A displayable name for the user (for consumer users)
     * @type {string}
     * @memberof UserDetailsAdmin
     */
    'name'?: string;
    /**
     * The URL of the picture to display
     * @type {string}
     * @memberof UserDetailsAdmin
     */
    'picture': string | null;
    /**
     * List of badges for the user profile:  - `power` - `staff` - `composerOfTheMonth` - `ambassador` - `challenge` 
     * @type {Array<string>}
     * @memberof UserDetailsAdmin
     */
    'badges'?: Array<string>;
    /**
     * Organization ID (for Edu users only)
     * @type {string}
     * @memberof UserDetailsAdmin
     */
    'organization'?: string;
    /**
     * 
     * @type {OrganizationRoles}
     * @memberof UserDetailsAdmin
     */
    'organizationRole'?: OrganizationRoles;
    /**
     * 
     * @type {ClassRoles}
     * @memberof UserDetailsAdmin
     */
    'classRole'?: ClassRoles;
    /**
     * Link to user profile (for Indiv. users only)
     * @type {string}
     * @memberof UserDetailsAdmin
     */
    'htmlUrl'?: string;
    /**
     * Email of the user
     * @type {string}
     * @memberof UserDetailsAdmin
     */
    'email'?: string;
    /**
     * Date of the last user activity
     * @type {string}
     * @memberof UserDetailsAdmin
     */
    'lastActivityDate'?: string;
    /**
     * 
     * @type {UserDetailsAdminLicense}
     * @memberof UserDetailsAdmin
     */
    'license'?: UserDetailsAdminLicense;
    /**
     * For Flat for Education accounts, list of Group identifiers the user is part of.
     * @type {Array<string>}
     * @memberof UserDetailsAdmin
     */
    'groups'?: Array<string>;
}

export const UserDetailsAdminTypeEnum = {
    User: 'user',
    Guest: 'guest'
} as const;

export type UserDetailsAdminTypeEnum = typeof UserDetailsAdminTypeEnum[keyof typeof UserDetailsAdminTypeEnum];

/**
 * Current active license of the user
 * @export
 * @interface UserDetailsAdminLicense
 */
export interface UserDetailsAdminLicense {
    /**
     * ID of the current license
     * @type {string}
     * @memberof UserDetailsAdminLicense
     */
    'id'?: string;
    /**
     * Date when the license expires
     * @type {string}
     * @memberof UserDetailsAdminLicense
     */
    'expirationDate'?: string;
    /**
     * 
     * @type {LicenseSources}
     * @memberof UserDetailsAdminLicense
     */
    'source'?: LicenseSources;
    /**
     * 
     * @type {LicenseMode}
     * @memberof UserDetailsAdminLicense
     */
    'mode'?: LicenseMode;
    /**
     * ID of the current license
     * @type {boolean}
     * @memberof UserDetailsAdminLicense
     */
    'active'?: boolean;
}


/**
 * 
 * @export
 * @interface UserPublic
 */
export interface UserPublic {
    /**
     * The user unique identifier
     * @type {string}
     * @memberof UserPublic
     */
    'id': string;
    /**
     * The type of user account
     * @type {string}
     * @memberof UserPublic
     */
    'type': UserPublicTypeEnum;
    /**
     * 
     * @type {TutteoProduct}
     * @memberof UserPublic
     */
    'product': TutteoProduct;
    /**
     * The user name (unique for the organization)
     * @type {string}
     * @memberof UserPublic
     */
    'username': string;
    /**
     * The name that can be directly printed (name, firstname & lastname, or username)
     * @type {string}
     * @memberof UserPublic
     */
    'printableName'?: string;
    /**
     * Firstname of the user (for education users)
     * @type {string}
     * @memberof UserPublic
     */
    'firstname'?: string;
    /**
     * Lastname of the user (for education users)
     * @type {string}
     * @memberof UserPublic
     */
    'lastname'?: string;
    /**
     * A displayable name for the user (for consumer users)
     * @type {string}
     * @memberof UserPublic
     */
    'name'?: string;
    /**
     * The URL of the picture to display
     * @type {string}
     * @memberof UserPublic
     */
    'picture': string | null;
    /**
     * List of badges for the user profile:  - `power` - `staff` - `composerOfTheMonth` - `ambassador` - `challenge` 
     * @type {Array<string>}
     * @memberof UserPublic
     */
    'badges'?: Array<string>;
    /**
     * Organization ID (for Edu users only)
     * @type {string}
     * @memberof UserPublic
     */
    'organization'?: string;
    /**
     * 
     * @type {OrganizationRoles}
     * @memberof UserPublic
     */
    'organizationRole'?: OrganizationRoles;
    /**
     * 
     * @type {ClassRoles}
     * @memberof UserPublic
     */
    'classRole'?: ClassRoles;
    /**
     * Link to user profile (for Indiv. users only)
     * @type {string}
     * @memberof UserPublic
     */
    'htmlUrl'?: string;
    /**
     * User\'s biography
     * @type {string}
     * @memberof UserPublic
     */
    'bio'?: string;
    /**
     * Date the user signed up
     * @type {string}
     * @memberof UserPublic
     */
    'registrationDate'?: string;
    /**
     * Number of the scores liked by the user
     * @type {number}
     * @memberof UserPublic
     */
    'likedScoresCount'?: number;
    /**
     * Number of followers the user have
     * @type {number}
     * @memberof UserPublic
     */
    'followersCount'?: number;
    /**
     * Number of people the user follow
     * @type {number}
     * @memberof UserPublic
     */
    'followingCount'?: number;
    /**
     * Number of public scores the user have
     * @type {number}
     * @memberof UserPublic
     */
    'ownedPublicScoresCount'?: number;
    /**
     * Cover picture (backgroud) for the profile
     * @type {string}
     * @memberof UserPublic
     */
    'coverPicture'?: string | null;
    /**
     * Theme (background) for the profile
     * @type {string}
     * @memberof UserPublic
     */
    'profileTheme'?: string;
    /**
     * An array of the instrument identifiers. The format of the strings is `{instrument-group}.{instrument-id}`. 
     * @type {Array<string>}
     * @memberof UserPublic
     */
    'instruments'?: Array<string>;
    /**
     * 
     * @type {UserCommunityProfileLinks}
     * @memberof UserPublic
     */
    'links'?: UserCommunityProfileLinks;
}

export const UserPublicTypeEnum = {
    User: 'user',
    Guest: 'guest'
} as const;

export type UserPublicTypeEnum = typeof UserPublicTypeEnum[keyof typeof UserPublicTypeEnum];

/**
 * 
 * @export
 * @interface UserPublicSummary
 */
export interface UserPublicSummary {
    /**
     * The user unique identifier
     * @type {string}
     * @memberof UserPublicSummary
     */
    'id': string;
    /**
     * The type of user account
     * @type {string}
     * @memberof UserPublicSummary
     */
    'type': UserPublicSummaryTypeEnum;
    /**
     * 
     * @type {TutteoProduct}
     * @memberof UserPublicSummary
     */
    'product': TutteoProduct;
    /**
     * The user name (unique for the organization)
     * @type {string}
     * @memberof UserPublicSummary
     */
    'username': string;
    /**
     * The name that can be directly printed (name, firstname & lastname, or username)
     * @type {string}
     * @memberof UserPublicSummary
     */
    'printableName'?: string;
    /**
     * Firstname of the user (for education users)
     * @type {string}
     * @memberof UserPublicSummary
     */
    'firstname'?: string;
    /**
     * Lastname of the user (for education users)
     * @type {string}
     * @memberof UserPublicSummary
     */
    'lastname'?: string;
    /**
     * A displayable name for the user (for consumer users)
     * @type {string}
     * @memberof UserPublicSummary
     */
    'name'?: string;
    /**
     * The URL of the picture to display
     * @type {string}
     * @memberof UserPublicSummary
     */
    'picture': string | null;
    /**
     * List of badges for the user profile:  - `power` - `staff` - `composerOfTheMonth` - `ambassador` - `challenge` 
     * @type {Array<string>}
     * @memberof UserPublicSummary
     */
    'badges'?: Array<string>;
    /**
     * Organization ID (for Edu users only)
     * @type {string}
     * @memberof UserPublicSummary
     */
    'organization'?: string;
    /**
     * 
     * @type {OrganizationRoles}
     * @memberof UserPublicSummary
     */
    'organizationRole'?: OrganizationRoles;
    /**
     * 
     * @type {ClassRoles}
     * @memberof UserPublicSummary
     */
    'classRole'?: ClassRoles;
    /**
     * Link to user profile (for Indiv. users only)
     * @type {string}
     * @memberof UserPublicSummary
     */
    'htmlUrl'?: string;
}

export const UserPublicSummaryTypeEnum = {
    User: 'user',
    Guest: 'guest'
} as const;

export type UserPublicSummaryTypeEnum = typeof UserPublicSummaryTypeEnum[keyof typeof UserPublicSummaryTypeEnum];

/**
 * 
 * @export
 * @interface UserSigninLink
 */
export interface UserSigninLink {
    /**
     * URL to use to sign in to this account
     * @type {string}
     * @memberof UserSigninLink
     */
    'url'?: string;
    /**
     * Date when the link expires
     * @type {string}
     * @memberof UserSigninLink
     */
    'expirationDate'?: string;
}
/**
 * 
 * @export
 * @interface UserSigninLinkCreation
 */
export interface UserSigninLinkCreation {
    /**
     * Path to redirect to after signin
     * @type {string}
     * @memberof UserSigninLinkCreation
     */
    'destinationPath'?: string;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get details about the current authenticated User. 
         * @summary Get current user account
         * @param {boolean} [onlyId] Only return the user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticatedUser: async (onlyId?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["account.public_profile", "account.education_profile"], configuration)

            if (onlyId !== undefined) {
                localVarQueryParameter['onlyId'] = onlyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * Get details about the current authenticated User. 
         * @summary Get current user account
         * @param {boolean} [onlyId] Only return the user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthenticatedUser(onlyId?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthenticatedUser(onlyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.getAuthenticatedUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * Get details about the current authenticated User. 
         * @summary Get current user account
         * @param {boolean} [onlyId] Only return the user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticatedUser(onlyId?: boolean, options?: any): AxiosPromise<UserDetails> {
            return localVarFp.getAuthenticatedUser(onlyId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * Get details about the current authenticated User. 
     * @summary Get current user account
     * @param {boolean} [onlyId] Only return the user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAuthenticatedUser(onlyId?: boolean, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).getAuthenticatedUser(onlyId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClassApi - axios parameter creator
 * @export
 */
export const ClassApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Mark the class as `active`. This is mainly used for classes synchronized from Clever that are initially with an `inactive` state and hidden in the UI. 
         * @summary Activate the class
         * @param {string} _class Unique identifier of the class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateClass: async (_class: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('activateClass', '_class', _class)
            const localVarPath = `/classes/{class}/activate`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.classes"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method can be used by a teacher of the class to enroll another Flat user into the class.  Only users that are part of your Organization can be enrolled in a class of this same Organization.  When enrolling a user in the class, Flat will automatically add this user to the corresponding Class group, based on this role in the Organization. 
         * @summary Add a user to the class
         * @param {string} _class Unique identifier of the class
         * @param {string} user Unique identifier of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addClassUser: async (_class: string, user: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('addClassUser', '_class', _class)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('addClassUser', 'user', user)
            const localVarPath = `/classes/{class}/users/{user}`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.classes"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Archive the assignment 
         * @summary Archive the assignment
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveAssignment: async (_class: string, assignment: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('archiveAssignment', '_class', _class)
            // verify required parameter 'assignment' is not null or undefined
            assertParamExists('archiveAssignment', 'assignment', assignment)
            const localVarPath = `/classes/{class}/assignments/{assignment}/archive`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)))
                .replace(`{${"assignment"}}`, encodeURIComponent(String(assignment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.classes", "edu.assignments"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark the class as `archived`. When this course is synchronized with another app, like Google Classroom, this state will be automatically be updated. 
         * @summary Archive the class
         * @param {string} _class Unique identifier of the class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveClass: async (_class: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('archiveClass', '_class', _class)
            const localVarPath = `/classes/{class}/archive`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.classes"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Copy an assignment to a specified class or the resource library  For class assignments: - If the original assignment has a due date in the past, this new assignment will be created without a due date. - If the class is synchronized with an external app (e.g. Google Classroom), the copied assignment will also be posted on the external app. 
         * @summary Copy an assignment
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {AssignmentCopy} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyAssignment: async (_class: string, assignment: string, body: AssignmentCopy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('copyAssignment', '_class', _class)
            // verify required parameter 'assignment' is not null or undefined
            assertParamExists('copyAssignment', 'assignment', assignment)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('copyAssignment', 'body', body)
            const localVarPath = `/classes/{class}/assignments/{assignment}/copy`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)))
                .replace(`{${"assignment"}}`, encodeURIComponent(String(assignment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.classes", "edu.assignments"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Classrooms on Flat allow you to create activities with assignments and post content to a specific group.  When creating a class, Flat automatically creates two groups: one for the teachers of the course, one for the students. The creator of this class is automatically added to the teachers group.  If the classsroom is synchronized with another application like Google Classroom, some of the meta information will automatically be updated.  You can add users to this class using `PUT /classes/{class}/users/{user}`, they will automatically added to the group based on their role on Flat. Users can also enroll themselves to this class using `POST /classes/enroll/{enrollmentCode}` and the `enrollmentCode` returned in the `ClassDetails` response. 
         * @summary Create a new class
         * @param {ClassCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClass: async (body: ClassCreation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createClass', 'body', body)
            const localVarPath = `/classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.classes"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method as a teacher to create and post a new assignment to a class.  If the class is synchronized with Google Classroom, the assignment will be automatically posted to your Classroom course. 
         * @summary Assignment creation
         * @param {string} _class Unique identifier of the class
         * @param {ClassAssignmentUpdate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClassAssignment: async (_class: string, body: ClassAssignmentUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('createClassAssignment', '_class', _class)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createClassAssignment', 'body', body)
            const localVarPath = `/classes/{class}/assignments`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.classes", "edu.assignments"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method as a student to create, update and submit a submission related to an assignment. Students can only set `attachments` and `submit`. Teachers can use `PUT /classes/{class}/assignments/{assignment}/submissions/{submission}` to update a submission by id. 
         * @summary Create or edit a submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {AssignmentSubmissionUpdate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubmission: async (_class: string, assignment: string, body: AssignmentSubmissionUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('createSubmission', '_class', _class)
            // verify required parameter 'assignment' is not null or undefined
            assertParamExists('createSubmission', 'assignment', assignment)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createSubmission', 'body', body)
            const localVarPath = `/classes/{class}/assignments/{assignment}/submissions`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)))
                .replace(`{${"assignment"}}`, encodeURIComponent(String(assignment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.classes", "edu.assignments"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test students account can be created by teachers an admin and be used to experiment the assignments.  - They are automatically added to the class. - They can be reset using this API endpoint (a new account will be created and the previous one scheduled for deletion). - These accounts don\'t use a user license. 
         * @summary Create a test student account
         * @param {string} _class Unique identifier of the class
         * @param {boolean} [reset] If true, the testing account will be re-created. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTestStudentAccount: async (_class: string, reset?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('createTestStudentAccount', '_class', _class)
            const localVarPath = `/classes/{class}/testStudent`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.admin", "edu.classes"], configuration)

            if (reset !== undefined) {
                localVarQueryParameter['reset'] = reset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method can be used by a teacher to remove a user from the class, or by a student to leave the classroom.  Warning: Removing a user from the class will remove the associated resources, including the submissions and feedback related to these submissions. 
         * @summary Remove a user from the class
         * @param {string} _class Unique identifier of the class
         * @param {string} user Unique identifier of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClassUser: async (_class: string, user: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('deleteClassUser', '_class', _class)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('deleteClassUser', 'user', user)
            const localVarPath = `/classes/{class}/users/{user}`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.classes"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method as a teacher to reset a submission and allow student to start over the assignment 
         * @summary Reset a submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {string} submission Unique identifier of the submission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmission: async (_class: string, assignment: string, submission: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('deleteSubmission', '_class', _class)
            // verify required parameter 'assignment' is not null or undefined
            assertParamExists('deleteSubmission', 'assignment', assignment)
            // verify required parameter 'submission' is not null or undefined
            assertParamExists('deleteSubmission', 'submission', submission)
            const localVarPath = `/classes/{class}/assignments/{assignment}/submissions/{submission}`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)))
                .replace(`{${"assignment"}}`, encodeURIComponent(String(assignment)))
                .replace(`{${"submission"}}`, encodeURIComponent(String(submission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.classes", "edu.assignments"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a feedback comment to a submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {string} submission Unique identifier of the submission
         * @param {string} comment Unique identifier of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmissionComment: async (_class: string, assignment: string, submission: string, comment: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('deleteSubmissionComment', '_class', _class)
            // verify required parameter 'assignment' is not null or undefined
            assertParamExists('deleteSubmissionComment', 'assignment', assignment)
            // verify required parameter 'submission' is not null or undefined
            assertParamExists('deleteSubmissionComment', 'submission', submission)
            // verify required parameter 'comment' is not null or undefined
            assertParamExists('deleteSubmissionComment', 'comment', comment)
            const localVarPath = `/classes/{class}/assignments/{assignment}/submissions/{submission}/comments/{comment}`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)))
                .replace(`{${"assignment"}}`, encodeURIComponent(String(assignment)))
                .replace(`{${"submission"}}`, encodeURIComponent(String(submission)))
                .replace(`{${"comment"}}`, encodeURIComponent(String(comment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.assignments"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method as a teacher to update the different submission and give feedback. Teachers can only set `return`, `draftGrade` and `grade` 
         * @summary Edit a submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {string} submission Unique identifier of the submission
         * @param {AssignmentSubmissionUpdate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editSubmission: async (_class: string, assignment: string, submission: string, body: AssignmentSubmissionUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('editSubmission', '_class', _class)
            // verify required parameter 'assignment' is not null or undefined
            assertParamExists('editSubmission', 'assignment', assignment)
            // verify required parameter 'submission' is not null or undefined
            assertParamExists('editSubmission', 'submission', submission)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('editSubmission', 'body', body)
            const localVarPath = `/classes/{class}/assignments/{assignment}/submissions/{submission}`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)))
                .replace(`{${"assignment"}}`, encodeURIComponent(String(assignment)))
                .replace(`{${"submission"}}`, encodeURIComponent(String(submission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.classes", "edu.assignments"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to join a class using an enrollment code given one of the teacher of this class. This code is also available in the `ClassDetails` returned to the teachers when creating the class or listing / fetching a specific class.  Flat will automatically add the user to the corresponding class group based on this role in the organization. 
         * @summary Join a class
         * @param {string} enrollmentCode The enrollment code, available to the teacher in &#x60;ClassDetails&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollClass: async (enrollmentCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enrollmentCode' is not null or undefined
            assertParamExists('enrollClass', 'enrollmentCode', enrollmentCode)
            const localVarPath = `/classes/enroll/{enrollmentCode}`
                .replace(`{${"enrollmentCode"}}`, encodeURIComponent(String(enrollmentCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.classes"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export list of submissions grades to a CSV file
         * @summary CSV Grades exports
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportSubmissionsReviewsAsCsv: async (_class: string, assignment: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('exportSubmissionsReviewsAsCsv', '_class', _class)
            // verify required parameter 'assignment' is not null or undefined
            assertParamExists('exportSubmissionsReviewsAsCsv', 'assignment', assignment)
            const localVarPath = `/classes/{class}/assignments/{assignment}/submissions/csv`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)))
                .replace(`{${"assignment"}}`, encodeURIComponent(String(assignment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.classes", "edu.classes.readonly", "edu.assignments", "edu.assignments.readonly"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export list of submissions grades to an Excel file
         * @summary Excel Grades exports
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportSubmissionsReviewsAsExcel: async (_class: string, assignment: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('exportSubmissionsReviewsAsExcel', '_class', _class)
            // verify required parameter 'assignment' is not null or undefined
            assertParamExists('exportSubmissionsReviewsAsExcel', 'assignment', assignment)
            const localVarPath = `/classes/{class}/assignments/{assignment}/submissions/excel`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)))
                .replace(`{${"assignment"}}`, encodeURIComponent(String(assignment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.classes", "edu.classes.readonly", "edu.assignments", "edu.assignments.readonly"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a single class
         * @param {string} _class Unique identifier of the class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClass: async (_class: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('getClass', '_class', _class)
            const localVarPath = `/classes/{class}`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.classes", "edu.classes.readonly"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API call will list the different assignments submissions where the score is attached. This method can be used by anyone that are part of the organization and have at least read access to the document. 
         * @summary List submissions related to the score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoreSubmissions: async (score: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('getScoreSubmissions', 'score', score)
            const localVarPath = `/scores/{score}/submissions`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores", "scores.readonly"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a student submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {string} submission Unique identifier of the submission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmission: async (_class: string, assignment: string, submission: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('getSubmission', '_class', _class)
            // verify required parameter 'assignment' is not null or undefined
            assertParamExists('getSubmission', 'assignment', assignment)
            // verify required parameter 'submission' is not null or undefined
            assertParamExists('getSubmission', 'submission', submission)
            const localVarPath = `/classes/{class}/assignments/{assignment}/submissions/{submission}`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)))
                .replace(`{${"assignment"}}`, encodeURIComponent(String(assignment)))
                .replace(`{${"submission"}}`, encodeURIComponent(String(submission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.classes", "edu.classes.readonly", "edu.assignments", "edu.assignments.readonly"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the feedback comments of a submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {string} submission Unique identifier of the submission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissionComments: async (_class: string, assignment: string, submission: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('getSubmissionComments', '_class', _class)
            // verify required parameter 'assignment' is not null or undefined
            assertParamExists('getSubmissionComments', 'assignment', assignment)
            // verify required parameter 'submission' is not null or undefined
            assertParamExists('getSubmissionComments', 'submission', submission)
            const localVarPath = `/classes/{class}/assignments/{assignment}/submissions/{submission}/comments`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)))
                .replace(`{${"assignment"}}`, encodeURIComponent(String(assignment)))
                .replace(`{${"submission"}}`, encodeURIComponent(String(submission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.assignments", "edu.assignments.readonly"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For teachers only. Returns a detailed history of the submission. This currently includes state and grade histories. 
         * @summary Get the history of the submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {string} submission Unique identifier of the submission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissionHistory: async (_class: string, assignment: string, submission: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('getSubmissionHistory', '_class', _class)
            // verify required parameter 'assignment' is not null or undefined
            assertParamExists('getSubmissionHistory', 'assignment', assignment)
            // verify required parameter 'submission' is not null or undefined
            assertParamExists('getSubmissionHistory', 'submission', submission)
            const localVarPath = `/classes/{class}/assignments/{assignment}/submissions/{submission}/history`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)))
                .replace(`{${"assignment"}}`, encodeURIComponent(String(assignment)))
                .replace(`{${"submission"}}`, encodeURIComponent(String(submission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.assignments", "edu.assignments.readonly"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the students\' submissions
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissions: async (_class: string, assignment: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('getSubmissions', '_class', _class)
            // verify required parameter 'assignment' is not null or undefined
            assertParamExists('getSubmissions', 'assignment', assignment)
            const localVarPath = `/classes/{class}/assignments/{assignment}/submissions`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)))
                .replace(`{${"assignment"}}`, encodeURIComponent(String(assignment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.classes", "edu.classes.readonly", "edu.assignments", "edu.assignments.readonly"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Assignments listing
         * @param {string} _class Unique identifier of the class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAssignments: async (_class: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('listAssignments', '_class', _class)
            const localVarPath = `/classes/{class}/assignments`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.classes", "edu.classes.readonly", "edu.assignments", "edu.assignments.readonly"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method as a teacher to list all the assignment submissions sent by a student of the class 
         * @summary List the submissions for a student
         * @param {string} _class Unique identifier of the class
         * @param {string} user Unique identifier of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClassStudentSubmissions: async (_class: string, user: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('listClassStudentSubmissions', '_class', _class)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('listClassStudentSubmissions', 'user', user)
            const localVarPath = `/classes/{class}/students/{user}/submissions`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.classes", "edu.classes.readonly", "edu.assignments", "edu.assignments.readonly"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the classes available for the current user
         * @param {ListClassesStateEnum} [state] Filter the classes by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClasses: async (state?: ListClassesStateEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.classes", "edu.classes.readonly"], configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a feedback comment to a submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {string} submission Unique identifier of the submission
         * @param {AssignmentSubmissionCommentCreation} assignmentSubmissionCommentCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmissionComment: async (_class: string, assignment: string, submission: string, assignmentSubmissionCommentCreation: AssignmentSubmissionCommentCreation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('postSubmissionComment', '_class', _class)
            // verify required parameter 'assignment' is not null or undefined
            assertParamExists('postSubmissionComment', 'assignment', assignment)
            // verify required parameter 'submission' is not null or undefined
            assertParamExists('postSubmissionComment', 'submission', submission)
            // verify required parameter 'assignmentSubmissionCommentCreation' is not null or undefined
            assertParamExists('postSubmissionComment', 'assignmentSubmissionCommentCreation', assignmentSubmissionCommentCreation)
            const localVarPath = `/classes/{class}/assignments/{assignment}/submissions/{submission}/comments`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)))
                .replace(`{${"assignment"}}`, encodeURIComponent(String(assignment)))
                .replace(`{${"submission"}}`, encodeURIComponent(String(submission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.assignments"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignmentSubmissionCommentCreation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark the assignment as `active`. 
         * @summary Unarchive the assignment.
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveAssignment: async (_class: string, assignment: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('unarchiveAssignment', '_class', _class)
            // verify required parameter 'assignment' is not null or undefined
            assertParamExists('unarchiveAssignment', 'assignment', assignment)
            const localVarPath = `/classes/{class}/assignments/{assignment}/archive`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)))
                .replace(`{${"assignment"}}`, encodeURIComponent(String(assignment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.classes", "edu.assignments"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark the class as `active`. When this course is synchronized with another app, like Google Classroom, this state will be automatically be updated. 
         * @summary Unarchive the class
         * @param {string} _class Unique identifier of the class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveClass: async (_class: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('unarchiveClass', '_class', _class)
            const localVarPath = `/classes/{class}/archive`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.classes"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the meta information of the class 
         * @summary Update the class
         * @param {string} _class Unique identifier of the class
         * @param {ClassUpdate} body Details of the Class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClass: async (_class: string, body: ClassUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('updateClass', '_class', _class)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateClass', 'body', body)
            const localVarPath = `/classes/{class}`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.classes"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a feedback comment to a submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {string} submission Unique identifier of the submission
         * @param {string} comment Unique identifier of the comment
         * @param {AssignmentSubmissionCommentCreation} assignmentSubmissionCommentCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubmissionComment: async (_class: string, assignment: string, submission: string, comment: string, assignmentSubmissionCommentCreation: AssignmentSubmissionCommentCreation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('updateSubmissionComment', '_class', _class)
            // verify required parameter 'assignment' is not null or undefined
            assertParamExists('updateSubmissionComment', 'assignment', assignment)
            // verify required parameter 'submission' is not null or undefined
            assertParamExists('updateSubmissionComment', 'submission', submission)
            // verify required parameter 'comment' is not null or undefined
            assertParamExists('updateSubmissionComment', 'comment', comment)
            // verify required parameter 'assignmentSubmissionCommentCreation' is not null or undefined
            assertParamExists('updateSubmissionComment', 'assignmentSubmissionCommentCreation', assignmentSubmissionCommentCreation)
            const localVarPath = `/classes/{class}/assignments/{assignment}/submissions/{submission}/comments/{comment}`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)))
                .replace(`{${"assignment"}}`, encodeURIComponent(String(assignment)))
                .replace(`{${"submission"}}`, encodeURIComponent(String(submission)))
                .replace(`{${"comment"}}`, encodeURIComponent(String(comment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.assignments"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignmentSubmissionCommentCreation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClassApi - functional programming interface
 * @export
 */
export const ClassApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClassApiAxiosParamCreator(configuration)
    return {
        /**
         * Mark the class as `active`. This is mainly used for classes synchronized from Clever that are initially with an `inactive` state and hidden in the UI. 
         * @summary Activate the class
         * @param {string} _class Unique identifier of the class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateClass(_class: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateClass(_class, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.activateClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method can be used by a teacher of the class to enroll another Flat user into the class.  Only users that are part of your Organization can be enrolled in a class of this same Organization.  When enrolling a user in the class, Flat will automatically add this user to the corresponding Class group, based on this role in the Organization. 
         * @summary Add a user to the class
         * @param {string} _class Unique identifier of the class
         * @param {string} user Unique identifier of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addClassUser(_class: string, user: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addClassUser(_class, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.addClassUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Archive the assignment 
         * @summary Archive the assignment
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveAssignment(_class: string, assignment: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Assignment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveAssignment(_class, assignment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.archiveAssignment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Mark the class as `archived`. When this course is synchronized with another app, like Google Classroom, this state will be automatically be updated. 
         * @summary Archive the class
         * @param {string} _class Unique identifier of the class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveClass(_class: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveClass(_class, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.archiveClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Copy an assignment to a specified class or the resource library  For class assignments: - If the original assignment has a due date in the past, this new assignment will be created without a due date. - If the class is synchronized with an external app (e.g. Google Classroom), the copied assignment will also be posted on the external app. 
         * @summary Copy an assignment
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {AssignmentCopy} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyAssignment(_class: string, assignment: string, body: AssignmentCopy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssignmentCopyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.copyAssignment(_class, assignment, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.copyAssignment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Classrooms on Flat allow you to create activities with assignments and post content to a specific group.  When creating a class, Flat automatically creates two groups: one for the teachers of the course, one for the students. The creator of this class is automatically added to the teachers group.  If the classsroom is synchronized with another application like Google Classroom, some of the meta information will automatically be updated.  You can add users to this class using `PUT /classes/{class}/users/{user}`, they will automatically added to the group based on their role on Flat. Users can also enroll themselves to this class using `POST /classes/enroll/{enrollmentCode}` and the `enrollmentCode` returned in the `ClassDetails` response. 
         * @summary Create a new class
         * @param {ClassCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createClass(body: ClassCreation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createClass(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.createClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this method as a teacher to create and post a new assignment to a class.  If the class is synchronized with Google Classroom, the assignment will be automatically posted to your Classroom course. 
         * @summary Assignment creation
         * @param {string} _class Unique identifier of the class
         * @param {ClassAssignmentUpdate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createClassAssignment(_class: string, body: ClassAssignmentUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Assignment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createClassAssignment(_class, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.createClassAssignment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this method as a student to create, update and submit a submission related to an assignment. Students can only set `attachments` and `submit`. Teachers can use `PUT /classes/{class}/assignments/{assignment}/submissions/{submission}` to update a submission by id. 
         * @summary Create or edit a submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {AssignmentSubmissionUpdate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubmission(_class: string, assignment: string, body: AssignmentSubmissionUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssignmentSubmission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubmission(_class, assignment, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.createSubmission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test students account can be created by teachers an admin and be used to experiment the assignments.  - They are automatically added to the class. - They can be reset using this API endpoint (a new account will be created and the previous one scheduled for deletion). - These accounts don\'t use a user license. 
         * @summary Create a test student account
         * @param {string} _class Unique identifier of the class
         * @param {boolean} [reset] If true, the testing account will be re-created. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTestStudentAccount(_class: string, reset?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTestStudentAccount(_class, reset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.createTestStudentAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method can be used by a teacher to remove a user from the class, or by a student to leave the classroom.  Warning: Removing a user from the class will remove the associated resources, including the submissions and feedback related to these submissions. 
         * @summary Remove a user from the class
         * @param {string} _class Unique identifier of the class
         * @param {string} user Unique identifier of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteClassUser(_class: string, user: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteClassUser(_class, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.deleteClassUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this method as a teacher to reset a submission and allow student to start over the assignment 
         * @summary Reset a submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {string} submission Unique identifier of the submission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSubmission(_class: string, assignment: string, submission: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssignmentSubmission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSubmission(_class, assignment, submission, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.deleteSubmission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a feedback comment to a submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {string} submission Unique identifier of the submission
         * @param {string} comment Unique identifier of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSubmissionComment(_class: string, assignment: string, submission: string, comment: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSubmissionComment(_class, assignment, submission, comment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.deleteSubmissionComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this method as a teacher to update the different submission and give feedback. Teachers can only set `return`, `draftGrade` and `grade` 
         * @summary Edit a submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {string} submission Unique identifier of the submission
         * @param {AssignmentSubmissionUpdate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editSubmission(_class: string, assignment: string, submission: string, body: AssignmentSubmissionUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssignmentSubmission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editSubmission(_class, assignment, submission, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.editSubmission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this method to join a class using an enrollment code given one of the teacher of this class. This code is also available in the `ClassDetails` returned to the teachers when creating the class or listing / fetching a specific class.  Flat will automatically add the user to the corresponding class group based on this role in the organization. 
         * @summary Join a class
         * @param {string} enrollmentCode The enrollment code, available to the teacher in &#x60;ClassDetails&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enrollClass(enrollmentCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enrollClass(enrollmentCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.enrollClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Export list of submissions grades to a CSV file
         * @summary CSV Grades exports
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportSubmissionsReviewsAsCsv(_class: string, assignment: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportSubmissionsReviewsAsCsv(_class, assignment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.exportSubmissionsReviewsAsCsv']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Export list of submissions grades to an Excel file
         * @summary Excel Grades exports
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportSubmissionsReviewsAsExcel(_class: string, assignment: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportSubmissionsReviewsAsExcel(_class, assignment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.exportSubmissionsReviewsAsExcel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of a single class
         * @param {string} _class Unique identifier of the class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClass(_class: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClass(_class, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.getClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API call will list the different assignments submissions where the score is attached. This method can be used by anyone that are part of the organization and have at least read access to the document. 
         * @summary List submissions related to the score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScoreSubmissions(score: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssignmentSubmission>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScoreSubmissions(score, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.getScoreSubmissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a student submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {string} submission Unique identifier of the submission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubmission(_class: string, assignment: string, submission: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssignmentSubmission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubmission(_class, assignment, submission, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.getSubmission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List the feedback comments of a submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {string} submission Unique identifier of the submission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubmissionComments(_class: string, assignment: string, submission: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssignmentSubmissionComment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubmissionComments(_class, assignment, submission, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.getSubmissionComments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * For teachers only. Returns a detailed history of the submission. This currently includes state and grade histories. 
         * @summary Get the history of the submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {string} submission Unique identifier of the submission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubmissionHistory(_class: string, assignment: string, submission: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssignmentSubmissionHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubmissionHistory(_class, assignment, submission, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.getSubmissionHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List the students\' submissions
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubmissions(_class: string, assignment: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssignmentSubmission>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubmissions(_class, assignment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.getSubmissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Assignments listing
         * @param {string} _class Unique identifier of the class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAssignments(_class: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClassAssignment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAssignments(_class, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.listAssignments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this method as a teacher to list all the assignment submissions sent by a student of the class 
         * @summary List the submissions for a student
         * @param {string} _class Unique identifier of the class
         * @param {string} user Unique identifier of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClassStudentSubmissions(_class: string, user: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssignmentSubmission>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listClassStudentSubmissions(_class, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.listClassStudentSubmissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List the classes available for the current user
         * @param {ListClassesStateEnum} [state] Filter the classes by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClasses(state?: ListClassesStateEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClassDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listClasses(state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.listClasses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a feedback comment to a submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {string} submission Unique identifier of the submission
         * @param {AssignmentSubmissionCommentCreation} assignmentSubmissionCommentCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSubmissionComment(_class: string, assignment: string, submission: string, assignmentSubmissionCommentCreation: AssignmentSubmissionCommentCreation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssignmentSubmissionComment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSubmissionComment(_class, assignment, submission, assignmentSubmissionCommentCreation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.postSubmissionComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Mark the assignment as `active`. 
         * @summary Unarchive the assignment.
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unarchiveAssignment(_class: string, assignment: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Assignment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unarchiveAssignment(_class, assignment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.unarchiveAssignment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Mark the class as `active`. When this course is synchronized with another app, like Google Classroom, this state will be automatically be updated. 
         * @summary Unarchive the class
         * @param {string} _class Unique identifier of the class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unarchiveClass(_class: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unarchiveClass(_class, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.unarchiveClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the meta information of the class 
         * @summary Update the class
         * @param {string} _class Unique identifier of the class
         * @param {ClassUpdate} body Details of the Class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateClass(_class: string, body: ClassUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateClass(_class, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.updateClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a feedback comment to a submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {string} submission Unique identifier of the submission
         * @param {string} comment Unique identifier of the comment
         * @param {AssignmentSubmissionCommentCreation} assignmentSubmissionCommentCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubmissionComment(_class: string, assignment: string, submission: string, comment: string, assignmentSubmissionCommentCreation: AssignmentSubmissionCommentCreation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssignmentSubmissionComment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubmissionComment(_class, assignment, submission, comment, assignmentSubmissionCommentCreation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.updateSubmissionComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClassApi - factory interface
 * @export
 */
export const ClassApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClassApiFp(configuration)
    return {
        /**
         * Mark the class as `active`. This is mainly used for classes synchronized from Clever that are initially with an `inactive` state and hidden in the UI. 
         * @summary Activate the class
         * @param {string} _class Unique identifier of the class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateClass(_class: string, options?: any): AxiosPromise<ClassDetails> {
            return localVarFp.activateClass(_class, options).then((request) => request(axios, basePath));
        },
        /**
         * This method can be used by a teacher of the class to enroll another Flat user into the class.  Only users that are part of your Organization can be enrolled in a class of this same Organization.  When enrolling a user in the class, Flat will automatically add this user to the corresponding Class group, based on this role in the Organization. 
         * @summary Add a user to the class
         * @param {string} _class Unique identifier of the class
         * @param {string} user Unique identifier of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addClassUser(_class: string, user: string, options?: any): AxiosPromise<void> {
            return localVarFp.addClassUser(_class, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Archive the assignment 
         * @summary Archive the assignment
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveAssignment(_class: string, assignment: string, options?: any): AxiosPromise<Assignment> {
            return localVarFp.archiveAssignment(_class, assignment, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark the class as `archived`. When this course is synchronized with another app, like Google Classroom, this state will be automatically be updated. 
         * @summary Archive the class
         * @param {string} _class Unique identifier of the class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveClass(_class: string, options?: any): AxiosPromise<ClassDetails> {
            return localVarFp.archiveClass(_class, options).then((request) => request(axios, basePath));
        },
        /**
         * Copy an assignment to a specified class or the resource library  For class assignments: - If the original assignment has a due date in the past, this new assignment will be created without a due date. - If the class is synchronized with an external app (e.g. Google Classroom), the copied assignment will also be posted on the external app. 
         * @summary Copy an assignment
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {AssignmentCopy} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyAssignment(_class: string, assignment: string, body: AssignmentCopy, options?: any): AxiosPromise<AssignmentCopyResponse> {
            return localVarFp.copyAssignment(_class, assignment, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Classrooms on Flat allow you to create activities with assignments and post content to a specific group.  When creating a class, Flat automatically creates two groups: one for the teachers of the course, one for the students. The creator of this class is automatically added to the teachers group.  If the classsroom is synchronized with another application like Google Classroom, some of the meta information will automatically be updated.  You can add users to this class using `PUT /classes/{class}/users/{user}`, they will automatically added to the group based on their role on Flat. Users can also enroll themselves to this class using `POST /classes/enroll/{enrollmentCode}` and the `enrollmentCode` returned in the `ClassDetails` response. 
         * @summary Create a new class
         * @param {ClassCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClass(body: ClassCreation, options?: any): AxiosPromise<ClassDetails> {
            return localVarFp.createClass(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method as a teacher to create and post a new assignment to a class.  If the class is synchronized with Google Classroom, the assignment will be automatically posted to your Classroom course. 
         * @summary Assignment creation
         * @param {string} _class Unique identifier of the class
         * @param {ClassAssignmentUpdate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClassAssignment(_class: string, body: ClassAssignmentUpdate, options?: any): AxiosPromise<Assignment> {
            return localVarFp.createClassAssignment(_class, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method as a student to create, update and submit a submission related to an assignment. Students can only set `attachments` and `submit`. Teachers can use `PUT /classes/{class}/assignments/{assignment}/submissions/{submission}` to update a submission by id. 
         * @summary Create or edit a submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {AssignmentSubmissionUpdate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubmission(_class: string, assignment: string, body: AssignmentSubmissionUpdate, options?: any): AxiosPromise<AssignmentSubmission> {
            return localVarFp.createSubmission(_class, assignment, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Test students account can be created by teachers an admin and be used to experiment the assignments.  - They are automatically added to the class. - They can be reset using this API endpoint (a new account will be created and the previous one scheduled for deletion). - These accounts don\'t use a user license. 
         * @summary Create a test student account
         * @param {string} _class Unique identifier of the class
         * @param {boolean} [reset] If true, the testing account will be re-created. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTestStudentAccount(_class: string, reset?: boolean, options?: any): AxiosPromise<UserDetails> {
            return localVarFp.createTestStudentAccount(_class, reset, options).then((request) => request(axios, basePath));
        },
        /**
         * This method can be used by a teacher to remove a user from the class, or by a student to leave the classroom.  Warning: Removing a user from the class will remove the associated resources, including the submissions and feedback related to these submissions. 
         * @summary Remove a user from the class
         * @param {string} _class Unique identifier of the class
         * @param {string} user Unique identifier of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClassUser(_class: string, user: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteClassUser(_class, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method as a teacher to reset a submission and allow student to start over the assignment 
         * @summary Reset a submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {string} submission Unique identifier of the submission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmission(_class: string, assignment: string, submission: string, options?: any): AxiosPromise<AssignmentSubmission> {
            return localVarFp.deleteSubmission(_class, assignment, submission, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a feedback comment to a submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {string} submission Unique identifier of the submission
         * @param {string} comment Unique identifier of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmissionComment(_class: string, assignment: string, submission: string, comment: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSubmissionComment(_class, assignment, submission, comment, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method as a teacher to update the different submission and give feedback. Teachers can only set `return`, `draftGrade` and `grade` 
         * @summary Edit a submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {string} submission Unique identifier of the submission
         * @param {AssignmentSubmissionUpdate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editSubmission(_class: string, assignment: string, submission: string, body: AssignmentSubmissionUpdate, options?: any): AxiosPromise<AssignmentSubmission> {
            return localVarFp.editSubmission(_class, assignment, submission, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to join a class using an enrollment code given one of the teacher of this class. This code is also available in the `ClassDetails` returned to the teachers when creating the class or listing / fetching a specific class.  Flat will automatically add the user to the corresponding class group based on this role in the organization. 
         * @summary Join a class
         * @param {string} enrollmentCode The enrollment code, available to the teacher in &#x60;ClassDetails&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollClass(enrollmentCode: string, options?: any): AxiosPromise<ClassDetails> {
            return localVarFp.enrollClass(enrollmentCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Export list of submissions grades to a CSV file
         * @summary CSV Grades exports
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportSubmissionsReviewsAsCsv(_class: string, assignment: string, options?: any): AxiosPromise<File> {
            return localVarFp.exportSubmissionsReviewsAsCsv(_class, assignment, options).then((request) => request(axios, basePath));
        },
        /**
         * Export list of submissions grades to an Excel file
         * @summary Excel Grades exports
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportSubmissionsReviewsAsExcel(_class: string, assignment: string, options?: any): AxiosPromise<File> {
            return localVarFp.exportSubmissionsReviewsAsExcel(_class, assignment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a single class
         * @param {string} _class Unique identifier of the class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClass(_class: string, options?: any): AxiosPromise<ClassDetails> {
            return localVarFp.getClass(_class, options).then((request) => request(axios, basePath));
        },
        /**
         * This API call will list the different assignments submissions where the score is attached. This method can be used by anyone that are part of the organization and have at least read access to the document. 
         * @summary List submissions related to the score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoreSubmissions(score: string, options?: any): AxiosPromise<Array<AssignmentSubmission>> {
            return localVarFp.getScoreSubmissions(score, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a student submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {string} submission Unique identifier of the submission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmission(_class: string, assignment: string, submission: string, options?: any): AxiosPromise<AssignmentSubmission> {
            return localVarFp.getSubmission(_class, assignment, submission, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the feedback comments of a submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {string} submission Unique identifier of the submission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissionComments(_class: string, assignment: string, submission: string, options?: any): AxiosPromise<Array<AssignmentSubmissionComment>> {
            return localVarFp.getSubmissionComments(_class, assignment, submission, options).then((request) => request(axios, basePath));
        },
        /**
         * For teachers only. Returns a detailed history of the submission. This currently includes state and grade histories. 
         * @summary Get the history of the submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {string} submission Unique identifier of the submission
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissionHistory(_class: string, assignment: string, submission: string, options?: any): AxiosPromise<Array<AssignmentSubmissionHistory>> {
            return localVarFp.getSubmissionHistory(_class, assignment, submission, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the students\' submissions
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissions(_class: string, assignment: string, options?: any): AxiosPromise<Array<AssignmentSubmission>> {
            return localVarFp.getSubmissions(_class, assignment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Assignments listing
         * @param {string} _class Unique identifier of the class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAssignments(_class: string, options?: any): AxiosPromise<Array<ClassAssignment>> {
            return localVarFp.listAssignments(_class, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method as a teacher to list all the assignment submissions sent by a student of the class 
         * @summary List the submissions for a student
         * @param {string} _class Unique identifier of the class
         * @param {string} user Unique identifier of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClassStudentSubmissions(_class: string, user: string, options?: any): AxiosPromise<Array<AssignmentSubmission>> {
            return localVarFp.listClassStudentSubmissions(_class, user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the classes available for the current user
         * @param {ListClassesStateEnum} [state] Filter the classes by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClasses(state?: ListClassesStateEnum, options?: any): AxiosPromise<Array<ClassDetails>> {
            return localVarFp.listClasses(state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a feedback comment to a submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {string} submission Unique identifier of the submission
         * @param {AssignmentSubmissionCommentCreation} assignmentSubmissionCommentCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmissionComment(_class: string, assignment: string, submission: string, assignmentSubmissionCommentCreation: AssignmentSubmissionCommentCreation, options?: any): AxiosPromise<AssignmentSubmissionComment> {
            return localVarFp.postSubmissionComment(_class, assignment, submission, assignmentSubmissionCommentCreation, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark the assignment as `active`. 
         * @summary Unarchive the assignment.
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveAssignment(_class: string, assignment: string, options?: any): AxiosPromise<Assignment> {
            return localVarFp.unarchiveAssignment(_class, assignment, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark the class as `active`. When this course is synchronized with another app, like Google Classroom, this state will be automatically be updated. 
         * @summary Unarchive the class
         * @param {string} _class Unique identifier of the class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveClass(_class: string, options?: any): AxiosPromise<ClassDetails> {
            return localVarFp.unarchiveClass(_class, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the meta information of the class 
         * @summary Update the class
         * @param {string} _class Unique identifier of the class
         * @param {ClassUpdate} body Details of the Class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClass(_class: string, body: ClassUpdate, options?: any): AxiosPromise<ClassDetails> {
            return localVarFp.updateClass(_class, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a feedback comment to a submission
         * @param {string} _class Unique identifier of the class
         * @param {string} assignment Unique identifier of the assignment
         * @param {string} submission Unique identifier of the submission
         * @param {string} comment Unique identifier of the comment
         * @param {AssignmentSubmissionCommentCreation} assignmentSubmissionCommentCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubmissionComment(_class: string, assignment: string, submission: string, comment: string, assignmentSubmissionCommentCreation: AssignmentSubmissionCommentCreation, options?: any): AxiosPromise<AssignmentSubmissionComment> {
            return localVarFp.updateSubmissionComment(_class, assignment, submission, comment, assignmentSubmissionCommentCreation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClassApi - object-oriented interface
 * @export
 * @class ClassApi
 * @extends {BaseAPI}
 */
export class ClassApi extends BaseAPI {
    /**
     * Mark the class as `active`. This is mainly used for classes synchronized from Clever that are initially with an `inactive` state and hidden in the UI. 
     * @summary Activate the class
     * @param {string} _class Unique identifier of the class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public activateClass(_class: string, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).activateClass(_class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method can be used by a teacher of the class to enroll another Flat user into the class.  Only users that are part of your Organization can be enrolled in a class of this same Organization.  When enrolling a user in the class, Flat will automatically add this user to the corresponding Class group, based on this role in the Organization. 
     * @summary Add a user to the class
     * @param {string} _class Unique identifier of the class
     * @param {string} user Unique identifier of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public addClassUser(_class: string, user: string, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).addClassUser(_class, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Archive the assignment 
     * @summary Archive the assignment
     * @param {string} _class Unique identifier of the class
     * @param {string} assignment Unique identifier of the assignment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public archiveAssignment(_class: string, assignment: string, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).archiveAssignment(_class, assignment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark the class as `archived`. When this course is synchronized with another app, like Google Classroom, this state will be automatically be updated. 
     * @summary Archive the class
     * @param {string} _class Unique identifier of the class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public archiveClass(_class: string, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).archiveClass(_class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Copy an assignment to a specified class or the resource library  For class assignments: - If the original assignment has a due date in the past, this new assignment will be created without a due date. - If the class is synchronized with an external app (e.g. Google Classroom), the copied assignment will also be posted on the external app. 
     * @summary Copy an assignment
     * @param {string} _class Unique identifier of the class
     * @param {string} assignment Unique identifier of the assignment
     * @param {AssignmentCopy} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public copyAssignment(_class: string, assignment: string, body: AssignmentCopy, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).copyAssignment(_class, assignment, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Classrooms on Flat allow you to create activities with assignments and post content to a specific group.  When creating a class, Flat automatically creates two groups: one for the teachers of the course, one for the students. The creator of this class is automatically added to the teachers group.  If the classsroom is synchronized with another application like Google Classroom, some of the meta information will automatically be updated.  You can add users to this class using `PUT /classes/{class}/users/{user}`, they will automatically added to the group based on their role on Flat. Users can also enroll themselves to this class using `POST /classes/enroll/{enrollmentCode}` and the `enrollmentCode` returned in the `ClassDetails` response. 
     * @summary Create a new class
     * @param {ClassCreation} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public createClass(body: ClassCreation, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).createClass(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method as a teacher to create and post a new assignment to a class.  If the class is synchronized with Google Classroom, the assignment will be automatically posted to your Classroom course. 
     * @summary Assignment creation
     * @param {string} _class Unique identifier of the class
     * @param {ClassAssignmentUpdate} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public createClassAssignment(_class: string, body: ClassAssignmentUpdate, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).createClassAssignment(_class, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method as a student to create, update and submit a submission related to an assignment. Students can only set `attachments` and `submit`. Teachers can use `PUT /classes/{class}/assignments/{assignment}/submissions/{submission}` to update a submission by id. 
     * @summary Create or edit a submission
     * @param {string} _class Unique identifier of the class
     * @param {string} assignment Unique identifier of the assignment
     * @param {AssignmentSubmissionUpdate} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public createSubmission(_class: string, assignment: string, body: AssignmentSubmissionUpdate, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).createSubmission(_class, assignment, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test students account can be created by teachers an admin and be used to experiment the assignments.  - They are automatically added to the class. - They can be reset using this API endpoint (a new account will be created and the previous one scheduled for deletion). - These accounts don\'t use a user license. 
     * @summary Create a test student account
     * @param {string} _class Unique identifier of the class
     * @param {boolean} [reset] If true, the testing account will be re-created. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public createTestStudentAccount(_class: string, reset?: boolean, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).createTestStudentAccount(_class, reset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method can be used by a teacher to remove a user from the class, or by a student to leave the classroom.  Warning: Removing a user from the class will remove the associated resources, including the submissions and feedback related to these submissions. 
     * @summary Remove a user from the class
     * @param {string} _class Unique identifier of the class
     * @param {string} user Unique identifier of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public deleteClassUser(_class: string, user: string, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).deleteClassUser(_class, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method as a teacher to reset a submission and allow student to start over the assignment 
     * @summary Reset a submission
     * @param {string} _class Unique identifier of the class
     * @param {string} assignment Unique identifier of the assignment
     * @param {string} submission Unique identifier of the submission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public deleteSubmission(_class: string, assignment: string, submission: string, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).deleteSubmission(_class, assignment, submission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a feedback comment to a submission
     * @param {string} _class Unique identifier of the class
     * @param {string} assignment Unique identifier of the assignment
     * @param {string} submission Unique identifier of the submission
     * @param {string} comment Unique identifier of the comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public deleteSubmissionComment(_class: string, assignment: string, submission: string, comment: string, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).deleteSubmissionComment(_class, assignment, submission, comment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method as a teacher to update the different submission and give feedback. Teachers can only set `return`, `draftGrade` and `grade` 
     * @summary Edit a submission
     * @param {string} _class Unique identifier of the class
     * @param {string} assignment Unique identifier of the assignment
     * @param {string} submission Unique identifier of the submission
     * @param {AssignmentSubmissionUpdate} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public editSubmission(_class: string, assignment: string, submission: string, body: AssignmentSubmissionUpdate, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).editSubmission(_class, assignment, submission, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to join a class using an enrollment code given one of the teacher of this class. This code is also available in the `ClassDetails` returned to the teachers when creating the class or listing / fetching a specific class.  Flat will automatically add the user to the corresponding class group based on this role in the organization. 
     * @summary Join a class
     * @param {string} enrollmentCode The enrollment code, available to the teacher in &#x60;ClassDetails&#x60; 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public enrollClass(enrollmentCode: string, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).enrollClass(enrollmentCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export list of submissions grades to a CSV file
     * @summary CSV Grades exports
     * @param {string} _class Unique identifier of the class
     * @param {string} assignment Unique identifier of the assignment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public exportSubmissionsReviewsAsCsv(_class: string, assignment: string, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).exportSubmissionsReviewsAsCsv(_class, assignment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export list of submissions grades to an Excel file
     * @summary Excel Grades exports
     * @param {string} _class Unique identifier of the class
     * @param {string} assignment Unique identifier of the assignment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public exportSubmissionsReviewsAsExcel(_class: string, assignment: string, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).exportSubmissionsReviewsAsExcel(_class, assignment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a single class
     * @param {string} _class Unique identifier of the class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public getClass(_class: string, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).getClass(_class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API call will list the different assignments submissions where the score is attached. This method can be used by anyone that are part of the organization and have at least read access to the document. 
     * @summary List submissions related to the score
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public getScoreSubmissions(score: string, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).getScoreSubmissions(score, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a student submission
     * @param {string} _class Unique identifier of the class
     * @param {string} assignment Unique identifier of the assignment
     * @param {string} submission Unique identifier of the submission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public getSubmission(_class: string, assignment: string, submission: string, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).getSubmission(_class, assignment, submission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the feedback comments of a submission
     * @param {string} _class Unique identifier of the class
     * @param {string} assignment Unique identifier of the assignment
     * @param {string} submission Unique identifier of the submission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public getSubmissionComments(_class: string, assignment: string, submission: string, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).getSubmissionComments(_class, assignment, submission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * For teachers only. Returns a detailed history of the submission. This currently includes state and grade histories. 
     * @summary Get the history of the submission
     * @param {string} _class Unique identifier of the class
     * @param {string} assignment Unique identifier of the assignment
     * @param {string} submission Unique identifier of the submission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public getSubmissionHistory(_class: string, assignment: string, submission: string, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).getSubmissionHistory(_class, assignment, submission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the students\' submissions
     * @param {string} _class Unique identifier of the class
     * @param {string} assignment Unique identifier of the assignment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public getSubmissions(_class: string, assignment: string, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).getSubmissions(_class, assignment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Assignments listing
     * @param {string} _class Unique identifier of the class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public listAssignments(_class: string, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).listAssignments(_class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method as a teacher to list all the assignment submissions sent by a student of the class 
     * @summary List the submissions for a student
     * @param {string} _class Unique identifier of the class
     * @param {string} user Unique identifier of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public listClassStudentSubmissions(_class: string, user: string, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).listClassStudentSubmissions(_class, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the classes available for the current user
     * @param {ListClassesStateEnum} [state] Filter the classes by state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public listClasses(state?: ListClassesStateEnum, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).listClasses(state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a feedback comment to a submission
     * @param {string} _class Unique identifier of the class
     * @param {string} assignment Unique identifier of the assignment
     * @param {string} submission Unique identifier of the submission
     * @param {AssignmentSubmissionCommentCreation} assignmentSubmissionCommentCreation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public postSubmissionComment(_class: string, assignment: string, submission: string, assignmentSubmissionCommentCreation: AssignmentSubmissionCommentCreation, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).postSubmissionComment(_class, assignment, submission, assignmentSubmissionCommentCreation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark the assignment as `active`. 
     * @summary Unarchive the assignment.
     * @param {string} _class Unique identifier of the class
     * @param {string} assignment Unique identifier of the assignment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public unarchiveAssignment(_class: string, assignment: string, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).unarchiveAssignment(_class, assignment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark the class as `active`. When this course is synchronized with another app, like Google Classroom, this state will be automatically be updated. 
     * @summary Unarchive the class
     * @param {string} _class Unique identifier of the class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public unarchiveClass(_class: string, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).unarchiveClass(_class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the meta information of the class 
     * @summary Update the class
     * @param {string} _class Unique identifier of the class
     * @param {ClassUpdate} body Details of the Class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public updateClass(_class: string, body: ClassUpdate, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).updateClass(_class, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a feedback comment to a submission
     * @param {string} _class Unique identifier of the class
     * @param {string} assignment Unique identifier of the assignment
     * @param {string} submission Unique identifier of the submission
     * @param {string} comment Unique identifier of the comment
     * @param {AssignmentSubmissionCommentCreation} assignmentSubmissionCommentCreation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassApi
     */
    public updateSubmissionComment(_class: string, assignment: string, submission: string, comment: string, assignmentSubmissionCommentCreation: AssignmentSubmissionCommentCreation, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).updateSubmissionComment(_class, assignment, submission, comment, assignmentSubmissionCommentCreation, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListClassesStateEnum = {
    Active: 'active',
    Inactive: 'inactive',
    Archived: 'archived'
} as const;
export type ListClassesStateEnum = typeof ListClassesStateEnum[keyof typeof ListClassesStateEnum];


/**
 * CollectionApi - axios parameter creator
 * @export
 */
export const CollectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This operation will add a score to a collection. The default behavior will make the score available across multiple collections. You must have the capability `canAddScores` on the provided `collection` to perform the action. 
         * @summary Add a score to the collection
         * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addScoreToCollection: async (collection: string, score: string, sharingKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('addScoreToCollection', 'collection', collection)
            // verify required parameter 'score' is not null or undefined
            assertParamExists('addScoreToCollection', 'score', score)
            const localVarPath = `/collections/{collection}/scores/{score}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"score"}}`, encodeURIComponent(String(score)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["collections", "collections.add_scores"], configuration)

            if (sharingKey !== undefined) {
                localVarQueryParameter['sharingKey'] = sharingKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method will create a new collection and add it to your `root` collection. 
         * @summary Create a new collection
         * @param {CollectionCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection: async (body: CollectionCreation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createCollection', 'body', body)
            const localVarPath = `/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["collections"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method will schedule the deletion of the collection. Until deleted, the collection will be available in the `trash`. 
         * @summary Delete the collection
         * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection: async (collection: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('deleteCollection', 'collection', collection)
            const localVarPath = `/collections/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["collections"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method will delete a score from the collection. Unlike [`DELETE /scores/{score}`](#operation/deleteScore), this score will not remove the score from your account, but only from the collection. This can be used to *move* a score from one collection to another, or simply remove a score from one collection when this one is contained in multiple collections. 
         * @summary Delete a score from the collection
         * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScoreFromCollection: async (collection: string, score: string, sharingKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('deleteScoreFromCollection', 'collection', collection)
            // verify required parameter 'score' is not null or undefined
            assertParamExists('deleteScoreFromCollection', 'score', score)
            const localVarPath = `/collections/{collection}/scores/{score}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"score"}}`, encodeURIComponent(String(score)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["collections"], configuration)

            if (sharingKey !== undefined) {
                localVarQueryParameter['sharingKey'] = sharingKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a collection\'s metadata
         * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
         * @param {CollectionModification} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCollection: async (collection: string, body: CollectionModification, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('editCollection', 'collection', collection)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('editCollection', 'body', body)
            const localVarPath = `/collections/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["collections"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get collection details
         * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection: async (collection: string, sharingKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('getCollection', 'collection', collection)
            const localVarPath = `/collections/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["collections", "collections.readonly"], configuration)

            if (sharingKey !== undefined) {
                localVarQueryParameter['sharingKey'] = sharingKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to list the scores contained in a collection. If no sort option is provided, the scores are sorted by `modificationDate` `desc`.  For example, to list the scores contained in your app collection, you can use `GET /v2/collections/app/scores`. 
         * @summary List the scores contained in a collection
         * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {ListCollectionScoresSortEnum} [sort] Sort
         * @param {ListCollectionScoresDirectionEnum} [direction] Sort direction
         * @param {number} [limit] This is the maximum number of objects that may be returned
         * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionScores: async (collection: string, sharingKey?: string, sort?: ListCollectionScoresSortEnum, direction?: ListCollectionScoresDirectionEnum, limit?: number, next?: string, previous?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('listCollectionScores', 'collection', collection)
            const localVarPath = `/collections/{collection}/scores`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["collections"], configuration)

            if (sharingKey !== undefined) {
                localVarQueryParameter['sharingKey'] = sharingKey;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (previous !== undefined) {
                localVarQueryParameter['previous'] = previous;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to list the user\'s collections contained in `parent` (by default in the `root` collection). If no sort option is provided, the collections are sorted by `creationDate` `desc`.  Note that this method will not include the `parent` collection in the listing. For example, if you need the details of the `root` collection, you can use `GET /v2/collections/root`.  To fetch your app collection details, you can use `GET /v2/collections/app`. 
         * @summary List the collections
         * @param {string} [parent] List the collection contained in this &#x60;parent&#x60; collection.  This option doesn\&#39;t provide a complete multi-level collection support. When sharing a collection with someone, this one will have as &#x60;parent&#x60; &#x60;sharedWithMe&#x60;. 
         * @param {ListCollectionsSortEnum} [sort] Sort
         * @param {ListCollectionsDirectionEnum} [direction] Sort direction
         * @param {number} [limit] This is the maximum number of objects that may be returned
         * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections: async (parent?: string, sort?: ListCollectionsSortEnum, direction?: ListCollectionsDirectionEnum, limit?: number, next?: string, previous?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["collections", "collections.readonly"], configuration)

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (previous !== undefined) {
                localVarQueryParameter['previous'] = previous;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method will restore the collection by removing it from the `trash` and add it back to the `root` collection. 
         * @summary Untrash a collection
         * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        untrashCollection: async (collection: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('untrashCollection', 'collection', collection)
            const localVarPath = `/collections/{collection}/untrash`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["collections"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionApi - functional programming interface
 * @export
 */
export const CollectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionApiAxiosParamCreator(configuration)
    return {
        /**
         * This operation will add a score to a collection. The default behavior will make the score available across multiple collections. You must have the capability `canAddScores` on the provided `collection` to perform the action. 
         * @summary Add a score to the collection
         * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addScoreToCollection(collection: string, score: string, sharingKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScoreDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addScoreToCollection(collection, score, sharingKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.addScoreToCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method will create a new collection and add it to your `root` collection. 
         * @summary Create a new collection
         * @param {CollectionCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollection(body: CollectionCreation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollection(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.createCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method will schedule the deletion of the collection. Until deleted, the collection will be available in the `trash`. 
         * @summary Delete the collection
         * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCollection(collection: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCollection(collection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.deleteCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method will delete a score from the collection. Unlike [`DELETE /scores/{score}`](#operation/deleteScore), this score will not remove the score from your account, but only from the collection. This can be used to *move* a score from one collection to another, or simply remove a score from one collection when this one is contained in multiple collections. 
         * @summary Delete a score from the collection
         * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScoreFromCollection(collection: string, score: string, sharingKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScoreFromCollection(collection, score, sharingKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.deleteScoreFromCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a collection\'s metadata
         * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
         * @param {CollectionModification} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editCollection(collection: string, body: CollectionModification, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editCollection(collection, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.editCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get collection details
         * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollection(collection: string, sharingKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollection(collection, sharingKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.getCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this method to list the scores contained in a collection. If no sort option is provided, the scores are sorted by `modificationDate` `desc`.  For example, to list the scores contained in your app collection, you can use `GET /v2/collections/app/scores`. 
         * @summary List the scores contained in a collection
         * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {ListCollectionScoresSortEnum} [sort] Sort
         * @param {ListCollectionScoresDirectionEnum} [direction] Sort direction
         * @param {number} [limit] This is the maximum number of objects that may be returned
         * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCollectionScores(collection: string, sharingKey?: string, sort?: ListCollectionScoresSortEnum, direction?: ListCollectionScoresDirectionEnum, limit?: number, next?: string, previous?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScoreDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCollectionScores(collection, sharingKey, sort, direction, limit, next, previous, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.listCollectionScores']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this method to list the user\'s collections contained in `parent` (by default in the `root` collection). If no sort option is provided, the collections are sorted by `creationDate` `desc`.  Note that this method will not include the `parent` collection in the listing. For example, if you need the details of the `root` collection, you can use `GET /v2/collections/root`.  To fetch your app collection details, you can use `GET /v2/collections/app`. 
         * @summary List the collections
         * @param {string} [parent] List the collection contained in this &#x60;parent&#x60; collection.  This option doesn\&#39;t provide a complete multi-level collection support. When sharing a collection with someone, this one will have as &#x60;parent&#x60; &#x60;sharedWithMe&#x60;. 
         * @param {ListCollectionsSortEnum} [sort] Sort
         * @param {ListCollectionsDirectionEnum} [direction] Sort direction
         * @param {number} [limit] This is the maximum number of objects that may be returned
         * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCollections(parent?: string, sort?: ListCollectionsSortEnum, direction?: ListCollectionsDirectionEnum, limit?: number, next?: string, previous?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Collection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCollections(parent, sort, direction, limit, next, previous, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.listCollections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method will restore the collection by removing it from the `trash` and add it back to the `root` collection. 
         * @summary Untrash a collection
         * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async untrashCollection(collection: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.untrashCollection(collection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionApi.untrashCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CollectionApi - factory interface
 * @export
 */
export const CollectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionApiFp(configuration)
    return {
        /**
         * This operation will add a score to a collection. The default behavior will make the score available across multiple collections. You must have the capability `canAddScores` on the provided `collection` to perform the action. 
         * @summary Add a score to the collection
         * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addScoreToCollection(collection: string, score: string, sharingKey?: string, options?: any): AxiosPromise<ScoreDetails> {
            return localVarFp.addScoreToCollection(collection, score, sharingKey, options).then((request) => request(axios, basePath));
        },
        /**
         * This method will create a new collection and add it to your `root` collection. 
         * @summary Create a new collection
         * @param {CollectionCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(body: CollectionCreation, options?: any): AxiosPromise<Collection> {
            return localVarFp.createCollection(body, options).then((request) => request(axios, basePath));
        },
        /**
         * This method will schedule the deletion of the collection. Until deleted, the collection will be available in the `trash`. 
         * @summary Delete the collection
         * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection(collection: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCollection(collection, options).then((request) => request(axios, basePath));
        },
        /**
         * This method will delete a score from the collection. Unlike [`DELETE /scores/{score}`](#operation/deleteScore), this score will not remove the score from your account, but only from the collection. This can be used to *move* a score from one collection to another, or simply remove a score from one collection when this one is contained in multiple collections. 
         * @summary Delete a score from the collection
         * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScoreFromCollection(collection: string, score: string, sharingKey?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteScoreFromCollection(collection, score, sharingKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a collection\'s metadata
         * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
         * @param {CollectionModification} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCollection(collection: string, body: CollectionModification, options?: any): AxiosPromise<Collection> {
            return localVarFp.editCollection(collection, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get collection details
         * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(collection: string, sharingKey?: string, options?: any): AxiosPromise<Collection> {
            return localVarFp.getCollection(collection, sharingKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to list the scores contained in a collection. If no sort option is provided, the scores are sorted by `modificationDate` `desc`.  For example, to list the scores contained in your app collection, you can use `GET /v2/collections/app/scores`. 
         * @summary List the scores contained in a collection
         * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {ListCollectionScoresSortEnum} [sort] Sort
         * @param {ListCollectionScoresDirectionEnum} [direction] Sort direction
         * @param {number} [limit] This is the maximum number of objects that may be returned
         * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionScores(collection: string, sharingKey?: string, sort?: ListCollectionScoresSortEnum, direction?: ListCollectionScoresDirectionEnum, limit?: number, next?: string, previous?: string, options?: any): AxiosPromise<Array<ScoreDetails>> {
            return localVarFp.listCollectionScores(collection, sharingKey, sort, direction, limit, next, previous, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to list the user\'s collections contained in `parent` (by default in the `root` collection). If no sort option is provided, the collections are sorted by `creationDate` `desc`.  Note that this method will not include the `parent` collection in the listing. For example, if you need the details of the `root` collection, you can use `GET /v2/collections/root`.  To fetch your app collection details, you can use `GET /v2/collections/app`. 
         * @summary List the collections
         * @param {string} [parent] List the collection contained in this &#x60;parent&#x60; collection.  This option doesn\&#39;t provide a complete multi-level collection support. When sharing a collection with someone, this one will have as &#x60;parent&#x60; &#x60;sharedWithMe&#x60;. 
         * @param {ListCollectionsSortEnum} [sort] Sort
         * @param {ListCollectionsDirectionEnum} [direction] Sort direction
         * @param {number} [limit] This is the maximum number of objects that may be returned
         * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections(parent?: string, sort?: ListCollectionsSortEnum, direction?: ListCollectionsDirectionEnum, limit?: number, next?: string, previous?: string, options?: any): AxiosPromise<Array<Collection>> {
            return localVarFp.listCollections(parent, sort, direction, limit, next, previous, options).then((request) => request(axios, basePath));
        },
        /**
         * This method will restore the collection by removing it from the `trash` and add it back to the `root` collection. 
         * @summary Untrash a collection
         * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        untrashCollection(collection: string, options?: any): AxiosPromise<void> {
            return localVarFp.untrashCollection(collection, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionApi - object-oriented interface
 * @export
 * @class CollectionApi
 * @extends {BaseAPI}
 */
export class CollectionApi extends BaseAPI {
    /**
     * This operation will add a score to a collection. The default behavior will make the score available across multiple collections. You must have the capability `canAddScores` on the provided `collection` to perform the action. 
     * @summary Add a score to the collection
     * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public addScoreToCollection(collection: string, score: string, sharingKey?: string, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).addScoreToCollection(collection, score, sharingKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method will create a new collection and add it to your `root` collection. 
     * @summary Create a new collection
     * @param {CollectionCreation} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public createCollection(body: CollectionCreation, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).createCollection(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method will schedule the deletion of the collection. Until deleted, the collection will be available in the `trash`. 
     * @summary Delete the collection
     * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public deleteCollection(collection: string, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).deleteCollection(collection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method will delete a score from the collection. Unlike [`DELETE /scores/{score}`](#operation/deleteScore), this score will not remove the score from your account, but only from the collection. This can be used to *move* a score from one collection to another, or simply remove a score from one collection when this one is contained in multiple collections. 
     * @summary Delete a score from the collection
     * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public deleteScoreFromCollection(collection: string, score: string, sharingKey?: string, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).deleteScoreFromCollection(collection, score, sharingKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a collection\'s metadata
     * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
     * @param {CollectionModification} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public editCollection(collection: string, body: CollectionModification, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).editCollection(collection, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get collection details
     * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
     * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public getCollection(collection: string, sharingKey?: string, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).getCollection(collection, sharingKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to list the scores contained in a collection. If no sort option is provided, the scores are sorted by `modificationDate` `desc`.  For example, to list the scores contained in your app collection, you can use `GET /v2/collections/app/scores`. 
     * @summary List the scores contained in a collection
     * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
     * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
     * @param {ListCollectionScoresSortEnum} [sort] Sort
     * @param {ListCollectionScoresDirectionEnum} [direction] Sort direction
     * @param {number} [limit] This is the maximum number of objects that may be returned
     * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
     * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public listCollectionScores(collection: string, sharingKey?: string, sort?: ListCollectionScoresSortEnum, direction?: ListCollectionScoresDirectionEnum, limit?: number, next?: string, previous?: string, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).listCollectionScores(collection, sharingKey, sort, direction, limit, next, previous, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to list the user\'s collections contained in `parent` (by default in the `root` collection). If no sort option is provided, the collections are sorted by `creationDate` `desc`.  Note that this method will not include the `parent` collection in the listing. For example, if you need the details of the `root` collection, you can use `GET /v2/collections/root`.  To fetch your app collection details, you can use `GET /v2/collections/app`. 
     * @summary List the collections
     * @param {string} [parent] List the collection contained in this &#x60;parent&#x60; collection.  This option doesn\&#39;t provide a complete multi-level collection support. When sharing a collection with someone, this one will have as &#x60;parent&#x60; &#x60;sharedWithMe&#x60;. 
     * @param {ListCollectionsSortEnum} [sort] Sort
     * @param {ListCollectionsDirectionEnum} [direction] Sort direction
     * @param {number} [limit] This is the maximum number of objects that may be returned
     * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
     * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public listCollections(parent?: string, sort?: ListCollectionsSortEnum, direction?: ListCollectionsDirectionEnum, limit?: number, next?: string, previous?: string, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).listCollections(parent, sort, direction, limit, next, previous, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method will restore the collection by removing it from the `trash` and add it back to the `root` collection. 
     * @summary Untrash a collection
     * @param {string} collection Unique identifier of the collection. The following aliases are supported: - &#x60;root&#x60;: The root collection of the account - &#x60;app&#x60;: Alias for the current app collection - &#x60;sharedWithMe&#x60;: Automatically contains new resources that have been shared individually - &#x60;trash&#x60;: Automatically contains resources that have been deleted 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public untrashCollection(collection: string, options?: RawAxiosRequestConfig) {
        return CollectionApiFp(this.configuration).untrashCollection(collection, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListCollectionScoresSortEnum = {
    CreationDate: 'creationDate',
    ModificationDate: 'modificationDate',
    Title: 'title'
} as const;
export type ListCollectionScoresSortEnum = typeof ListCollectionScoresSortEnum[keyof typeof ListCollectionScoresSortEnum];
/**
 * @export
 */
export const ListCollectionScoresDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ListCollectionScoresDirectionEnum = typeof ListCollectionScoresDirectionEnum[keyof typeof ListCollectionScoresDirectionEnum];
/**
 * @export
 */
export const ListCollectionsSortEnum = {
    CreationDate: 'creationDate',
    Title: 'title'
} as const;
export type ListCollectionsSortEnum = typeof ListCollectionsSortEnum[keyof typeof ListCollectionsSortEnum];
/**
 * @export
 */
export const ListCollectionsDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ListCollectionsDirectionEnum = typeof ListCollectionsDirectionEnum[keyof typeof ListCollectionsDirectionEnum];


/**
 * EduResourcesApi - axios parameter creator
 * @export
 */
export const EduResourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Copy an education resource to a Resource Library
         * @param {string} resource Unique identifier of the resource
         * @param {EduResourceCopy} eduResourceCopy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyEduResource: async (resource: string, eduResourceCopy: EduResourceCopy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('copyEduResource', 'resource', resource)
            // verify required parameter 'eduResourceCopy' is not null or undefined
            assertParamExists('copyEduResource', 'eduResourceCopy', eduResourceCopy)
            const localVarPath = `/eduResources/{resource}/copy`
                .replace(`{${"resource"}}`, encodeURIComponent(String(resource)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.resources", "edu.assignments"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eduResourceCopy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Once a resource library can be published to a class (`Assignment.capabilities.canPublishInClass = true`), this endpoint can be used for the feature \"View as student\".  It will ensure the teacher has a demo class, then copy the assignment to the demo class. You can then use `POST /classes/{class}/testStudent` to create a testing student account in the demo class. 
         * @summary Copy an education assignment to a teacher demo class
         * @param {string} resource Unique identifier of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyEduResourceToDemoClass: async (resource: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('copyEduResourceToDemoClass', 'resource', resource)
            const localVarPath = `/eduResources/{resource}/copyToDemoClass`
                .replace(`{${"resource"}}`, encodeURIComponent(String(resource)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.resources", "edu.assignments"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new education resource
         * @param {EduResourceCreation} eduResourceCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEduResource: async (eduResourceCreation: EduResourceCreation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eduResourceCreation' is not null or undefined
            assertParamExists('createEduResource', 'eduResourceCreation', eduResourceCreation)
            const localVarPath = `/eduResources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.resources", "edu.assignments"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eduResourceCreation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will return an LTI link that can be used to launch Flat for Education. The link, in a context from a class, will ensure the assignment has been copied in the class. 
         * @summary Create an LTI link for an education resource
         * @param {string} resource Unique identifier of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEduResourceLtiLink: async (resource: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('createEduResourceLtiLink', 'resource', resource)
            const localVarPath = `/eduResources/{resource}/createLtiLink`
                .replace(`{${"resource"}}`, encodeURIComponent(String(resource)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.resources", "edu.assignments"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an education resource
         * @param {string} resource Unique identifier of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEduResource: async (resource: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('deleteEduResource', 'resource', resource)
            const localVarPath = `/eduResources/{resource}`
                .replace(`{${"resource"}}`, encodeURIComponent(String(resource)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.resources", "edu.assignments"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an education resource
         * @param {string} resource Unique identifier of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEduResource: async (resource: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('getEduResource', 'resource', resource)
            const localVarPath = `/eduResources/{resource}`
                .replace(`{${"resource"}}`, encodeURIComponent(String(resource)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.resources", "edu.resources.readonly", "edu.assignments", "edu.assignments.readonly"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the education libraries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEduLibraries: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eduResources/libraries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.resources", "edu.resources.readonly", "edu.assignments", "edu.assignments.readonly"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List education resources in a library or folder
         * @param {string} [parent] List the resources contained in this &#x60;parent&#x60; library or folder 
         * @param {ListEduResourcesTypeEnum} [type] Filter the returned resources by type 
         * @param {ListEduResourcesSortEnum} [sort] Sort
         * @param {ListEduResourcesDirectionEnum} [direction] Sort direction
         * @param {number} [limit] This is the maximum number of resources that may be returned
         * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEduResources: async (parent?: string, type?: ListEduResourcesTypeEnum, sort?: ListEduResourcesSortEnum, direction?: ListEduResourcesDirectionEnum, limit?: number, next?: string, previous?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/eduResources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.resources", "edu.resources.readonly", "edu.assignments", "edu.assignments.readonly"], configuration)

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (previous !== undefined) {
                localVarQueryParameter['previous'] = previous;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move an education resource
         * @param {string} resource Unique identifier of the resource
         * @param {EduResourceMove} eduResourceMove 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveEduResource: async (resource: string, eduResourceMove: EduResourceMove, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('moveEduResource', 'resource', resource)
            // verify required parameter 'eduResourceMove' is not null or undefined
            assertParamExists('moveEduResource', 'eduResourceMove', eduResourceMove)
            const localVarPath = `/eduResources/{resource}/move`
                .replace(`{${"resource"}}`, encodeURIComponent(String(resource)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.resources", "edu.assignments"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eduResourceMove, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update any resources metadata (e.g. title).  Use this method to rename education resources folders or assignments. 
         * @summary Update an education resource metadata
         * @param {string} resource Unique identifier of the resource
         * @param {EduResourceUpdate} eduResourceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEduResource: async (resource: string, eduResourceUpdate: EduResourceUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('updateEduResource', 'resource', resource)
            // verify required parameter 'eduResourceUpdate' is not null or undefined
            assertParamExists('updateEduResource', 'eduResourceUpdate', eduResourceUpdate)
            const localVarPath = `/eduResources/{resource}`
                .replace(`{${"resource"}}`, encodeURIComponent(String(resource)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.resources", "edu.assignments"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eduResourceUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an education resource assignment
         * @param {string} resource Unique identifier of the resource
         * @param {AssignmentUpdate} assignmentUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEduResourceAssignment: async (resource: string, assignmentUpdate: AssignmentUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('updateEduResourceAssignment', 'resource', resource)
            // verify required parameter 'assignmentUpdate' is not null or undefined
            assertParamExists('updateEduResourceAssignment', 'assignmentUpdate', assignmentUpdate)
            const localVarPath = `/eduResources/{resource}/assignment`
                .replace(`{${"resource"}}`, encodeURIComponent(String(resource)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.resources", "edu.assignments"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignmentUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will copy a resource and the underlying resources. The assignment will be created as a draft that can be completed with other options before publishing (e.g. due date, publication date for scheduling, etc.). 
         * @summary Use an education resource in a class
         * @param {string} resource Unique identifier of the resource
         * @param {EduResourceUseInClass} eduResourceUseInClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        useEduResourceInClass: async (resource: string, eduResourceUseInClass: EduResourceUseInClass, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('useEduResourceInClass', 'resource', resource)
            // verify required parameter 'eduResourceUseInClass' is not null or undefined
            assertParamExists('useEduResourceInClass', 'eduResourceUseInClass', eduResourceUseInClass)
            const localVarPath = `/eduResources/{resource}/useInClass`
                .replace(`{${"resource"}}`, encodeURIComponent(String(resource)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.resources", "edu.assignments"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eduResourceUseInClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EduResourcesApi - functional programming interface
 * @export
 */
export const EduResourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EduResourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Copy an education resource to a Resource Library
         * @param {string} resource Unique identifier of the resource
         * @param {EduResourceCopy} eduResourceCopy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyEduResource(resource: string, eduResourceCopy: EduResourceCopy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EduResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.copyEduResource(resource, eduResourceCopy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EduResourcesApi.copyEduResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Once a resource library can be published to a class (`Assignment.capabilities.canPublishInClass = true`), this endpoint can be used for the feature \"View as student\".  It will ensure the teacher has a demo class, then copy the assignment to the demo class. You can then use `POST /classes/{class}/testStudent` to create a testing student account in the demo class. 
         * @summary Copy an education assignment to a teacher demo class
         * @param {string} resource Unique identifier of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyEduResourceToDemoClass(resource: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassAssignment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.copyEduResourceToDemoClass(resource, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EduResourcesApi.copyEduResourceToDemoClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new education resource
         * @param {EduResourceCreation} eduResourceCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEduResource(eduResourceCreation: EduResourceCreation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EduResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEduResource(eduResourceCreation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EduResourcesApi.createEduResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint will return an LTI link that can be used to launch Flat for Education. The link, in a context from a class, will ensure the assignment has been copied in the class. 
         * @summary Create an LTI link for an education resource
         * @param {string} resource Unique identifier of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEduResourceLtiLink(resource: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EduResourceLtiLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEduResourceLtiLink(resource, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EduResourcesApi.createEduResourceLtiLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an education resource
         * @param {string} resource Unique identifier of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEduResource(resource: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEduResource(resource, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EduResourcesApi.deleteEduResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get an education resource
         * @param {string} resource Unique identifier of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEduResource(resource: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EduResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEduResource(resource, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EduResourcesApi.getEduResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List the education libraries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEduLibraries(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EduLibrary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEduLibraries(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EduResourcesApi.listEduLibraries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List education resources in a library or folder
         * @param {string} [parent] List the resources contained in this &#x60;parent&#x60; library or folder 
         * @param {ListEduResourcesTypeEnum} [type] Filter the returned resources by type 
         * @param {ListEduResourcesSortEnum} [sort] Sort
         * @param {ListEduResourcesDirectionEnum} [direction] Sort direction
         * @param {number} [limit] This is the maximum number of resources that may be returned
         * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEduResources(parent?: string, type?: ListEduResourcesTypeEnum, sort?: ListEduResourcesSortEnum, direction?: ListEduResourcesDirectionEnum, limit?: number, next?: string, previous?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EduResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEduResources(parent, type, sort, direction, limit, next, previous, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EduResourcesApi.listEduResources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Move an education resource
         * @param {string} resource Unique identifier of the resource
         * @param {EduResourceMove} eduResourceMove 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveEduResource(resource: string, eduResourceMove: EduResourceMove, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EduResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveEduResource(resource, eduResourceMove, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EduResourcesApi.moveEduResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update any resources metadata (e.g. title).  Use this method to rename education resources folders or assignments. 
         * @summary Update an education resource metadata
         * @param {string} resource Unique identifier of the resource
         * @param {EduResourceUpdate} eduResourceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEduResource(resource: string, eduResourceUpdate: EduResourceUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EduResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEduResource(resource, eduResourceUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EduResourcesApi.updateEduResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an education resource assignment
         * @param {string} resource Unique identifier of the resource
         * @param {AssignmentUpdate} assignmentUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEduResourceAssignment(resource: string, assignmentUpdate: AssignmentUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Assignment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEduResourceAssignment(resource, assignmentUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EduResourcesApi.updateEduResourceAssignment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint will copy a resource and the underlying resources. The assignment will be created as a draft that can be completed with other options before publishing (e.g. due date, publication date for scheduling, etc.). 
         * @summary Use an education resource in a class
         * @param {string} resource Unique identifier of the resource
         * @param {EduResourceUseInClass} eduResourceUseInClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async useEduResourceInClass(resource: string, eduResourceUseInClass: EduResourceUseInClass, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassAssignment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.useEduResourceInClass(resource, eduResourceUseInClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EduResourcesApi.useEduResourceInClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EduResourcesApi - factory interface
 * @export
 */
export const EduResourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EduResourcesApiFp(configuration)
    return {
        /**
         * 
         * @summary Copy an education resource to a Resource Library
         * @param {string} resource Unique identifier of the resource
         * @param {EduResourceCopy} eduResourceCopy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyEduResource(resource: string, eduResourceCopy: EduResourceCopy, options?: any): AxiosPromise<EduResource> {
            return localVarFp.copyEduResource(resource, eduResourceCopy, options).then((request) => request(axios, basePath));
        },
        /**
         * Once a resource library can be published to a class (`Assignment.capabilities.canPublishInClass = true`), this endpoint can be used for the feature \"View as student\".  It will ensure the teacher has a demo class, then copy the assignment to the demo class. You can then use `POST /classes/{class}/testStudent` to create a testing student account in the demo class. 
         * @summary Copy an education assignment to a teacher demo class
         * @param {string} resource Unique identifier of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyEduResourceToDemoClass(resource: string, options?: any): AxiosPromise<ClassAssignment> {
            return localVarFp.copyEduResourceToDemoClass(resource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new education resource
         * @param {EduResourceCreation} eduResourceCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEduResource(eduResourceCreation: EduResourceCreation, options?: any): AxiosPromise<EduResource> {
            return localVarFp.createEduResource(eduResourceCreation, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will return an LTI link that can be used to launch Flat for Education. The link, in a context from a class, will ensure the assignment has been copied in the class. 
         * @summary Create an LTI link for an education resource
         * @param {string} resource Unique identifier of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEduResourceLtiLink(resource: string, options?: any): AxiosPromise<EduResourceLtiLink> {
            return localVarFp.createEduResourceLtiLink(resource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an education resource
         * @param {string} resource Unique identifier of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEduResource(resource: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEduResource(resource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an education resource
         * @param {string} resource Unique identifier of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEduResource(resource: string, options?: any): AxiosPromise<EduResource> {
            return localVarFp.getEduResource(resource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the education libraries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEduLibraries(options?: any): AxiosPromise<Array<EduLibrary>> {
            return localVarFp.listEduLibraries(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List education resources in a library or folder
         * @param {string} [parent] List the resources contained in this &#x60;parent&#x60; library or folder 
         * @param {ListEduResourcesTypeEnum} [type] Filter the returned resources by type 
         * @param {ListEduResourcesSortEnum} [sort] Sort
         * @param {ListEduResourcesDirectionEnum} [direction] Sort direction
         * @param {number} [limit] This is the maximum number of resources that may be returned
         * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEduResources(parent?: string, type?: ListEduResourcesTypeEnum, sort?: ListEduResourcesSortEnum, direction?: ListEduResourcesDirectionEnum, limit?: number, next?: string, previous?: string, options?: any): AxiosPromise<Array<EduResource>> {
            return localVarFp.listEduResources(parent, type, sort, direction, limit, next, previous, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move an education resource
         * @param {string} resource Unique identifier of the resource
         * @param {EduResourceMove} eduResourceMove 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveEduResource(resource: string, eduResourceMove: EduResourceMove, options?: any): AxiosPromise<EduResource> {
            return localVarFp.moveEduResource(resource, eduResourceMove, options).then((request) => request(axios, basePath));
        },
        /**
         * Update any resources metadata (e.g. title).  Use this method to rename education resources folders or assignments. 
         * @summary Update an education resource metadata
         * @param {string} resource Unique identifier of the resource
         * @param {EduResourceUpdate} eduResourceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEduResource(resource: string, eduResourceUpdate: EduResourceUpdate, options?: any): AxiosPromise<EduResource> {
            return localVarFp.updateEduResource(resource, eduResourceUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an education resource assignment
         * @param {string} resource Unique identifier of the resource
         * @param {AssignmentUpdate} assignmentUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEduResourceAssignment(resource: string, assignmentUpdate: AssignmentUpdate, options?: any): AxiosPromise<Assignment> {
            return localVarFp.updateEduResourceAssignment(resource, assignmentUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will copy a resource and the underlying resources. The assignment will be created as a draft that can be completed with other options before publishing (e.g. due date, publication date for scheduling, etc.). 
         * @summary Use an education resource in a class
         * @param {string} resource Unique identifier of the resource
         * @param {EduResourceUseInClass} eduResourceUseInClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        useEduResourceInClass(resource: string, eduResourceUseInClass: EduResourceUseInClass, options?: any): AxiosPromise<ClassAssignment> {
            return localVarFp.useEduResourceInClass(resource, eduResourceUseInClass, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EduResourcesApi - object-oriented interface
 * @export
 * @class EduResourcesApi
 * @extends {BaseAPI}
 */
export class EduResourcesApi extends BaseAPI {
    /**
     * 
     * @summary Copy an education resource to a Resource Library
     * @param {string} resource Unique identifier of the resource
     * @param {EduResourceCopy} eduResourceCopy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EduResourcesApi
     */
    public copyEduResource(resource: string, eduResourceCopy: EduResourceCopy, options?: RawAxiosRequestConfig) {
        return EduResourcesApiFp(this.configuration).copyEduResource(resource, eduResourceCopy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Once a resource library can be published to a class (`Assignment.capabilities.canPublishInClass = true`), this endpoint can be used for the feature \"View as student\".  It will ensure the teacher has a demo class, then copy the assignment to the demo class. You can then use `POST /classes/{class}/testStudent` to create a testing student account in the demo class. 
     * @summary Copy an education assignment to a teacher demo class
     * @param {string} resource Unique identifier of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EduResourcesApi
     */
    public copyEduResourceToDemoClass(resource: string, options?: RawAxiosRequestConfig) {
        return EduResourcesApiFp(this.configuration).copyEduResourceToDemoClass(resource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new education resource
     * @param {EduResourceCreation} eduResourceCreation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EduResourcesApi
     */
    public createEduResource(eduResourceCreation: EduResourceCreation, options?: RawAxiosRequestConfig) {
        return EduResourcesApiFp(this.configuration).createEduResource(eduResourceCreation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will return an LTI link that can be used to launch Flat for Education. The link, in a context from a class, will ensure the assignment has been copied in the class. 
     * @summary Create an LTI link for an education resource
     * @param {string} resource Unique identifier of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EduResourcesApi
     */
    public createEduResourceLtiLink(resource: string, options?: RawAxiosRequestConfig) {
        return EduResourcesApiFp(this.configuration).createEduResourceLtiLink(resource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an education resource
     * @param {string} resource Unique identifier of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EduResourcesApi
     */
    public deleteEduResource(resource: string, options?: RawAxiosRequestConfig) {
        return EduResourcesApiFp(this.configuration).deleteEduResource(resource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an education resource
     * @param {string} resource Unique identifier of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EduResourcesApi
     */
    public getEduResource(resource: string, options?: RawAxiosRequestConfig) {
        return EduResourcesApiFp(this.configuration).getEduResource(resource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the education libraries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EduResourcesApi
     */
    public listEduLibraries(options?: RawAxiosRequestConfig) {
        return EduResourcesApiFp(this.configuration).listEduLibraries(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List education resources in a library or folder
     * @param {string} [parent] List the resources contained in this &#x60;parent&#x60; library or folder 
     * @param {ListEduResourcesTypeEnum} [type] Filter the returned resources by type 
     * @param {ListEduResourcesSortEnum} [sort] Sort
     * @param {ListEduResourcesDirectionEnum} [direction] Sort direction
     * @param {number} [limit] This is the maximum number of resources that may be returned
     * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
     * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EduResourcesApi
     */
    public listEduResources(parent?: string, type?: ListEduResourcesTypeEnum, sort?: ListEduResourcesSortEnum, direction?: ListEduResourcesDirectionEnum, limit?: number, next?: string, previous?: string, options?: RawAxiosRequestConfig) {
        return EduResourcesApiFp(this.configuration).listEduResources(parent, type, sort, direction, limit, next, previous, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move an education resource
     * @param {string} resource Unique identifier of the resource
     * @param {EduResourceMove} eduResourceMove 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EduResourcesApi
     */
    public moveEduResource(resource: string, eduResourceMove: EduResourceMove, options?: RawAxiosRequestConfig) {
        return EduResourcesApiFp(this.configuration).moveEduResource(resource, eduResourceMove, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update any resources metadata (e.g. title).  Use this method to rename education resources folders or assignments. 
     * @summary Update an education resource metadata
     * @param {string} resource Unique identifier of the resource
     * @param {EduResourceUpdate} eduResourceUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EduResourcesApi
     */
    public updateEduResource(resource: string, eduResourceUpdate: EduResourceUpdate, options?: RawAxiosRequestConfig) {
        return EduResourcesApiFp(this.configuration).updateEduResource(resource, eduResourceUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an education resource assignment
     * @param {string} resource Unique identifier of the resource
     * @param {AssignmentUpdate} assignmentUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EduResourcesApi
     */
    public updateEduResourceAssignment(resource: string, assignmentUpdate: AssignmentUpdate, options?: RawAxiosRequestConfig) {
        return EduResourcesApiFp(this.configuration).updateEduResourceAssignment(resource, assignmentUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will copy a resource and the underlying resources. The assignment will be created as a draft that can be completed with other options before publishing (e.g. due date, publication date for scheduling, etc.). 
     * @summary Use an education resource in a class
     * @param {string} resource Unique identifier of the resource
     * @param {EduResourceUseInClass} eduResourceUseInClass 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EduResourcesApi
     */
    public useEduResourceInClass(resource: string, eduResourceUseInClass: EduResourceUseInClass, options?: RawAxiosRequestConfig) {
        return EduResourcesApiFp(this.configuration).useEduResourceInClass(resource, eduResourceUseInClass, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListEduResourcesTypeEnum = {
    Assignment: 'assignment',
    Folder: 'folder'
} as const;
export type ListEduResourcesTypeEnum = typeof ListEduResourcesTypeEnum[keyof typeof ListEduResourcesTypeEnum];
/**
 * @export
 */
export const ListEduResourcesSortEnum = {
    CreationDate: 'creationDate',
    UpdateDate: 'updateDate',
    Title: 'title'
} as const;
export type ListEduResourcesSortEnum = typeof ListEduResourcesSortEnum[keyof typeof ListEduResourcesSortEnum];
/**
 * @export
 */
export const ListEduResourcesDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ListEduResourcesDirectionEnum = typeof ListEduResourcesDirectionEnum[keyof typeof ListEduResourcesDirectionEnum];


/**
 * GroupApi - axios parameter creator
 * @export
 */
export const GroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get group information
         * @param {string} group Unique identifier of a Flat group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupDetails: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('getGroupDetails', 'group', group)
            const localVarPath = `/groups/{group}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.admin", "edu.admin.users", "edu.admin.users.readonly", "edu.classes", "edu.classes.readonly"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of scores shared with a group. 
         * @summary List group\'s scores
         * @param {string} group Unique identifier of a Flat group 
         * @param {string} [parent] Filter the score forked from the score id &#x60;parent&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupScores: async (group: string, parent?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('getGroupScores', 'group', group)
            const localVarPath = `/groups/{group}/scores`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores", "scores.readonly"], configuration)

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List group\'s users
         * @param {string} group Unique identifier of a Flat group 
         * @param {ListGroupUsersSourceEnum} [source] Filter the users by their source 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroupUsers: async (group: string, source?: ListGroupUsersSourceEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('listGroupUsers', 'group', group)
            const localVarPath = `/groups/{group}/users`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.admin", "edu.admin.users", "edu.admin.users.readonly", "edu.classes", "edu.classes.readonly"], configuration)

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupApi - functional programming interface
 * @export
 */
export const GroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get group information
         * @param {string} group Unique identifier of a Flat group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupDetails(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupDetails(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.getGroupDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the list of scores shared with a group. 
         * @summary List group\'s scores
         * @param {string} group Unique identifier of a Flat group 
         * @param {string} [parent] Filter the score forked from the score id &#x60;parent&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupScores(group: string, parent?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScoreDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupScores(group, parent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.getGroupScores']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List group\'s users
         * @param {string} group Unique identifier of a Flat group 
         * @param {ListGroupUsersSourceEnum} [source] Filter the users by their source 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroupUsers(group: string, source?: ListGroupUsersSourceEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserPublic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroupUsers(group, source, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupApi.listGroupUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupApi - factory interface
 * @export
 */
export const GroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupApiFp(configuration)
    return {
        /**
         * 
         * @summary Get group information
         * @param {string} group Unique identifier of a Flat group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupDetails(group: string, options?: any): AxiosPromise<GroupDetails> {
            return localVarFp.getGroupDetails(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of scores shared with a group. 
         * @summary List group\'s scores
         * @param {string} group Unique identifier of a Flat group 
         * @param {string} [parent] Filter the score forked from the score id &#x60;parent&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupScores(group: string, parent?: string, options?: any): AxiosPromise<Array<ScoreDetails>> {
            return localVarFp.getGroupScores(group, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List group\'s users
         * @param {string} group Unique identifier of a Flat group 
         * @param {ListGroupUsersSourceEnum} [source] Filter the users by their source 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroupUsers(group: string, source?: ListGroupUsersSourceEnum, options?: any): AxiosPromise<Array<UserPublic>> {
            return localVarFp.listGroupUsers(group, source, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
export class GroupApi extends BaseAPI {
    /**
     * 
     * @summary Get group information
     * @param {string} group Unique identifier of a Flat group 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public getGroupDetails(group: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).getGroupDetails(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the list of scores shared with a group. 
     * @summary List group\'s scores
     * @param {string} group Unique identifier of a Flat group 
     * @param {string} [parent] Filter the score forked from the score id &#x60;parent&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public getGroupScores(group: string, parent?: string, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).getGroupScores(group, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List group\'s users
     * @param {string} group Unique identifier of a Flat group 
     * @param {ListGroupUsersSourceEnum} [source] Filter the users by their source 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public listGroupUsers(group: string, source?: ListGroupUsersSourceEnum, options?: RawAxiosRequestConfig) {
        return GroupApiFp(this.configuration).listGroupUsers(group, source, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListGroupUsersSourceEnum = {
    GoogleClassroom: 'googleClassroom',
    MicrosoftGraph: 'microsoftGraph',
    Clever: 'clever'
} as const;
export type ListGroupUsersSourceEnum = typeof ListGroupUsersSourceEnum[keyof typeof ListGroupUsersSourceEnum];


/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Count the organization users using the provided filters
         * @param {Array<CountOrgaUsersRoleEnum>} [role] Filter users by role
         * @param {string} [q] The query to search
         * @param {Array<string>} [group] Filter users by group
         * @param {boolean} [noActiveLicense] Filter users who don\&#39;t have an active license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countOrgaUsers: async (role?: Array<CountOrgaUsersRoleEnum>, q?: string, group?: Array<string>, noActiveLicense?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations/users/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.admin", "edu.admin.users", "edu.admin.users.readonly"], configuration)

            if (role) {
                localVarQueryParameter['role'] = role;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (group) {
                localVarQueryParameter['group'] = group;
            }

            if (noActiveLicense !== undefined) {
                localVarQueryParameter['noActiveLicense'] = noActiveLicense;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Flat for Education is a Certified LTI Provider. You can use these API methods to automate the creation of LTI credentials. You can read more about our LTI implementation, supported components and LTI Endpoints in our [Developer Documentation](https://flat.io/developers/docs/lti/). 
         * @summary Create a new couple of LTI 1.x credentials
         * @param {LtiCredentialsCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLtiCredentials: async (body: LtiCredentialsCreation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createLtiCredentials', 'body', body)
            const localVarPath = `/organizations/lti/credentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.admin", "edu.admin.lti"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method creates and sends invitation for teachers and admins.  Invitations can only be used by new Flat users or users who are not part of the organization yet.  If the email of the user is already associated to a user of your organization, the API will simply update the role of the existing user and won\'t send an invitation. In this case, the property `usedBy` will be directly filled with the uniquer identifier of the corresponding user. 
         * @summary Create a new invitation to join the organization
         * @param {OrganizationInvitationCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationInvitation: async (body: OrganizationInvitationCreation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOrganizationInvitation', 'body', body)
            const localVarPath = `/organizations/invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.admin", "edu.admin.users"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new user account
         * @param {UserCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationUser: async (body: UserCreation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOrganizationUser', 'body', body)
            const localVarPath = `/organizations/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.admin", "edu.admin.users"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation will create an API access token for a chosen organization user. This token will be valid for a limited time and can be used to access the API as the organization user. 
         * @summary Create a delegated API access token for an organization user
         * @param {string} user Unique identifier of the Flat account 
         * @param {OrganizationUserAccessTokenCreation} organizationUserAccessTokenCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationUserAccessToken: async (user: string, organizationUserAccessTokenCreation: OrganizationUserAccessTokenCreation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('createOrganizationUserAccessToken', 'user', user)
            // verify required parameter 'organizationUserAccessTokenCreation' is not null or undefined
            assertParamExists('createOrganizationUserAccessToken', 'organizationUserAccessTokenCreation', organizationUserAccessTokenCreation)
            const localVarPath = `/organizations/users/{user}/accessToken`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.admin", "edu.admin.users"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationUserAccessTokenCreation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a sign in link for an organization user
         * @param {string} user Unique identifier of the Flat account 
         * @param {UserSigninLinkCreation} userSigninLinkCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationUserSigninLink: async (user: string, userSigninLinkCreation: UserSigninLinkCreation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('createOrganizationUserSigninLink', 'user', user)
            // verify required parameter 'userSigninLinkCreation' is not null or undefined
            assertParamExists('createOrganizationUserSigninLink', 'userSigninLinkCreation', userSigninLinkCreation)
            const localVarPath = `/organizations/users/{user}/signinLink`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.admin", "edu.admin.users"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSigninLinkCreation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List LTI 1.x credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLtiCredentials: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations/lti/credentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.admin", "edu.admin.lti", "edu.admin.lti.readonly"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the organization invitations
         * @param {ListOrganizationInvitationsRoleEnum} [role] Filter users by role
         * @param {number} [limit] This is the maximum number of objects that may be returned
         * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationInvitations: async (role?: ListOrganizationInvitationsRoleEnum, limit?: number, next?: string, previous?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations/invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.admin", "edu.admin.users", "edu.admin.users.readonly"], configuration)

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (previous !== undefined) {
                localVarQueryParameter['previous'] = previous;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the organization users
         * @param {Array<ListOrganizationUsersSortEnum>} [sort] The order to sort the user list
         * @param {ListOrganizationUsersDirectionEnum} [direction] Sort direction
         * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {Array<ListOrganizationUsersRoleEnum>} [role] Filter users by role
         * @param {string} [q] The query to search
         * @param {Array<string>} [group] Filter users by group
         * @param {boolean} [noActiveLicense] Filter users who don\&#39;t have an active license
         * @param {Array<string>} [licenseExpirationDate] Filter users by license expiration date or &#x60;active&#x60; / &#x60;notActive&#x60;
         * @param {boolean} [onlyIds] Return only user ids
         * @param {number} [limit] This is the maximum number of objects that may be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationUsers: async (sort?: Array<ListOrganizationUsersSortEnum>, direction?: ListOrganizationUsersDirectionEnum, next?: string, previous?: string, role?: Array<ListOrganizationUsersRoleEnum>, q?: string, group?: Array<string>, noActiveLicense?: boolean, licenseExpirationDate?: Array<string>, onlyIds?: boolean, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.admin", "edu.admin.users", "edu.admin.users.readonly"], configuration)

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (previous !== undefined) {
                localVarQueryParameter['previous'] = previous;
            }

            if (role) {
                localVarQueryParameter['role'] = role;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (group) {
                localVarQueryParameter['group'] = group;
            }

            if (noActiveLicense !== undefined) {
                localVarQueryParameter['noActiveLicense'] = noActiveLicense;
            }

            if (licenseExpirationDate) {
                localVarQueryParameter['licenseExpirationDate'] = licenseExpirationDate;
            }

            if (onlyIds !== undefined) {
                localVarQueryParameter['onlyIds'] = onlyIds;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an organization invitation
         * @param {string} invitation Unique identifier of the invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrganizationInvitation: async (invitation: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invitation' is not null or undefined
            assertParamExists('removeOrganizationInvitation', 'invitation', invitation)
            const localVarPath = `/organizations/invitations/{invitation}`
                .replace(`{${"invitation"}}`, encodeURIComponent(String(invitation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.admin", "edu.admin.users"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation removes an account from Flat and its data, including: * The music scores created by this user (documents, history, comments, collaboration information) * Education related data (assignments and classroom information) 
         * @summary Remove an account from Flat
         * @param {string} user Unique identifier of the Flat account 
         * @param {boolean} [convertToIndividual] If &#x60;true&#x60;, the account will be only removed from the organization and converted into an individual account on our public website, https://flat.io. This operation will remove the education-related data from the account. Before realizing this operation, you need to be sure that the user is at least 13 years old and that this one has read and agreed to the Individual Terms of Services of Flat available on https://flat.io/legal. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrganizationUser: async (user: string, convertToIndividual?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('removeOrganizationUser', 'user', user)
            const localVarPath = `/organizations/users/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.admin", "edu.admin.users"], configuration)

            if (convertToIndividual !== undefined) {
                localVarQueryParameter['convertToIndividual'] = convertToIndividual;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke LTI 1.x credentials
         * @param {string} credentials Credentials unique identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeLtiCredentials: async (credentials: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentials' is not null or undefined
            assertParamExists('revokeLtiCredentials', 'credentials', credentials)
            const localVarPath = `/organizations/lti/credentials/{credentials}`
                .replace(`{${"credentials"}}`, encodeURIComponent(String(credentials)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.admin", "edu.admin.lti"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update account information
         * @param {string} user Unique identifier of the Flat account 
         * @param {UserAdminUpdate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationUser: async (user: string, body: UserAdminUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateOrganizationUser', 'user', user)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateOrganizationUser', 'body', body)
            const localVarPath = `/organizations/users/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["edu.admin", "edu.admin.users"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Count the organization users using the provided filters
         * @param {Array<CountOrgaUsersRoleEnum>} [role] Filter users by role
         * @param {string} [q] The query to search
         * @param {Array<string>} [group] Filter users by group
         * @param {boolean} [noActiveLicense] Filter users who don\&#39;t have an active license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countOrgaUsers(role?: Array<CountOrgaUsersRoleEnum>, q?: string, group?: Array<string>, noActiveLicense?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDetailsAdmin>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countOrgaUsers(role, q, group, noActiveLicense, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.countOrgaUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Flat for Education is a Certified LTI Provider. You can use these API methods to automate the creation of LTI credentials. You can read more about our LTI implementation, supported components and LTI Endpoints in our [Developer Documentation](https://flat.io/developers/docs/lti/). 
         * @summary Create a new couple of LTI 1.x credentials
         * @param {LtiCredentialsCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLtiCredentials(body: LtiCredentialsCreation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LtiCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLtiCredentials(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.createLtiCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method creates and sends invitation for teachers and admins.  Invitations can only be used by new Flat users or users who are not part of the organization yet.  If the email of the user is already associated to a user of your organization, the API will simply update the role of the existing user and won\'t send an invitation. In this case, the property `usedBy` will be directly filled with the uniquer identifier of the corresponding user. 
         * @summary Create a new invitation to join the organization
         * @param {OrganizationInvitationCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationInvitation(body: OrganizationInvitationCreation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationInvitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationInvitation(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.createOrganizationInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new user account
         * @param {UserCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationUser(body: UserCreation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDetailsAdmin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationUser(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.createOrganizationUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This operation will create an API access token for a chosen organization user. This token will be valid for a limited time and can be used to access the API as the organization user. 
         * @summary Create a delegated API access token for an organization user
         * @param {string} user Unique identifier of the Flat account 
         * @param {OrganizationUserAccessTokenCreation} organizationUserAccessTokenCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationUserAccessToken(user: string, organizationUserAccessTokenCreation: OrganizationUserAccessTokenCreation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationUserAccessToken(user, organizationUserAccessTokenCreation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.createOrganizationUserAccessToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a sign in link for an organization user
         * @param {string} user Unique identifier of the Flat account 
         * @param {UserSigninLinkCreation} userSigninLinkCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationUserSigninLink(user: string, userSigninLinkCreation: UserSigninLinkCreation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSigninLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationUserSigninLink(user, userSigninLinkCreation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.createOrganizationUserSigninLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List LTI 1.x credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLtiCredentials(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LtiCredentials>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLtiCredentials(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.listLtiCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List the organization invitations
         * @param {ListOrganizationInvitationsRoleEnum} [role] Filter users by role
         * @param {number} [limit] This is the maximum number of objects that may be returned
         * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationInvitations(role?: ListOrganizationInvitationsRoleEnum, limit?: number, next?: string, previous?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationInvitation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationInvitations(role, limit, next, previous, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.listOrganizationInvitations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List the organization users
         * @param {Array<ListOrganizationUsersSortEnum>} [sort] The order to sort the user list
         * @param {ListOrganizationUsersDirectionEnum} [direction] Sort direction
         * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {Array<ListOrganizationUsersRoleEnum>} [role] Filter users by role
         * @param {string} [q] The query to search
         * @param {Array<string>} [group] Filter users by group
         * @param {boolean} [noActiveLicense] Filter users who don\&#39;t have an active license
         * @param {Array<string>} [licenseExpirationDate] Filter users by license expiration date or &#x60;active&#x60; / &#x60;notActive&#x60;
         * @param {boolean} [onlyIds] Return only user ids
         * @param {number} [limit] This is the maximum number of objects that may be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationUsers(sort?: Array<ListOrganizationUsersSortEnum>, direction?: ListOrganizationUsersDirectionEnum, next?: string, previous?: string, role?: Array<ListOrganizationUsersRoleEnum>, q?: string, group?: Array<string>, noActiveLicense?: boolean, licenseExpirationDate?: Array<string>, onlyIds?: boolean, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDetailsAdmin>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationUsers(sort, direction, next, previous, role, q, group, noActiveLicense, licenseExpirationDate, onlyIds, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.listOrganizationUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove an organization invitation
         * @param {string} invitation Unique identifier of the invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOrganizationInvitation(invitation: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeOrganizationInvitation(invitation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.removeOrganizationInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This operation removes an account from Flat and its data, including: * The music scores created by this user (documents, history, comments, collaboration information) * Education related data (assignments and classroom information) 
         * @summary Remove an account from Flat
         * @param {string} user Unique identifier of the Flat account 
         * @param {boolean} [convertToIndividual] If &#x60;true&#x60;, the account will be only removed from the organization and converted into an individual account on our public website, https://flat.io. This operation will remove the education-related data from the account. Before realizing this operation, you need to be sure that the user is at least 13 years old and that this one has read and agreed to the Individual Terms of Services of Flat available on https://flat.io/legal. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOrganizationUser(user: string, convertToIndividual?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeOrganizationUser(user, convertToIndividual, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.removeOrganizationUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Revoke LTI 1.x credentials
         * @param {string} credentials Credentials unique identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeLtiCredentials(credentials: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeLtiCredentials(credentials, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.revokeLtiCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update account information
         * @param {string} user Unique identifier of the Flat account 
         * @param {UserAdminUpdate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationUser(user: string, body: UserAdminUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDetailsAdmin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationUser(user, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.updateOrganizationUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiFp(configuration)
    return {
        /**
         * 
         * @summary Count the organization users using the provided filters
         * @param {Array<CountOrgaUsersRoleEnum>} [role] Filter users by role
         * @param {string} [q] The query to search
         * @param {Array<string>} [group] Filter users by group
         * @param {boolean} [noActiveLicense] Filter users who don\&#39;t have an active license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countOrgaUsers(role?: Array<CountOrgaUsersRoleEnum>, q?: string, group?: Array<string>, noActiveLicense?: boolean, options?: any): AxiosPromise<Array<UserDetailsAdmin>> {
            return localVarFp.countOrgaUsers(role, q, group, noActiveLicense, options).then((request) => request(axios, basePath));
        },
        /**
         * Flat for Education is a Certified LTI Provider. You can use these API methods to automate the creation of LTI credentials. You can read more about our LTI implementation, supported components and LTI Endpoints in our [Developer Documentation](https://flat.io/developers/docs/lti/). 
         * @summary Create a new couple of LTI 1.x credentials
         * @param {LtiCredentialsCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLtiCredentials(body: LtiCredentialsCreation, options?: any): AxiosPromise<LtiCredentials> {
            return localVarFp.createLtiCredentials(body, options).then((request) => request(axios, basePath));
        },
        /**
         * This method creates and sends invitation for teachers and admins.  Invitations can only be used by new Flat users or users who are not part of the organization yet.  If the email of the user is already associated to a user of your organization, the API will simply update the role of the existing user and won\'t send an invitation. In this case, the property `usedBy` will be directly filled with the uniquer identifier of the corresponding user. 
         * @summary Create a new invitation to join the organization
         * @param {OrganizationInvitationCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationInvitation(body: OrganizationInvitationCreation, options?: any): AxiosPromise<OrganizationInvitation> {
            return localVarFp.createOrganizationInvitation(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new user account
         * @param {UserCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationUser(body: UserCreation, options?: any): AxiosPromise<UserDetailsAdmin> {
            return localVarFp.createOrganizationUser(body, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation will create an API access token for a chosen organization user. This token will be valid for a limited time and can be used to access the API as the organization user. 
         * @summary Create a delegated API access token for an organization user
         * @param {string} user Unique identifier of the Flat account 
         * @param {OrganizationUserAccessTokenCreation} organizationUserAccessTokenCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationUserAccessToken(user: string, organizationUserAccessTokenCreation: OrganizationUserAccessTokenCreation, options?: any): AxiosPromise<ApiAccessToken> {
            return localVarFp.createOrganizationUserAccessToken(user, organizationUserAccessTokenCreation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a sign in link for an organization user
         * @param {string} user Unique identifier of the Flat account 
         * @param {UserSigninLinkCreation} userSigninLinkCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationUserSigninLink(user: string, userSigninLinkCreation: UserSigninLinkCreation, options?: any): AxiosPromise<UserSigninLink> {
            return localVarFp.createOrganizationUserSigninLink(user, userSigninLinkCreation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List LTI 1.x credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLtiCredentials(options?: any): AxiosPromise<Array<LtiCredentials>> {
            return localVarFp.listLtiCredentials(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the organization invitations
         * @param {ListOrganizationInvitationsRoleEnum} [role] Filter users by role
         * @param {number} [limit] This is the maximum number of objects that may be returned
         * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationInvitations(role?: ListOrganizationInvitationsRoleEnum, limit?: number, next?: string, previous?: string, options?: any): AxiosPromise<Array<OrganizationInvitation>> {
            return localVarFp.listOrganizationInvitations(role, limit, next, previous, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the organization users
         * @param {Array<ListOrganizationUsersSortEnum>} [sort] The order to sort the user list
         * @param {ListOrganizationUsersDirectionEnum} [direction] Sort direction
         * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {Array<ListOrganizationUsersRoleEnum>} [role] Filter users by role
         * @param {string} [q] The query to search
         * @param {Array<string>} [group] Filter users by group
         * @param {boolean} [noActiveLicense] Filter users who don\&#39;t have an active license
         * @param {Array<string>} [licenseExpirationDate] Filter users by license expiration date or &#x60;active&#x60; / &#x60;notActive&#x60;
         * @param {boolean} [onlyIds] Return only user ids
         * @param {number} [limit] This is the maximum number of objects that may be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationUsers(sort?: Array<ListOrganizationUsersSortEnum>, direction?: ListOrganizationUsersDirectionEnum, next?: string, previous?: string, role?: Array<ListOrganizationUsersRoleEnum>, q?: string, group?: Array<string>, noActiveLicense?: boolean, licenseExpirationDate?: Array<string>, onlyIds?: boolean, limit?: number, options?: any): AxiosPromise<Array<UserDetailsAdmin>> {
            return localVarFp.listOrganizationUsers(sort, direction, next, previous, role, q, group, noActiveLicense, licenseExpirationDate, onlyIds, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an organization invitation
         * @param {string} invitation Unique identifier of the invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrganizationInvitation(invitation: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeOrganizationInvitation(invitation, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation removes an account from Flat and its data, including: * The music scores created by this user (documents, history, comments, collaboration information) * Education related data (assignments and classroom information) 
         * @summary Remove an account from Flat
         * @param {string} user Unique identifier of the Flat account 
         * @param {boolean} [convertToIndividual] If &#x60;true&#x60;, the account will be only removed from the organization and converted into an individual account on our public website, https://flat.io. This operation will remove the education-related data from the account. Before realizing this operation, you need to be sure that the user is at least 13 years old and that this one has read and agreed to the Individual Terms of Services of Flat available on https://flat.io/legal. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrganizationUser(user: string, convertToIndividual?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.removeOrganizationUser(user, convertToIndividual, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revoke LTI 1.x credentials
         * @param {string} credentials Credentials unique identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeLtiCredentials(credentials: string, options?: any): AxiosPromise<void> {
            return localVarFp.revokeLtiCredentials(credentials, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update account information
         * @param {string} user Unique identifier of the Flat account 
         * @param {UserAdminUpdate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationUser(user: string, body: UserAdminUpdate, options?: any): AxiosPromise<UserDetailsAdmin> {
            return localVarFp.updateOrganizationUser(user, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * 
     * @summary Count the organization users using the provided filters
     * @param {Array<CountOrgaUsersRoleEnum>} [role] Filter users by role
     * @param {string} [q] The query to search
     * @param {Array<string>} [group] Filter users by group
     * @param {boolean} [noActiveLicense] Filter users who don\&#39;t have an active license
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public countOrgaUsers(role?: Array<CountOrgaUsersRoleEnum>, q?: string, group?: Array<string>, noActiveLicense?: boolean, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).countOrgaUsers(role, q, group, noActiveLicense, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Flat for Education is a Certified LTI Provider. You can use these API methods to automate the creation of LTI credentials. You can read more about our LTI implementation, supported components and LTI Endpoints in our [Developer Documentation](https://flat.io/developers/docs/lti/). 
     * @summary Create a new couple of LTI 1.x credentials
     * @param {LtiCredentialsCreation} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public createLtiCredentials(body: LtiCredentialsCreation, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).createLtiCredentials(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method creates and sends invitation for teachers and admins.  Invitations can only be used by new Flat users or users who are not part of the organization yet.  If the email of the user is already associated to a user of your organization, the API will simply update the role of the existing user and won\'t send an invitation. In this case, the property `usedBy` will be directly filled with the uniquer identifier of the corresponding user. 
     * @summary Create a new invitation to join the organization
     * @param {OrganizationInvitationCreation} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public createOrganizationInvitation(body: OrganizationInvitationCreation, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).createOrganizationInvitation(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new user account
     * @param {UserCreation} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public createOrganizationUser(body: UserCreation, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).createOrganizationUser(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation will create an API access token for a chosen organization user. This token will be valid for a limited time and can be used to access the API as the organization user. 
     * @summary Create a delegated API access token for an organization user
     * @param {string} user Unique identifier of the Flat account 
     * @param {OrganizationUserAccessTokenCreation} organizationUserAccessTokenCreation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public createOrganizationUserAccessToken(user: string, organizationUserAccessTokenCreation: OrganizationUserAccessTokenCreation, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).createOrganizationUserAccessToken(user, organizationUserAccessTokenCreation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a sign in link for an organization user
     * @param {string} user Unique identifier of the Flat account 
     * @param {UserSigninLinkCreation} userSigninLinkCreation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public createOrganizationUserSigninLink(user: string, userSigninLinkCreation: UserSigninLinkCreation, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).createOrganizationUserSigninLink(user, userSigninLinkCreation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List LTI 1.x credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public listLtiCredentials(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).listLtiCredentials(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the organization invitations
     * @param {ListOrganizationInvitationsRoleEnum} [role] Filter users by role
     * @param {number} [limit] This is the maximum number of objects that may be returned
     * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
     * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public listOrganizationInvitations(role?: ListOrganizationInvitationsRoleEnum, limit?: number, next?: string, previous?: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).listOrganizationInvitations(role, limit, next, previous, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the organization users
     * @param {Array<ListOrganizationUsersSortEnum>} [sort] The order to sort the user list
     * @param {ListOrganizationUsersDirectionEnum} [direction] Sort direction
     * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
     * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
     * @param {Array<ListOrganizationUsersRoleEnum>} [role] Filter users by role
     * @param {string} [q] The query to search
     * @param {Array<string>} [group] Filter users by group
     * @param {boolean} [noActiveLicense] Filter users who don\&#39;t have an active license
     * @param {Array<string>} [licenseExpirationDate] Filter users by license expiration date or &#x60;active&#x60; / &#x60;notActive&#x60;
     * @param {boolean} [onlyIds] Return only user ids
     * @param {number} [limit] This is the maximum number of objects that may be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public listOrganizationUsers(sort?: Array<ListOrganizationUsersSortEnum>, direction?: ListOrganizationUsersDirectionEnum, next?: string, previous?: string, role?: Array<ListOrganizationUsersRoleEnum>, q?: string, group?: Array<string>, noActiveLicense?: boolean, licenseExpirationDate?: Array<string>, onlyIds?: boolean, limit?: number, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).listOrganizationUsers(sort, direction, next, previous, role, q, group, noActiveLicense, licenseExpirationDate, onlyIds, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an organization invitation
     * @param {string} invitation Unique identifier of the invitation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public removeOrganizationInvitation(invitation: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).removeOrganizationInvitation(invitation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation removes an account from Flat and its data, including: * The music scores created by this user (documents, history, comments, collaboration information) * Education related data (assignments and classroom information) 
     * @summary Remove an account from Flat
     * @param {string} user Unique identifier of the Flat account 
     * @param {boolean} [convertToIndividual] If &#x60;true&#x60;, the account will be only removed from the organization and converted into an individual account on our public website, https://flat.io. This operation will remove the education-related data from the account. Before realizing this operation, you need to be sure that the user is at least 13 years old and that this one has read and agreed to the Individual Terms of Services of Flat available on https://flat.io/legal. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public removeOrganizationUser(user: string, convertToIndividual?: boolean, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).removeOrganizationUser(user, convertToIndividual, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revoke LTI 1.x credentials
     * @param {string} credentials Credentials unique identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public revokeLtiCredentials(credentials: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).revokeLtiCredentials(credentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update account information
     * @param {string} user Unique identifier of the Flat account 
     * @param {UserAdminUpdate} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateOrganizationUser(user: string, body: UserAdminUpdate, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateOrganizationUser(user, body, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CountOrgaUsersRoleEnum = {
    User: 'user',
    Teacher: 'teacher',
    Admin: 'admin'
} as const;
export type CountOrgaUsersRoleEnum = typeof CountOrgaUsersRoleEnum[keyof typeof CountOrgaUsersRoleEnum];
/**
 * @export
 */
export const ListOrganizationInvitationsRoleEnum = {
    User: 'user',
    Teacher: 'teacher',
    Admin: 'admin'
} as const;
export type ListOrganizationInvitationsRoleEnum = typeof ListOrganizationInvitationsRoleEnum[keyof typeof ListOrganizationInvitationsRoleEnum];
/**
 * @export
 */
export const ListOrganizationUsersSortEnum = {
    Firstname: 'firstname',
    Lastname: 'lastname',
    LastActivityDate: 'lastActivityDate',
    LicenseExpirationDate: 'licenseExpirationDate'
} as const;
export type ListOrganizationUsersSortEnum = typeof ListOrganizationUsersSortEnum[keyof typeof ListOrganizationUsersSortEnum];
/**
 * @export
 */
export const ListOrganizationUsersDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ListOrganizationUsersDirectionEnum = typeof ListOrganizationUsersDirectionEnum[keyof typeof ListOrganizationUsersDirectionEnum];
/**
 * @export
 */
export const ListOrganizationUsersRoleEnum = {
    User: 'user',
    Teacher: 'teacher',
    Admin: 'admin'
} as const;
export type ListOrganizationUsersRoleEnum = typeof ListOrganizationUsersRoleEnum[keyof typeof ListOrganizationUsersRoleEnum];


/**
 * ScoreApi - axios parameter creator
 * @export
 */
export const ScoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Share a score with a single user or a group. This API call allows to add, invite and update the collaborators of a resource. - To add an existing Flat user to the resource, specify its unique identifier in the `user` property. - To invite an external user to the resource, specify its email in the `userEmail` property. - To add a Flat group to the resource, specify its unique identifier in the `group` property. - To update an existing collaborator, process the same request with different rights. 
         * @summary Add a new collaborator
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {ResourceCollaboratorCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addScoreCollaborator: async (score: string, body: ResourceCollaboratorCreation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('addScoreCollaborator', 'score', score)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('addScoreCollaborator', 'body', body)
            const localVarPath = `/scores/{score}/collaborators`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to add new track to the score. This track can then be played on flat.io or in an embedded score. This API method support medias hosted on SoundCloud, YouTube and Vimeo. 
         * @summary Add a new video or audio track to the score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {ScoreTrackCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addScoreTrack: async (score: string, body: ScoreTrackCreation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('addScoreTrack', 'score', score)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('addScoreTrack', 'body', body)
            const localVarPath = `/scores/{score}/tracks`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Some of the exports of a score takes are longer to process than a simple API requests. Use this endpoint to launch a new export of one score hosted on Flat. 
         * @summary Create a new score export task
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} revision Unique identifier of a score revision. You can use &#x60;last&#x60; to fetch the information related to the last version created. 
         * @param {CreateExportTaskFormatEnum} format The format of the file that will be generated or the target service name where the file will be exported
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {TaskExportOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExportTask: async (score: string, revision: string, format: CreateExportTaskFormatEnum, sharingKey?: string, body?: TaskExportOptions, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('createExportTask', 'score', score)
            // verify required parameter 'revision' is not null or undefined
            assertParamExists('createExportTask', 'revision', revision)
            // verify required parameter 'format' is not null or undefined
            assertParamExists('createExportTask', 'format', format)
            const localVarPath = `/scores/{score}/revisions/{revision}/{format}/task`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)))
                .replace(`{${"revision"}}`, encodeURIComponent(String(revision)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores", "scores.readonly"], configuration)

            if (sharingKey !== undefined) {
                localVarQueryParameter['sharingKey'] = sharingKey;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this API method to **create a new music score in the current User account**. This API endpoints provides 3 ways to create scores:  * `ScoreCreationBuilderData` : Create a blank score by providing the list of instruments to use. You can optionally customize the initial key signature, time signature, enable TABs, Chord grids, as well as the page layout. * `ScoreCreationFileImport`: Import an existing MusicXML 3 file (`vnd.recordare.musicxml` or `vnd.recordare.musicxml+xml`), a MIDI file (`audio/midi`), Guitar Pro (GP3, GP4, GP5, GPX, GP), PowerTab, TuxGuitar, or MuseScore file to create the new Flat document. * `ScoreCreationGoogleDriveImport`: Import an existing Google Drive file from the connected Google Drive account.  This API call will automatically create the first revision of the document, the score can be modified by the using our web application or by uploading a new revision of this file (`POST /v2/scores/{score}/revisions/{revision}`).  The currently authenticated user will be granted owner of the file and will be able to add other collaborators (users and groups).  If no `collection` is specified, the API will create the score in the most appropriate collection. When using an OAuth2 access token or a personal token, the score will be automatically added to your dedicated app collection in the account (`/v2/collections/app`).  If a `collection` is specified and this one has more public privacy settings than the score (e.g. `public` vs `private` for the score), the privacy settings of the created score will be adjusted to the collection ones.  You can check the adjusted privacy settings in the returned score `privacy`, and optionally adjust these settings if needed using `PUT /scores/{score}`. 
         * @summary Create a new score
         * @param {ScoreCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScore: async (body: ScoreCreation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createScore', 'body', body)
            const localVarPath = `/scores`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a score by uploading a new revision for this one. 
         * @summary Create a new revision
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {ScoreRevisionCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScoreRevision: async (score: string, body: ScoreRevisionCreation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('createScoreRevision', 'score', score)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createScoreRevision', 'body', body)
            const localVarPath = `/scores/{score}/revisions`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method can be used by the owner/admin (`aclAdmin` rights) of a score as well as regular collaborators.  When called by an owner/admin, it will schedule the deletion of the score, its revisions, and complete history. The score won\'t be accessible anymore after calling this method and the user\'s quota will directly be updated.  When called by a regular collaborator (`aclRead` / `aclWrite`), the score will be unshared (i.e. removed from the account & own collections). 
         * @summary Delete a score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {boolean} [now] If &#x60;true&#x60;, the score deletion will be scheduled to be done ASAP
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScore: async (score: string, now?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('deleteScore', 'score', score)
            const localVarPath = `/scores/{score}`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores"], configuration)

            if (now !== undefined) {
                localVarQueryParameter['now'] = now;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a comment
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} comment Unique identifier of a sheet music comment 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScoreComment: async (score: string, comment: string, sharingKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('deleteScoreComment', 'score', score)
            // verify required parameter 'comment' is not null or undefined
            assertParamExists('deleteScoreComment', 'comment', comment)
            const localVarPath = `/scores/{score}/comments/{comment}`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)))
                .replace(`{${"comment"}}`, encodeURIComponent(String(comment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores.social", "scores"], configuration)

            if (sharingKey !== undefined) {
                localVarQueryParameter['sharingKey'] = sharingKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an audio or video track linked to the score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} track Unique identifier of a score audio track 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScoreTrack: async (score: string, track: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('deleteScoreTrack', 'score', score)
            // verify required parameter 'track' is not null or undefined
            assertParamExists('deleteScoreTrack', 'track', track)
            const localVarPath = `/scores/{score}/tracks/{track}`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)))
                .replace(`{${"track"}}`, encodeURIComponent(String(track)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API method allows you to change the metadata of a score document (e.g. its `title` or `privacy`), all the properties are optional.  To edit the file itself, create a new revision using the appropriate method (`POST /v2/scores/{score}/revisions/{revision}`).  When editing the `title`, `subtitle`, `composer`, `lyricist`, `arranger` or `licenseText`, the metadatas will be instantly be updated, and a real-time action will be pushed to update the document lazily. This pending document modification will be automatically be saved as a new version by either a connected client or our internal versioning service. 
         * @summary Edit a score\'s metadata
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {ScoreModification} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editScore: async (score: string, body: ScoreModification, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('editScore', 'score', score)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('editScore', 'body', body)
            const localVarPath = `/scores/{score}`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API call will make a copy of the last revision of the specified score and create a new score. The copy of the score will have a privacy set to `private`.  When using a [Flat for Education](https://flat.io/edu) account, the inline and contextualized comments will be accessible in the child document. 
         * @summary Fork a score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {ScoreFork} body 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forkScore: async (score: string, body: ScoreFork, sharingKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('forkScore', 'score', score)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('forkScore', 'body', body)
            const localVarPath = `/scores/{score}/fork`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores"], configuration)

            if (sharingKey !== undefined) {
                localVarQueryParameter['sharingKey'] = sharingKey;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of scores shared with a group. 
         * @summary List group\'s scores
         * @param {string} group Unique identifier of a Flat group 
         * @param {string} [parent] Filter the score forked from the score id &#x60;parent&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupScores: async (group: string, parent?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('getGroupScores', 'group', group)
            const localVarPath = `/groups/{group}/scores`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores", "scores.readonly"], configuration)

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the details of a score identified by the `score` parameter in the URL. The currently authenticated user must have at least a read access to the document to use this API call. 
         * @summary Get a score\'s metadata
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScore: async (score: string, sharingKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('getScore', 'score', score)
            const localVarPath = `/scores/{score}`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores", "scores.readonly"], configuration)

            if (sharingKey !== undefined) {
                localVarQueryParameter['sharingKey'] = sharingKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the information about a collaborator (User or Group). 
         * @summary Get a collaborator
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} collaborator Unique identifier of a **collaborator permission**, or unique identifier of a **User**, or unique identifier of a **Group** 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoreCollaborator: async (score: string, collaborator: string, sharingKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('getScoreCollaborator', 'score', score)
            // verify required parameter 'collaborator' is not null or undefined
            assertParamExists('getScoreCollaborator', 'collaborator', collaborator)
            const localVarPath = `/scores/{score}/collaborators/{collaborator}`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)))
                .replace(`{${"collaborator"}}`, encodeURIComponent(String(collaborator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores.readonly"], configuration)

            if (sharingKey !== undefined) {
                localVarQueryParameter['sharingKey'] = sharingKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API call will list the different collaborators of a score and their rights on the document. The returned list will at least contain the owner of the document.  Collaborators can be a single user (the object `user` will be populated) or a group (the object `group` will be populated). 
         * @summary List the collaborators
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoreCollaborators: async (score: string, sharingKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('getScoreCollaborators', 'score', score)
            const localVarPath = `/scores/{score}/collaborators`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores.readonly", "scores"], configuration)

            if (sharingKey !== undefined) {
                localVarQueryParameter['sharingKey'] = sharingKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method lists the different comments added on a music score (documents and inline) sorted by their post dates.
         * @summary List comments
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {GetScoreCommentsTypeEnum} [type] Filter the comments by type
         * @param {GetScoreCommentsSortEnum} [sort] Sort
         * @param {GetScoreCommentsDirectionEnum} [direction] Sort direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoreComments: async (score: string, sharingKey?: string, type?: GetScoreCommentsTypeEnum, sort?: GetScoreCommentsSortEnum, direction?: GetScoreCommentsDirectionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('getScoreComments', 'score', score)
            const localVarPath = `/scores/{score}/comments`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores.readonly", "scores.social", "scores"], configuration)

            if (sharingKey !== undefined) {
                localVarQueryParameter['sharingKey'] = sharingKey;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When creating a score or saving a new version of a score, a revision is created in our storage. This method allows you to get a specific revision metadata. 
         * @summary Get a score revision
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} revision Unique identifier of a score revision. You can use &#x60;last&#x60; to fetch the information related to the last version created. 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoreRevision: async (score: string, revision: string, sharingKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('getScoreRevision', 'score', score)
            // verify required parameter 'revision' is not null or undefined
            assertParamExists('getScoreRevision', 'revision', revision)
            const localVarPath = `/scores/{score}/revisions/{revision}`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)))
                .replace(`{${"revision"}}`, encodeURIComponent(String(revision)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores", "scores.readonly"], configuration)

            if (sharingKey !== undefined) {
                localVarQueryParameter['sharingKey'] = sharingKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the file corresponding to a score revision (the following formats are available): Flat JSON/Adagio JSON `json`, MusicXML `mxl`/`xml`, MP3 `mp3`, WAV `wav`, MIDI `midi`, a tumbnail of the first page `thumbnail.png` or auto sync points `synchronizationPoints`. 
         * @summary Get a score revision data
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} revision Unique identifier of a score revision. You can use &#x60;last&#x60; to fetch the information related to the last version created. 
         * @param {GetScoreRevisionDataFormatEnum} format The format of the file you will retrieve
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {string} [parts] An optional a set of parts uuid to be exported. This parameter must be composed of parts uuids separated by commas. For example \&quot;59df645f-bb1c-f1b4-b573-d2afc4491f94,34ef645f-1aef-f3bc-1564-34cca4492b87\&quot;. 
         * @param {boolean} [defaultTrack] When &#x60;format&#x60; is &#x60;mp3&#x60;, this property is set to true and the score has a default &#x60;ScoreTrack&#x60; (mp3), this one will be returned instead of the playback file. 
         * @param {boolean} [url] Returns a json with the &#x60;url&#x60; in it instead of redirecting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoreRevisionData: async (score: string, revision: string, format: GetScoreRevisionDataFormatEnum, sharingKey?: string, parts?: string, defaultTrack?: boolean, url?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('getScoreRevisionData', 'score', score)
            // verify required parameter 'revision' is not null or undefined
            assertParamExists('getScoreRevisionData', 'revision', revision)
            // verify required parameter 'format' is not null or undefined
            assertParamExists('getScoreRevisionData', 'format', format)
            const localVarPath = `/scores/{score}/revisions/{revision}/{format}`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)))
                .replace(`{${"revision"}}`, encodeURIComponent(String(revision)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores", "scores.readonly"], configuration)

            if (sharingKey !== undefined) {
                localVarQueryParameter['sharingKey'] = sharingKey;
            }

            if (parts !== undefined) {
                localVarQueryParameter['parts'] = parts;
            }

            if (defaultTrack !== undefined) {
                localVarQueryParameter['defaultTrack'] = defaultTrack;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When creating a score or saving a new version of a score, a revision is created in our storage. This method allows you to list all of them, sorted by last modification.  Depending the plan of the account, this list can be trunked to the few last revisions. 
         * @summary List the revisions
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoreRevisions: async (score: string, sharingKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('getScoreRevisions', 'score', score)
            const localVarPath = `/scores/{score}/revisions`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores", "scores.readonly"], configuration)

            if (sharingKey !== undefined) {
                localVarQueryParameter['sharingKey'] = sharingKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API call will list the different assignments submissions where the score is attached. This method can be used by anyone that are part of the organization and have at least read access to the document. 
         * @summary List submissions related to the score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoreSubmissions: async (score: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('getScoreSubmissions', 'score', score)
            const localVarPath = `/scores/{score}/submissions`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores", "scores.readonly"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the details of an audio or video track linked to a score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} track Unique identifier of a score audio track 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoreTrack: async (score: string, track: string, sharingKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('getScoreTrack', 'score', score)
            // verify required parameter 'track' is not null or undefined
            assertParamExists('getScoreTrack', 'track', track)
            const localVarPath = `/scores/{score}/tracks/{track}`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)))
                .replace(`{${"track"}}`, encodeURIComponent(String(track)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores", "scores.readonly"], configuration)

            if (sharingKey !== undefined) {
                localVarQueryParameter['sharingKey'] = sharingKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List liked scores
         * @param {string} user Unique identifier of a Flat user. If you authenticated, you can use &#x60;me&#x60; to refer to the current user. 
         * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {number} [limit] This is the maximum number of objects that may be returned
         * @param {boolean} [ids] Return only the identifiers of the scores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserLikes: async (user: string, next?: string, previous?: string, limit?: number, ids?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getUserLikes', 'user', user)
            const localVarPath = `/users/{user}/likes`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["account.public_profile"], configuration)

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (previous !== undefined) {
                localVarQueryParameter['previous'] = previous;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of public scores owned by a User.  **DEPRECATED**: Please note that the current behavior will be deprecrated on **2019-01-01**. This method will no longer list private and shared scores, but only public scores of a Flat account. If you want to access to private scores, please use the [Collections API](#tag/Collection) instead. 
         * @summary List user\'s scores
         * @param {string} user Unique identifier of a Flat user. If you authenticated, you can use &#x60;me&#x60; to refer to the current user. 
         * @param {string} [parent] Filter the score forked from the score id &#x60;parent&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserScores: async (user: string, parent?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getUserScores', 'user', user)
            const localVarPath = `/users/{user}/scores`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores", "scores.readonly"], configuration)

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the audio or video tracks linked to a score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {string} [assignment] An assignment id with which all the tracks returned will be related to 
         * @param {boolean} [listAutoTrack] If true, and if available, return last automatically synchronized Flat\&#39;s mp3 export as an additional track 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScoreTracks: async (score: string, sharingKey?: string, assignment?: string, listAutoTrack?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('listScoreTracks', 'score', score)
            const localVarPath = `/scores/{score}/tracks`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores", "scores.readonly"], configuration)

            if (sharingKey !== undefined) {
                localVarQueryParameter['sharingKey'] = sharingKey;
            }

            if (assignment !== undefined) {
                localVarQueryParameter['assignment'] = assignment;
            }

            if (listAutoTrack !== undefined) {
                localVarQueryParameter['listAutoTrack'] = listAutoTrack;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark the comment as resolved
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} comment Unique identifier of a sheet music comment 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markScoreCommentResolved: async (score: string, comment: string, sharingKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('markScoreCommentResolved', 'score', score)
            // verify required parameter 'comment' is not null or undefined
            assertParamExists('markScoreCommentResolved', 'comment', comment)
            const localVarPath = `/scores/{score}/comments/{comment}/resolved`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)))
                .replace(`{${"comment"}}`, encodeURIComponent(String(comment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores.social", "scores"], configuration)

            if (sharingKey !== undefined) {
                localVarQueryParameter['sharingKey'] = sharingKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark the comment as unresolved
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} comment Unique identifier of a sheet music comment 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markScoreCommentUnresolved: async (score: string, comment: string, sharingKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('markScoreCommentUnresolved', 'score', score)
            // verify required parameter 'comment' is not null or undefined
            assertParamExists('markScoreCommentUnresolved', 'comment', comment)
            const localVarPath = `/scores/{score}/comments/{comment}/resolved`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)))
                .replace(`{${"comment"}}`, encodeURIComponent(String(comment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores.social", "scores"], configuration)

            if (sharingKey !== undefined) {
                localVarQueryParameter['sharingKey'] = sharingKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post a document or a contextualized comment on a document.  Please note that this method includes an anti-spam system for public scores. We don\'t guarantee that your comments will be accepted and displayed to end-user. Comments are be blocked by returning a `403` HTTP error and hidden from other users when the `spam` property is `true`. 
         * @summary Post a new comment
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {ScoreCommentCreation} body 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScoreComment: async (score: string, body: ScoreCommentCreation, sharingKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('postScoreComment', 'score', score)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postScoreComment', 'body', body)
            const localVarPath = `/scores/{score}/comments`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores.social", "scores"], configuration)

            if (sharingKey !== undefined) {
                localVarQueryParameter['sharingKey'] = sharingKey;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove the specified collaborator from the score 
         * @summary Delete a collaborator
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} collaborator Unique identifier of a **collaborator permission**, or unique identifier of a **User**, or unique identifier of a **Group** 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeScoreCollaborator: async (score: string, collaborator: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('removeScoreCollaborator', 'score', score)
            // verify required parameter 'collaborator' is not null or undefined
            assertParamExists('removeScoreCollaborator', 'collaborator', collaborator)
            const localVarPath = `/scores/{score}/collaborators/{collaborator}`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)))
                .replace(`{${"collaborator"}}`, encodeURIComponent(String(collaborator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method will remove the score from the `trash` collection and from the deletion queue, and add it back to the original collections. 
         * @summary Untrash a score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        untrashScore: async (score: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('untrashScore', 'score', score)
            const localVarPath = `/scores/{score}/untrash`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing comment
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} comment Unique identifier of a sheet music comment 
         * @param {ScoreCommentUpdate} body 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScoreComment: async (score: string, comment: string, body: ScoreCommentUpdate, sharingKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('updateScoreComment', 'score', score)
            // verify required parameter 'comment' is not null or undefined
            assertParamExists('updateScoreComment', 'comment', comment)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateScoreComment', 'body', body)
            const localVarPath = `/scores/{score}/comments/{comment}`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)))
                .replace(`{${"comment"}}`, encodeURIComponent(String(comment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores.social", "scores"], configuration)

            if (sharingKey !== undefined) {
                localVarQueryParameter['sharingKey'] = sharingKey;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an audio or video track linked to a score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} track Unique identifier of a score audio track 
         * @param {ScoreTrackUpdate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScoreTrack: async (score: string, track: string, body: ScoreTrackUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'score' is not null or undefined
            assertParamExists('updateScoreTrack', 'score', score)
            // verify required parameter 'track' is not null or undefined
            assertParamExists('updateScoreTrack', 'track', track)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateScoreTrack', 'body', body)
            const localVarPath = `/scores/{score}/tracks/{track}`
                .replace(`{${"score"}}`, encodeURIComponent(String(score)))
                .replace(`{${"track"}}`, encodeURIComponent(String(track)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScoreApi - functional programming interface
 * @export
 */
export const ScoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScoreApiAxiosParamCreator(configuration)
    return {
        /**
         * Share a score with a single user or a group. This API call allows to add, invite and update the collaborators of a resource. - To add an existing Flat user to the resource, specify its unique identifier in the `user` property. - To invite an external user to the resource, specify its email in the `userEmail` property. - To add a Flat group to the resource, specify its unique identifier in the `group` property. - To update an existing collaborator, process the same request with different rights. 
         * @summary Add a new collaborator
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {ResourceCollaboratorCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addScoreCollaborator(score: string, body: ResourceCollaboratorCreation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceCollaborator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addScoreCollaborator(score, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.addScoreCollaborator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this method to add new track to the score. This track can then be played on flat.io or in an embedded score. This API method support medias hosted on SoundCloud, YouTube and Vimeo. 
         * @summary Add a new video or audio track to the score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {ScoreTrackCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addScoreTrack(score: string, body: ScoreTrackCreation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScoreTrack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addScoreTrack(score, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.addScoreTrack']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Some of the exports of a score takes are longer to process than a simple API requests. Use this endpoint to launch a new export of one score hosted on Flat. 
         * @summary Create a new score export task
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} revision Unique identifier of a score revision. You can use &#x60;last&#x60; to fetch the information related to the last version created. 
         * @param {CreateExportTaskFormatEnum} format The format of the file that will be generated or the target service name where the file will be exported
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {TaskExportOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExportTask(score: string, revision: string, format: CreateExportTaskFormatEnum, sharingKey?: string, body?: TaskExportOptions, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExportTask(score, revision, format, sharingKey, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.createExportTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this API method to **create a new music score in the current User account**. This API endpoints provides 3 ways to create scores:  * `ScoreCreationBuilderData` : Create a blank score by providing the list of instruments to use. You can optionally customize the initial key signature, time signature, enable TABs, Chord grids, as well as the page layout. * `ScoreCreationFileImport`: Import an existing MusicXML 3 file (`vnd.recordare.musicxml` or `vnd.recordare.musicxml+xml`), a MIDI file (`audio/midi`), Guitar Pro (GP3, GP4, GP5, GPX, GP), PowerTab, TuxGuitar, or MuseScore file to create the new Flat document. * `ScoreCreationGoogleDriveImport`: Import an existing Google Drive file from the connected Google Drive account.  This API call will automatically create the first revision of the document, the score can be modified by the using our web application or by uploading a new revision of this file (`POST /v2/scores/{score}/revisions/{revision}`).  The currently authenticated user will be granted owner of the file and will be able to add other collaborators (users and groups).  If no `collection` is specified, the API will create the score in the most appropriate collection. When using an OAuth2 access token or a personal token, the score will be automatically added to your dedicated app collection in the account (`/v2/collections/app`).  If a `collection` is specified and this one has more public privacy settings than the score (e.g. `public` vs `private` for the score), the privacy settings of the created score will be adjusted to the collection ones.  You can check the adjusted privacy settings in the returned score `privacy`, and optionally adjust these settings if needed using `PUT /scores/{score}`. 
         * @summary Create a new score
         * @param {ScoreCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScore(body: ScoreCreation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScoreDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScore(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.createScore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a score by uploading a new revision for this one. 
         * @summary Create a new revision
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {ScoreRevisionCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScoreRevision(score: string, body: ScoreRevisionCreation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScoreRevision>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScoreRevision(score, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.createScoreRevision']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method can be used by the owner/admin (`aclAdmin` rights) of a score as well as regular collaborators.  When called by an owner/admin, it will schedule the deletion of the score, its revisions, and complete history. The score won\'t be accessible anymore after calling this method and the user\'s quota will directly be updated.  When called by a regular collaborator (`aclRead` / `aclWrite`), the score will be unshared (i.e. removed from the account & own collections). 
         * @summary Delete a score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {boolean} [now] If &#x60;true&#x60;, the score deletion will be scheduled to be done ASAP
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScore(score: string, now?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScore(score, now, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.deleteScore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a comment
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} comment Unique identifier of a sheet music comment 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScoreComment(score: string, comment: string, sharingKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScoreComment(score, comment, sharingKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.deleteScoreComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove an audio or video track linked to the score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} track Unique identifier of a score audio track 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScoreTrack(score: string, track: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScoreTrack(score, track, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.deleteScoreTrack']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API method allows you to change the metadata of a score document (e.g. its `title` or `privacy`), all the properties are optional.  To edit the file itself, create a new revision using the appropriate method (`POST /v2/scores/{score}/revisions/{revision}`).  When editing the `title`, `subtitle`, `composer`, `lyricist`, `arranger` or `licenseText`, the metadatas will be instantly be updated, and a real-time action will be pushed to update the document lazily. This pending document modification will be automatically be saved as a new version by either a connected client or our internal versioning service. 
         * @summary Edit a score\'s metadata
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {ScoreModification} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editScore(score: string, body: ScoreModification, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScoreDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editScore(score, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.editScore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API call will make a copy of the last revision of the specified score and create a new score. The copy of the score will have a privacy set to `private`.  When using a [Flat for Education](https://flat.io/edu) account, the inline and contextualized comments will be accessible in the child document. 
         * @summary Fork a score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {ScoreFork} body 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forkScore(score: string, body: ScoreFork, sharingKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScoreDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forkScore(score, body, sharingKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.forkScore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the list of scores shared with a group. 
         * @summary List group\'s scores
         * @param {string} group Unique identifier of a Flat group 
         * @param {string} [parent] Filter the score forked from the score id &#x60;parent&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupScores(group: string, parent?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScoreDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupScores(group, parent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.getGroupScores']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the details of a score identified by the `score` parameter in the URL. The currently authenticated user must have at least a read access to the document to use this API call. 
         * @summary Get a score\'s metadata
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScore(score: string, sharingKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScoreDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScore(score, sharingKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.getScore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the information about a collaborator (User or Group). 
         * @summary Get a collaborator
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} collaborator Unique identifier of a **collaborator permission**, or unique identifier of a **User**, or unique identifier of a **Group** 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScoreCollaborator(score: string, collaborator: string, sharingKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceCollaborator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScoreCollaborator(score, collaborator, sharingKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.getScoreCollaborator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API call will list the different collaborators of a score and their rights on the document. The returned list will at least contain the owner of the document.  Collaborators can be a single user (the object `user` will be populated) or a group (the object `group` will be populated). 
         * @summary List the collaborators
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScoreCollaborators(score: string, sharingKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceCollaborator>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScoreCollaborators(score, sharingKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.getScoreCollaborators']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method lists the different comments added on a music score (documents and inline) sorted by their post dates.
         * @summary List comments
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {GetScoreCommentsTypeEnum} [type] Filter the comments by type
         * @param {GetScoreCommentsSortEnum} [sort] Sort
         * @param {GetScoreCommentsDirectionEnum} [direction] Sort direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScoreComments(score: string, sharingKey?: string, type?: GetScoreCommentsTypeEnum, sort?: GetScoreCommentsSortEnum, direction?: GetScoreCommentsDirectionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScoreComment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScoreComments(score, sharingKey, type, sort, direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.getScoreComments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * When creating a score or saving a new version of a score, a revision is created in our storage. This method allows you to get a specific revision metadata. 
         * @summary Get a score revision
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} revision Unique identifier of a score revision. You can use &#x60;last&#x60; to fetch the information related to the last version created. 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScoreRevision(score: string, revision: string, sharingKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScoreRevision>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScoreRevision(score, revision, sharingKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.getScoreRevision']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the file corresponding to a score revision (the following formats are available): Flat JSON/Adagio JSON `json`, MusicXML `mxl`/`xml`, MP3 `mp3`, WAV `wav`, MIDI `midi`, a tumbnail of the first page `thumbnail.png` or auto sync points `synchronizationPoints`. 
         * @summary Get a score revision data
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} revision Unique identifier of a score revision. You can use &#x60;last&#x60; to fetch the information related to the last version created. 
         * @param {GetScoreRevisionDataFormatEnum} format The format of the file you will retrieve
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {string} [parts] An optional a set of parts uuid to be exported. This parameter must be composed of parts uuids separated by commas. For example \&quot;59df645f-bb1c-f1b4-b573-d2afc4491f94,34ef645f-1aef-f3bc-1564-34cca4492b87\&quot;. 
         * @param {boolean} [defaultTrack] When &#x60;format&#x60; is &#x60;mp3&#x60;, this property is set to true and the score has a default &#x60;ScoreTrack&#x60; (mp3), this one will be returned instead of the playback file. 
         * @param {boolean} [url] Returns a json with the &#x60;url&#x60; in it instead of redirecting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScoreRevisionData(score: string, revision: string, format: GetScoreRevisionDataFormatEnum, sharingKey?: string, parts?: string, defaultTrack?: boolean, url?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScoreRevisionData(score, revision, format, sharingKey, parts, defaultTrack, url, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.getScoreRevisionData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * When creating a score or saving a new version of a score, a revision is created in our storage. This method allows you to list all of them, sorted by last modification.  Depending the plan of the account, this list can be trunked to the few last revisions. 
         * @summary List the revisions
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScoreRevisions(score: string, sharingKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScoreRevision>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScoreRevisions(score, sharingKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.getScoreRevisions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API call will list the different assignments submissions where the score is attached. This method can be used by anyone that are part of the organization and have at least read access to the document. 
         * @summary List submissions related to the score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScoreSubmissions(score: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssignmentSubmission>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScoreSubmissions(score, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.getScoreSubmissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the details of an audio or video track linked to a score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} track Unique identifier of a score audio track 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScoreTrack(score: string, track: string, sharingKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScoreTrack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScoreTrack(score, track, sharingKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.getScoreTrack']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List liked scores
         * @param {string} user Unique identifier of a Flat user. If you authenticated, you can use &#x60;me&#x60; to refer to the current user. 
         * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {number} [limit] This is the maximum number of objects that may be returned
         * @param {boolean} [ids] Return only the identifiers of the scores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserLikes(user: string, next?: string, previous?: string, limit?: number, ids?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScoreDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserLikes(user, next, previous, limit, ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.getUserLikes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the list of public scores owned by a User.  **DEPRECATED**: Please note that the current behavior will be deprecrated on **2019-01-01**. This method will no longer list private and shared scores, but only public scores of a Flat account. If you want to access to private scores, please use the [Collections API](#tag/Collection) instead. 
         * @summary List user\'s scores
         * @param {string} user Unique identifier of a Flat user. If you authenticated, you can use &#x60;me&#x60; to refer to the current user. 
         * @param {string} [parent] Filter the score forked from the score id &#x60;parent&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserScores(user: string, parent?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScoreDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserScores(user, parent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.getUserScores']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List the audio or video tracks linked to a score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {string} [assignment] An assignment id with which all the tracks returned will be related to 
         * @param {boolean} [listAutoTrack] If true, and if available, return last automatically synchronized Flat\&#39;s mp3 export as an additional track 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScoreTracks(score: string, sharingKey?: string, assignment?: string, listAutoTrack?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScoreTrack>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScoreTracks(score, sharingKey, assignment, listAutoTrack, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.listScoreTracks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Mark the comment as resolved
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} comment Unique identifier of a sheet music comment 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markScoreCommentResolved(score: string, comment: string, sharingKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markScoreCommentResolved(score, comment, sharingKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.markScoreCommentResolved']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Mark the comment as unresolved
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} comment Unique identifier of a sheet music comment 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markScoreCommentUnresolved(score: string, comment: string, sharingKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markScoreCommentUnresolved(score, comment, sharingKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.markScoreCommentUnresolved']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Post a document or a contextualized comment on a document.  Please note that this method includes an anti-spam system for public scores. We don\'t guarantee that your comments will be accepted and displayed to end-user. Comments are be blocked by returning a `403` HTTP error and hidden from other users when the `spam` property is `true`. 
         * @summary Post a new comment
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {ScoreCommentCreation} body 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postScoreComment(score: string, body: ScoreCommentCreation, sharingKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScoreComment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postScoreComment(score, body, sharingKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.postScoreComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove the specified collaborator from the score 
         * @summary Delete a collaborator
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} collaborator Unique identifier of a **collaborator permission**, or unique identifier of a **User**, or unique identifier of a **Group** 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeScoreCollaborator(score: string, collaborator: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeScoreCollaborator(score, collaborator, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.removeScoreCollaborator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method will remove the score from the `trash` collection and from the deletion queue, and add it back to the original collections. 
         * @summary Untrash a score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async untrashScore(score: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.untrashScore(score, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.untrashScore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing comment
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} comment Unique identifier of a sheet music comment 
         * @param {ScoreCommentUpdate} body 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateScoreComment(score: string, comment: string, body: ScoreCommentUpdate, sharingKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScoreComment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScoreComment(score, comment, body, sharingKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.updateScoreComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an audio or video track linked to a score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} track Unique identifier of a score audio track 
         * @param {ScoreTrackUpdate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateScoreTrack(score: string, track: string, body: ScoreTrackUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScoreTrack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScoreTrack(score, track, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoreApi.updateScoreTrack']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ScoreApi - factory interface
 * @export
 */
export const ScoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScoreApiFp(configuration)
    return {
        /**
         * Share a score with a single user or a group. This API call allows to add, invite and update the collaborators of a resource. - To add an existing Flat user to the resource, specify its unique identifier in the `user` property. - To invite an external user to the resource, specify its email in the `userEmail` property. - To add a Flat group to the resource, specify its unique identifier in the `group` property. - To update an existing collaborator, process the same request with different rights. 
         * @summary Add a new collaborator
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {ResourceCollaboratorCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addScoreCollaborator(score: string, body: ResourceCollaboratorCreation, options?: any): AxiosPromise<ResourceCollaborator> {
            return localVarFp.addScoreCollaborator(score, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to add new track to the score. This track can then be played on flat.io or in an embedded score. This API method support medias hosted on SoundCloud, YouTube and Vimeo. 
         * @summary Add a new video or audio track to the score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {ScoreTrackCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addScoreTrack(score: string, body: ScoreTrackCreation, options?: any): AxiosPromise<ScoreTrack> {
            return localVarFp.addScoreTrack(score, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Some of the exports of a score takes are longer to process than a simple API requests. Use this endpoint to launch a new export of one score hosted on Flat. 
         * @summary Create a new score export task
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} revision Unique identifier of a score revision. You can use &#x60;last&#x60; to fetch the information related to the last version created. 
         * @param {CreateExportTaskFormatEnum} format The format of the file that will be generated or the target service name where the file will be exported
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {TaskExportOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExportTask(score: string, revision: string, format: CreateExportTaskFormatEnum, sharingKey?: string, body?: TaskExportOptions, options?: any): AxiosPromise<Task> {
            return localVarFp.createExportTask(score, revision, format, sharingKey, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this API method to **create a new music score in the current User account**. This API endpoints provides 3 ways to create scores:  * `ScoreCreationBuilderData` : Create a blank score by providing the list of instruments to use. You can optionally customize the initial key signature, time signature, enable TABs, Chord grids, as well as the page layout. * `ScoreCreationFileImport`: Import an existing MusicXML 3 file (`vnd.recordare.musicxml` or `vnd.recordare.musicxml+xml`), a MIDI file (`audio/midi`), Guitar Pro (GP3, GP4, GP5, GPX, GP), PowerTab, TuxGuitar, or MuseScore file to create the new Flat document. * `ScoreCreationGoogleDriveImport`: Import an existing Google Drive file from the connected Google Drive account.  This API call will automatically create the first revision of the document, the score can be modified by the using our web application or by uploading a new revision of this file (`POST /v2/scores/{score}/revisions/{revision}`).  The currently authenticated user will be granted owner of the file and will be able to add other collaborators (users and groups).  If no `collection` is specified, the API will create the score in the most appropriate collection. When using an OAuth2 access token or a personal token, the score will be automatically added to your dedicated app collection in the account (`/v2/collections/app`).  If a `collection` is specified and this one has more public privacy settings than the score (e.g. `public` vs `private` for the score), the privacy settings of the created score will be adjusted to the collection ones.  You can check the adjusted privacy settings in the returned score `privacy`, and optionally adjust these settings if needed using `PUT /scores/{score}`. 
         * @summary Create a new score
         * @param {ScoreCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScore(body: ScoreCreation, options?: any): AxiosPromise<ScoreDetails> {
            return localVarFp.createScore(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a score by uploading a new revision for this one. 
         * @summary Create a new revision
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {ScoreRevisionCreation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScoreRevision(score: string, body: ScoreRevisionCreation, options?: any): AxiosPromise<ScoreRevision> {
            return localVarFp.createScoreRevision(score, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This method can be used by the owner/admin (`aclAdmin` rights) of a score as well as regular collaborators.  When called by an owner/admin, it will schedule the deletion of the score, its revisions, and complete history. The score won\'t be accessible anymore after calling this method and the user\'s quota will directly be updated.  When called by a regular collaborator (`aclRead` / `aclWrite`), the score will be unshared (i.e. removed from the account & own collections). 
         * @summary Delete a score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {boolean} [now] If &#x60;true&#x60;, the score deletion will be scheduled to be done ASAP
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScore(score: string, now?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteScore(score, now, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a comment
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} comment Unique identifier of a sheet music comment 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScoreComment(score: string, comment: string, sharingKey?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteScoreComment(score, comment, sharingKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an audio or video track linked to the score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} track Unique identifier of a score audio track 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScoreTrack(score: string, track: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteScoreTrack(score, track, options).then((request) => request(axios, basePath));
        },
        /**
         * This API method allows you to change the metadata of a score document (e.g. its `title` or `privacy`), all the properties are optional.  To edit the file itself, create a new revision using the appropriate method (`POST /v2/scores/{score}/revisions/{revision}`).  When editing the `title`, `subtitle`, `composer`, `lyricist`, `arranger` or `licenseText`, the metadatas will be instantly be updated, and a real-time action will be pushed to update the document lazily. This pending document modification will be automatically be saved as a new version by either a connected client or our internal versioning service. 
         * @summary Edit a score\'s metadata
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {ScoreModification} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editScore(score: string, body: ScoreModification, options?: any): AxiosPromise<ScoreDetails> {
            return localVarFp.editScore(score, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This API call will make a copy of the last revision of the specified score and create a new score. The copy of the score will have a privacy set to `private`.  When using a [Flat for Education](https://flat.io/edu) account, the inline and contextualized comments will be accessible in the child document. 
         * @summary Fork a score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {ScoreFork} body 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forkScore(score: string, body: ScoreFork, sharingKey?: string, options?: any): AxiosPromise<ScoreDetails> {
            return localVarFp.forkScore(score, body, sharingKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of scores shared with a group. 
         * @summary List group\'s scores
         * @param {string} group Unique identifier of a Flat group 
         * @param {string} [parent] Filter the score forked from the score id &#x60;parent&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupScores(group: string, parent?: string, options?: any): AxiosPromise<Array<ScoreDetails>> {
            return localVarFp.getGroupScores(group, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the details of a score identified by the `score` parameter in the URL. The currently authenticated user must have at least a read access to the document to use this API call. 
         * @summary Get a score\'s metadata
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScore(score: string, sharingKey?: string, options?: any): AxiosPromise<ScoreDetails> {
            return localVarFp.getScore(score, sharingKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the information about a collaborator (User or Group). 
         * @summary Get a collaborator
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} collaborator Unique identifier of a **collaborator permission**, or unique identifier of a **User**, or unique identifier of a **Group** 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoreCollaborator(score: string, collaborator: string, sharingKey?: string, options?: any): AxiosPromise<ResourceCollaborator> {
            return localVarFp.getScoreCollaborator(score, collaborator, sharingKey, options).then((request) => request(axios, basePath));
        },
        /**
         * This API call will list the different collaborators of a score and their rights on the document. The returned list will at least contain the owner of the document.  Collaborators can be a single user (the object `user` will be populated) or a group (the object `group` will be populated). 
         * @summary List the collaborators
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoreCollaborators(score: string, sharingKey?: string, options?: any): AxiosPromise<Array<ResourceCollaborator>> {
            return localVarFp.getScoreCollaborators(score, sharingKey, options).then((request) => request(axios, basePath));
        },
        /**
         * This method lists the different comments added on a music score (documents and inline) sorted by their post dates.
         * @summary List comments
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {GetScoreCommentsTypeEnum} [type] Filter the comments by type
         * @param {GetScoreCommentsSortEnum} [sort] Sort
         * @param {GetScoreCommentsDirectionEnum} [direction] Sort direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoreComments(score: string, sharingKey?: string, type?: GetScoreCommentsTypeEnum, sort?: GetScoreCommentsSortEnum, direction?: GetScoreCommentsDirectionEnum, options?: any): AxiosPromise<Array<ScoreComment>> {
            return localVarFp.getScoreComments(score, sharingKey, type, sort, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * When creating a score or saving a new version of a score, a revision is created in our storage. This method allows you to get a specific revision metadata. 
         * @summary Get a score revision
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} revision Unique identifier of a score revision. You can use &#x60;last&#x60; to fetch the information related to the last version created. 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoreRevision(score: string, revision: string, sharingKey?: string, options?: any): AxiosPromise<ScoreRevision> {
            return localVarFp.getScoreRevision(score, revision, sharingKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the file corresponding to a score revision (the following formats are available): Flat JSON/Adagio JSON `json`, MusicXML `mxl`/`xml`, MP3 `mp3`, WAV `wav`, MIDI `midi`, a tumbnail of the first page `thumbnail.png` or auto sync points `synchronizationPoints`. 
         * @summary Get a score revision data
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} revision Unique identifier of a score revision. You can use &#x60;last&#x60; to fetch the information related to the last version created. 
         * @param {GetScoreRevisionDataFormatEnum} format The format of the file you will retrieve
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {string} [parts] An optional a set of parts uuid to be exported. This parameter must be composed of parts uuids separated by commas. For example \&quot;59df645f-bb1c-f1b4-b573-d2afc4491f94,34ef645f-1aef-f3bc-1564-34cca4492b87\&quot;. 
         * @param {boolean} [defaultTrack] When &#x60;format&#x60; is &#x60;mp3&#x60;, this property is set to true and the score has a default &#x60;ScoreTrack&#x60; (mp3), this one will be returned instead of the playback file. 
         * @param {boolean} [url] Returns a json with the &#x60;url&#x60; in it instead of redirecting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoreRevisionData(score: string, revision: string, format: GetScoreRevisionDataFormatEnum, sharingKey?: string, parts?: string, defaultTrack?: boolean, url?: boolean, options?: any): AxiosPromise<File> {
            return localVarFp.getScoreRevisionData(score, revision, format, sharingKey, parts, defaultTrack, url, options).then((request) => request(axios, basePath));
        },
        /**
         * When creating a score or saving a new version of a score, a revision is created in our storage. This method allows you to list all of them, sorted by last modification.  Depending the plan of the account, this list can be trunked to the few last revisions. 
         * @summary List the revisions
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoreRevisions(score: string, sharingKey?: string, options?: any): AxiosPromise<Array<ScoreRevision>> {
            return localVarFp.getScoreRevisions(score, sharingKey, options).then((request) => request(axios, basePath));
        },
        /**
         * This API call will list the different assignments submissions where the score is attached. This method can be used by anyone that are part of the organization and have at least read access to the document. 
         * @summary List submissions related to the score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoreSubmissions(score: string, options?: any): AxiosPromise<Array<AssignmentSubmission>> {
            return localVarFp.getScoreSubmissions(score, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the details of an audio or video track linked to a score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} track Unique identifier of a score audio track 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoreTrack(score: string, track: string, sharingKey?: string, options?: any): AxiosPromise<ScoreTrack> {
            return localVarFp.getScoreTrack(score, track, sharingKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List liked scores
         * @param {string} user Unique identifier of a Flat user. If you authenticated, you can use &#x60;me&#x60; to refer to the current user. 
         * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {number} [limit] This is the maximum number of objects that may be returned
         * @param {boolean} [ids] Return only the identifiers of the scores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserLikes(user: string, next?: string, previous?: string, limit?: number, ids?: boolean, options?: any): AxiosPromise<Array<ScoreDetails>> {
            return localVarFp.getUserLikes(user, next, previous, limit, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of public scores owned by a User.  **DEPRECATED**: Please note that the current behavior will be deprecrated on **2019-01-01**. This method will no longer list private and shared scores, but only public scores of a Flat account. If you want to access to private scores, please use the [Collections API](#tag/Collection) instead. 
         * @summary List user\'s scores
         * @param {string} user Unique identifier of a Flat user. If you authenticated, you can use &#x60;me&#x60; to refer to the current user. 
         * @param {string} [parent] Filter the score forked from the score id &#x60;parent&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserScores(user: string, parent?: string, options?: any): AxiosPromise<Array<ScoreDetails>> {
            return localVarFp.getUserScores(user, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the audio or video tracks linked to a score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {string} [assignment] An assignment id with which all the tracks returned will be related to 
         * @param {boolean} [listAutoTrack] If true, and if available, return last automatically synchronized Flat\&#39;s mp3 export as an additional track 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScoreTracks(score: string, sharingKey?: string, assignment?: string, listAutoTrack?: boolean, options?: any): AxiosPromise<Array<ScoreTrack>> {
            return localVarFp.listScoreTracks(score, sharingKey, assignment, listAutoTrack, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark the comment as resolved
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} comment Unique identifier of a sheet music comment 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markScoreCommentResolved(score: string, comment: string, sharingKey?: string, options?: any): AxiosPromise<void> {
            return localVarFp.markScoreCommentResolved(score, comment, sharingKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark the comment as unresolved
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} comment Unique identifier of a sheet music comment 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markScoreCommentUnresolved(score: string, comment: string, sharingKey?: string, options?: any): AxiosPromise<void> {
            return localVarFp.markScoreCommentUnresolved(score, comment, sharingKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Post a document or a contextualized comment on a document.  Please note that this method includes an anti-spam system for public scores. We don\'t guarantee that your comments will be accepted and displayed to end-user. Comments are be blocked by returning a `403` HTTP error and hidden from other users when the `spam` property is `true`. 
         * @summary Post a new comment
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {ScoreCommentCreation} body 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScoreComment(score: string, body: ScoreCommentCreation, sharingKey?: string, options?: any): AxiosPromise<ScoreComment> {
            return localVarFp.postScoreComment(score, body, sharingKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove the specified collaborator from the score 
         * @summary Delete a collaborator
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} collaborator Unique identifier of a **collaborator permission**, or unique identifier of a **User**, or unique identifier of a **Group** 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeScoreCollaborator(score: string, collaborator: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeScoreCollaborator(score, collaborator, options).then((request) => request(axios, basePath));
        },
        /**
         * This method will remove the score from the `trash` collection and from the deletion queue, and add it back to the original collections. 
         * @summary Untrash a score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        untrashScore(score: string, options?: any): AxiosPromise<void> {
            return localVarFp.untrashScore(score, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing comment
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} comment Unique identifier of a sheet music comment 
         * @param {ScoreCommentUpdate} body 
         * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScoreComment(score: string, comment: string, body: ScoreCommentUpdate, sharingKey?: string, options?: any): AxiosPromise<ScoreComment> {
            return localVarFp.updateScoreComment(score, comment, body, sharingKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an audio or video track linked to a score
         * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
         * @param {string} track Unique identifier of a score audio track 
         * @param {ScoreTrackUpdate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScoreTrack(score: string, track: string, body: ScoreTrackUpdate, options?: any): AxiosPromise<ScoreTrack> {
            return localVarFp.updateScoreTrack(score, track, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScoreApi - object-oriented interface
 * @export
 * @class ScoreApi
 * @extends {BaseAPI}
 */
export class ScoreApi extends BaseAPI {
    /**
     * Share a score with a single user or a group. This API call allows to add, invite and update the collaborators of a resource. - To add an existing Flat user to the resource, specify its unique identifier in the `user` property. - To invite an external user to the resource, specify its email in the `userEmail` property. - To add a Flat group to the resource, specify its unique identifier in the `group` property. - To update an existing collaborator, process the same request with different rights. 
     * @summary Add a new collaborator
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {ResourceCollaboratorCreation} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public addScoreCollaborator(score: string, body: ResourceCollaboratorCreation, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).addScoreCollaborator(score, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to add new track to the score. This track can then be played on flat.io or in an embedded score. This API method support medias hosted on SoundCloud, YouTube and Vimeo. 
     * @summary Add a new video or audio track to the score
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {ScoreTrackCreation} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public addScoreTrack(score: string, body: ScoreTrackCreation, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).addScoreTrack(score, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Some of the exports of a score takes are longer to process than a simple API requests. Use this endpoint to launch a new export of one score hosted on Flat. 
     * @summary Create a new score export task
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {string} revision Unique identifier of a score revision. You can use &#x60;last&#x60; to fetch the information related to the last version created. 
     * @param {CreateExportTaskFormatEnum} format The format of the file that will be generated or the target service name where the file will be exported
     * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
     * @param {TaskExportOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public createExportTask(score: string, revision: string, format: CreateExportTaskFormatEnum, sharingKey?: string, body?: TaskExportOptions, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).createExportTask(score, revision, format, sharingKey, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API method to **create a new music score in the current User account**. This API endpoints provides 3 ways to create scores:  * `ScoreCreationBuilderData` : Create a blank score by providing the list of instruments to use. You can optionally customize the initial key signature, time signature, enable TABs, Chord grids, as well as the page layout. * `ScoreCreationFileImport`: Import an existing MusicXML 3 file (`vnd.recordare.musicxml` or `vnd.recordare.musicxml+xml`), a MIDI file (`audio/midi`), Guitar Pro (GP3, GP4, GP5, GPX, GP), PowerTab, TuxGuitar, or MuseScore file to create the new Flat document. * `ScoreCreationGoogleDriveImport`: Import an existing Google Drive file from the connected Google Drive account.  This API call will automatically create the first revision of the document, the score can be modified by the using our web application or by uploading a new revision of this file (`POST /v2/scores/{score}/revisions/{revision}`).  The currently authenticated user will be granted owner of the file and will be able to add other collaborators (users and groups).  If no `collection` is specified, the API will create the score in the most appropriate collection. When using an OAuth2 access token or a personal token, the score will be automatically added to your dedicated app collection in the account (`/v2/collections/app`).  If a `collection` is specified and this one has more public privacy settings than the score (e.g. `public` vs `private` for the score), the privacy settings of the created score will be adjusted to the collection ones.  You can check the adjusted privacy settings in the returned score `privacy`, and optionally adjust these settings if needed using `PUT /scores/{score}`. 
     * @summary Create a new score
     * @param {ScoreCreation} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public createScore(body: ScoreCreation, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).createScore(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a score by uploading a new revision for this one. 
     * @summary Create a new revision
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {ScoreRevisionCreation} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public createScoreRevision(score: string, body: ScoreRevisionCreation, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).createScoreRevision(score, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method can be used by the owner/admin (`aclAdmin` rights) of a score as well as regular collaborators.  When called by an owner/admin, it will schedule the deletion of the score, its revisions, and complete history. The score won\'t be accessible anymore after calling this method and the user\'s quota will directly be updated.  When called by a regular collaborator (`aclRead` / `aclWrite`), the score will be unshared (i.e. removed from the account & own collections). 
     * @summary Delete a score
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {boolean} [now] If &#x60;true&#x60;, the score deletion will be scheduled to be done ASAP
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public deleteScore(score: string, now?: boolean, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).deleteScore(score, now, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a comment
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {string} comment Unique identifier of a sheet music comment 
     * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public deleteScoreComment(score: string, comment: string, sharingKey?: string, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).deleteScoreComment(score, comment, sharingKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an audio or video track linked to the score
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {string} track Unique identifier of a score audio track 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public deleteScoreTrack(score: string, track: string, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).deleteScoreTrack(score, track, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API method allows you to change the metadata of a score document (e.g. its `title` or `privacy`), all the properties are optional.  To edit the file itself, create a new revision using the appropriate method (`POST /v2/scores/{score}/revisions/{revision}`).  When editing the `title`, `subtitle`, `composer`, `lyricist`, `arranger` or `licenseText`, the metadatas will be instantly be updated, and a real-time action will be pushed to update the document lazily. This pending document modification will be automatically be saved as a new version by either a connected client or our internal versioning service. 
     * @summary Edit a score\'s metadata
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {ScoreModification} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public editScore(score: string, body: ScoreModification, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).editScore(score, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API call will make a copy of the last revision of the specified score and create a new score. The copy of the score will have a privacy set to `private`.  When using a [Flat for Education](https://flat.io/edu) account, the inline and contextualized comments will be accessible in the child document. 
     * @summary Fork a score
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {ScoreFork} body 
     * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public forkScore(score: string, body: ScoreFork, sharingKey?: string, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).forkScore(score, body, sharingKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the list of scores shared with a group. 
     * @summary List group\'s scores
     * @param {string} group Unique identifier of a Flat group 
     * @param {string} [parent] Filter the score forked from the score id &#x60;parent&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public getGroupScores(group: string, parent?: string, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).getGroupScores(group, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the details of a score identified by the `score` parameter in the URL. The currently authenticated user must have at least a read access to the document to use this API call. 
     * @summary Get a score\'s metadata
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public getScore(score: string, sharingKey?: string, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).getScore(score, sharingKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the information about a collaborator (User or Group). 
     * @summary Get a collaborator
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {string} collaborator Unique identifier of a **collaborator permission**, or unique identifier of a **User**, or unique identifier of a **Group** 
     * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public getScoreCollaborator(score: string, collaborator: string, sharingKey?: string, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).getScoreCollaborator(score, collaborator, sharingKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API call will list the different collaborators of a score and their rights on the document. The returned list will at least contain the owner of the document.  Collaborators can be a single user (the object `user` will be populated) or a group (the object `group` will be populated). 
     * @summary List the collaborators
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public getScoreCollaborators(score: string, sharingKey?: string, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).getScoreCollaborators(score, sharingKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method lists the different comments added on a music score (documents and inline) sorted by their post dates.
     * @summary List comments
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
     * @param {GetScoreCommentsTypeEnum} [type] Filter the comments by type
     * @param {GetScoreCommentsSortEnum} [sort] Sort
     * @param {GetScoreCommentsDirectionEnum} [direction] Sort direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public getScoreComments(score: string, sharingKey?: string, type?: GetScoreCommentsTypeEnum, sort?: GetScoreCommentsSortEnum, direction?: GetScoreCommentsDirectionEnum, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).getScoreComments(score, sharingKey, type, sort, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When creating a score or saving a new version of a score, a revision is created in our storage. This method allows you to get a specific revision metadata. 
     * @summary Get a score revision
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {string} revision Unique identifier of a score revision. You can use &#x60;last&#x60; to fetch the information related to the last version created. 
     * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public getScoreRevision(score: string, revision: string, sharingKey?: string, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).getScoreRevision(score, revision, sharingKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the file corresponding to a score revision (the following formats are available): Flat JSON/Adagio JSON `json`, MusicXML `mxl`/`xml`, MP3 `mp3`, WAV `wav`, MIDI `midi`, a tumbnail of the first page `thumbnail.png` or auto sync points `synchronizationPoints`. 
     * @summary Get a score revision data
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {string} revision Unique identifier of a score revision. You can use &#x60;last&#x60; to fetch the information related to the last version created. 
     * @param {GetScoreRevisionDataFormatEnum} format The format of the file you will retrieve
     * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
     * @param {string} [parts] An optional a set of parts uuid to be exported. This parameter must be composed of parts uuids separated by commas. For example \&quot;59df645f-bb1c-f1b4-b573-d2afc4491f94,34ef645f-1aef-f3bc-1564-34cca4492b87\&quot;. 
     * @param {boolean} [defaultTrack] When &#x60;format&#x60; is &#x60;mp3&#x60;, this property is set to true and the score has a default &#x60;ScoreTrack&#x60; (mp3), this one will be returned instead of the playback file. 
     * @param {boolean} [url] Returns a json with the &#x60;url&#x60; in it instead of redirecting 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public getScoreRevisionData(score: string, revision: string, format: GetScoreRevisionDataFormatEnum, sharingKey?: string, parts?: string, defaultTrack?: boolean, url?: boolean, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).getScoreRevisionData(score, revision, format, sharingKey, parts, defaultTrack, url, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When creating a score or saving a new version of a score, a revision is created in our storage. This method allows you to list all of them, sorted by last modification.  Depending the plan of the account, this list can be trunked to the few last revisions. 
     * @summary List the revisions
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public getScoreRevisions(score: string, sharingKey?: string, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).getScoreRevisions(score, sharingKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API call will list the different assignments submissions where the score is attached. This method can be used by anyone that are part of the organization and have at least read access to the document. 
     * @summary List submissions related to the score
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public getScoreSubmissions(score: string, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).getScoreSubmissions(score, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the details of an audio or video track linked to a score
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {string} track Unique identifier of a score audio track 
     * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public getScoreTrack(score: string, track: string, sharingKey?: string, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).getScoreTrack(score, track, sharingKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List liked scores
     * @param {string} user Unique identifier of a Flat user. If you authenticated, you can use &#x60;me&#x60; to refer to the current user. 
     * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
     * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
     * @param {number} [limit] This is the maximum number of objects that may be returned
     * @param {boolean} [ids] Return only the identifiers of the scores
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public getUserLikes(user: string, next?: string, previous?: string, limit?: number, ids?: boolean, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).getUserLikes(user, next, previous, limit, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the list of public scores owned by a User.  **DEPRECATED**: Please note that the current behavior will be deprecrated on **2019-01-01**. This method will no longer list private and shared scores, but only public scores of a Flat account. If you want to access to private scores, please use the [Collections API](#tag/Collection) instead. 
     * @summary List user\'s scores
     * @param {string} user Unique identifier of a Flat user. If you authenticated, you can use &#x60;me&#x60; to refer to the current user. 
     * @param {string} [parent] Filter the score forked from the score id &#x60;parent&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public getUserScores(user: string, parent?: string, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).getUserScores(user, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the audio or video tracks linked to a score
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
     * @param {string} [assignment] An assignment id with which all the tracks returned will be related to 
     * @param {boolean} [listAutoTrack] If true, and if available, return last automatically synchronized Flat\&#39;s mp3 export as an additional track 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public listScoreTracks(score: string, sharingKey?: string, assignment?: string, listAutoTrack?: boolean, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).listScoreTracks(score, sharingKey, assignment, listAutoTrack, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark the comment as resolved
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {string} comment Unique identifier of a sheet music comment 
     * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public markScoreCommentResolved(score: string, comment: string, sharingKey?: string, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).markScoreCommentResolved(score, comment, sharingKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark the comment as unresolved
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {string} comment Unique identifier of a sheet music comment 
     * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public markScoreCommentUnresolved(score: string, comment: string, sharingKey?: string, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).markScoreCommentUnresolved(score, comment, sharingKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Post a document or a contextualized comment on a document.  Please note that this method includes an anti-spam system for public scores. We don\'t guarantee that your comments will be accepted and displayed to end-user. Comments are be blocked by returning a `403` HTTP error and hidden from other users when the `spam` property is `true`. 
     * @summary Post a new comment
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {ScoreCommentCreation} body 
     * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public postScoreComment(score: string, body: ScoreCommentCreation, sharingKey?: string, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).postScoreComment(score, body, sharingKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove the specified collaborator from the score 
     * @summary Delete a collaborator
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {string} collaborator Unique identifier of a **collaborator permission**, or unique identifier of a **User**, or unique identifier of a **Group** 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public removeScoreCollaborator(score: string, collaborator: string, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).removeScoreCollaborator(score, collaborator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method will remove the score from the `trash` collection and from the deletion queue, and add it back to the original collections. 
     * @summary Untrash a score
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public untrashScore(score: string, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).untrashScore(score, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing comment
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {string} comment Unique identifier of a sheet music comment 
     * @param {ScoreCommentUpdate} body 
     * @param {string} [sharingKey] This sharing key must be specified to access to a score or collection with a &#x60;privacy&#x60; mode set to &#x60;privateLink&#x60; and the current user is not a collaborator of the document. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public updateScoreComment(score: string, comment: string, body: ScoreCommentUpdate, sharingKey?: string, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).updateScoreComment(score, comment, body, sharingKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an audio or video track linked to a score
     * @param {string} score Unique identifier of the score document. This can be a Flat Score unique identifier (i.e. &#x60;ScoreDetails.id&#x60;) or, if the score is also a Google Drive file, the Drive file unique identifier prefixed with &#x60;drive-&#x60; (e.g. &#x60;drive-0B000000000&#x60;). 
     * @param {string} track Unique identifier of a score audio track 
     * @param {ScoreTrackUpdate} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreApi
     */
    public updateScoreTrack(score: string, track: string, body: ScoreTrackUpdate, options?: RawAxiosRequestConfig) {
        return ScoreApiFp(this.configuration).updateScoreTrack(score, track, body, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CreateExportTaskFormatEnum = {
    Mp3: 'mp3',
    Wav: 'wav',
    Practicefirst: 'practicefirst'
} as const;
export type CreateExportTaskFormatEnum = typeof CreateExportTaskFormatEnum[keyof typeof CreateExportTaskFormatEnum];
/**
 * @export
 */
export const GetScoreCommentsTypeEnum = {
    Document: 'document',
    Inline: 'inline'
} as const;
export type GetScoreCommentsTypeEnum = typeof GetScoreCommentsTypeEnum[keyof typeof GetScoreCommentsTypeEnum];
/**
 * @export
 */
export const GetScoreCommentsSortEnum = {
    Date: 'date'
} as const;
export type GetScoreCommentsSortEnum = typeof GetScoreCommentsSortEnum[keyof typeof GetScoreCommentsSortEnum];
/**
 * @export
 */
export const GetScoreCommentsDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetScoreCommentsDirectionEnum = typeof GetScoreCommentsDirectionEnum[keyof typeof GetScoreCommentsDirectionEnum];
/**
 * @export
 */
export const GetScoreRevisionDataFormatEnum = {
    Json: 'json',
    Mxl: 'mxl',
    Xml: 'xml',
    Mp3: 'mp3',
    Wav: 'wav',
    Midi: 'midi',
    ThumbnailPng: 'thumbnail.png',
    SynchronizationPoints: 'synchronizationPoints'
} as const;
export type GetScoreRevisionDataFormatEnum = typeof GetScoreRevisionDataFormatEnum[keyof typeof GetScoreRevisionDataFormatEnum];


/**
 * TaskApi - axios parameter creator
 * @export
 */
export const TaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This method can be used to follow a task progression, for example while a score is being exported. 
         * @summary Get a task details
         * @param {string} task Unique identifier for the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask: async (task: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'task' is not null or undefined
            assertParamExists('getTask', 'task', task)
            const localVarPath = `/tasks/{task}`
                .replace(`{${"task"}}`, encodeURIComponent(String(task)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["tasks.readonly"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskApi - functional programming interface
 * @export
 */
export const TaskApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskApiAxiosParamCreator(configuration)
    return {
        /**
         * This method can be used to follow a task progression, for example while a score is being exported. 
         * @summary Get a task details
         * @param {string} task Unique identifier for the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTask(task: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTask(task, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskApi.getTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TaskApi - factory interface
 * @export
 */
export const TaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskApiFp(configuration)
    return {
        /**
         * This method can be used to follow a task progression, for example while a score is being exported. 
         * @summary Get a task details
         * @param {string} task Unique identifier for the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(task: string, options?: any): AxiosPromise<Task> {
            return localVarFp.getTask(task, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export class TaskApi extends BaseAPI {
    /**
     * This method can be used to follow a task progression, for example while a score is being exported. 
     * @summary Get a task details
     * @param {string} task Unique identifier for the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getTask(task: string, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).getTask(task, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a profile of a Flat or Flat for Education User. 
         * @summary Get a public user profile
         * @param {string} user This route parameter is the unique identifier of the user. You can specify an email instead of an unique identifier. If you are executing this request authenticated, you can use &#x60;me&#x60; as a value instead of the current User unique identifier to work on the current authenticated user. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (user: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getUser', 'user', user)
            const localVarPath = `/users/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["account.public_profile", "account.education_profile"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List liked scores
         * @param {string} user Unique identifier of a Flat user. If you authenticated, you can use &#x60;me&#x60; to refer to the current user. 
         * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {number} [limit] This is the maximum number of objects that may be returned
         * @param {boolean} [ids] Return only the identifiers of the scores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserLikes: async (user: string, next?: string, previous?: string, limit?: number, ids?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getUserLikes', 'user', user)
            const localVarPath = `/users/{user}/likes`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["account.public_profile"], configuration)

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (previous !== undefined) {
                localVarQueryParameter['previous'] = previous;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of public scores owned by a User.  **DEPRECATED**: Please note that the current behavior will be deprecrated on **2019-01-01**. This method will no longer list private and shared scores, but only public scores of a Flat account. If you want to access to private scores, please use the [Collections API](#tag/Collection) instead. 
         * @summary List user\'s scores
         * @param {string} user Unique identifier of a Flat user. If you authenticated, you can use &#x60;me&#x60; to refer to the current user. 
         * @param {string} [parent] Filter the score forked from the score id &#x60;parent&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserScores: async (user: string, parent?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getUserScores', 'user', user)
            const localVarPath = `/users/{user}/scores`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["scores", "scores.readonly"], configuration)

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a profile of a Flat or Flat for Education User. 
         * @summary Get a public user profile
         * @param {string} user This route parameter is the unique identifier of the user. You can specify an email instead of an unique identifier. If you are executing this request authenticated, you can use &#x60;me&#x60; as a value instead of the current User unique identifier to work on the current authenticated user. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(user: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List liked scores
         * @param {string} user Unique identifier of a Flat user. If you authenticated, you can use &#x60;me&#x60; to refer to the current user. 
         * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {number} [limit] This is the maximum number of objects that may be returned
         * @param {boolean} [ids] Return only the identifiers of the scores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserLikes(user: string, next?: string, previous?: string, limit?: number, ids?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScoreDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserLikes(user, next, previous, limit, ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserLikes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the list of public scores owned by a User.  **DEPRECATED**: Please note that the current behavior will be deprecrated on **2019-01-01**. This method will no longer list private and shared scores, but only public scores of a Flat account. If you want to access to private scores, please use the [Collections API](#tag/Collection) instead. 
         * @summary List user\'s scores
         * @param {string} user Unique identifier of a Flat user. If you authenticated, you can use &#x60;me&#x60; to refer to the current user. 
         * @param {string} [parent] Filter the score forked from the score id &#x60;parent&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserScores(user: string, parent?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScoreDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserScores(user, parent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserScores']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Get a profile of a Flat or Flat for Education User. 
         * @summary Get a public user profile
         * @param {string} user This route parameter is the unique identifier of the user. You can specify an email instead of an unique identifier. If you are executing this request authenticated, you can use &#x60;me&#x60; as a value instead of the current User unique identifier to work on the current authenticated user. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(user: string, options?: any): AxiosPromise<UserPublic> {
            return localVarFp.getUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List liked scores
         * @param {string} user Unique identifier of a Flat user. If you authenticated, you can use &#x60;me&#x60; to refer to the current user. 
         * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
         * @param {number} [limit] This is the maximum number of objects that may be returned
         * @param {boolean} [ids] Return only the identifiers of the scores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserLikes(user: string, next?: string, previous?: string, limit?: number, ids?: boolean, options?: any): AxiosPromise<Array<ScoreDetails>> {
            return localVarFp.getUserLikes(user, next, previous, limit, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of public scores owned by a User.  **DEPRECATED**: Please note that the current behavior will be deprecrated on **2019-01-01**. This method will no longer list private and shared scores, but only public scores of a Flat account. If you want to access to private scores, please use the [Collections API](#tag/Collection) instead. 
         * @summary List user\'s scores
         * @param {string} user Unique identifier of a Flat user. If you authenticated, you can use &#x60;me&#x60; to refer to the current user. 
         * @param {string} [parent] Filter the score forked from the score id &#x60;parent&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserScores(user: string, parent?: string, options?: any): AxiosPromise<Array<ScoreDetails>> {
            return localVarFp.getUserScores(user, parent, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Get a profile of a Flat or Flat for Education User. 
     * @summary Get a public user profile
     * @param {string} user This route parameter is the unique identifier of the user. You can specify an email instead of an unique identifier. If you are executing this request authenticated, you can use &#x60;me&#x60; as a value instead of the current User unique identifier to work on the current authenticated user. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(user: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List liked scores
     * @param {string} user Unique identifier of a Flat user. If you authenticated, you can use &#x60;me&#x60; to refer to the current user. 
     * @param {string} [next] An opaque string cursor to fetch the next page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
     * @param {string} [previous] An opaque string cursor to fetch the previous page of data. The paginated API URLs are returned in the &#x60;Link&#x60; header when requesting the API. These URLs will contain a &#x60;next&#x60; and &#x60;previous&#x60; cursor based on the available data. 
     * @param {number} [limit] This is the maximum number of objects that may be returned
     * @param {boolean} [ids] Return only the identifiers of the scores
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserLikes(user: string, next?: string, previous?: string, limit?: number, ids?: boolean, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserLikes(user, next, previous, limit, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the list of public scores owned by a User.  **DEPRECATED**: Please note that the current behavior will be deprecrated on **2019-01-01**. This method will no longer list private and shared scores, but only public scores of a Flat account. If you want to access to private scores, please use the [Collections API](#tag/Collection) instead. 
     * @summary List user\'s scores
     * @param {string} user Unique identifier of a Flat user. If you authenticated, you can use &#x60;me&#x60; to refer to the current user. 
     * @param {string} [parent] Filter the score forked from the score id &#x60;parent&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserScores(user: string, parent?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserScores(user, parent, options).then((request) => request(this.axios, this.basePath));
    }
}



